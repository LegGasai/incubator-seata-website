"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[33067],{87841:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=t(74848),i=t(28453);const r={title:"Seata AT Mode Startup Source Code Analysis",author:"chenghui.zhang",keywords:["Seata","distributed transaction","AT mode"],description:"Seata Source Code Analysis Series",date:"2019/11/27"},o="Preface",s={permalink:"/blog/seata-at-mode-start",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-at-mode-start.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-at-mode-start.md",title:"Seata AT Mode Startup Source Code Analysis",description:"Seata Source Code Analysis Series",date:"2019-11-27T00:00:00.000Z",formattedDate:"November 27, 2019",tags:[],readingTime:12.435,hasTruncateMarker:!1,authors:[{name:"chenghui.zhang"}],frontMatter:{title:"Seata AT Mode Startup Source Code Analysis",author:"chenghui.zhang",keywords:["Seata","distributed transaction","AT mode"],description:"Seata Source Code Analysis Series",date:"2019/11/27"},unlisted:!1,prevItem:{title:"Does Seata Client Need to Start RM and TM Simultaneously?",permalink:"/blog/seata-at-mode-start-rm-tm"},nextItem:{title:"Designing More Flexible Financial Applications with Seata Saga",permalink:"/blog/design-more-flexable-application-by-saga"}},c={authorsImageUrls:[void 0]},l=[];function h(e){const n={a:"a",code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:['From the previous article "',(0,a.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/Pypkm5C9aLPJHYwcM6tAtA",children:"Design Principles of Distributed Transaction Middleware Seata"}),'", we talked about some design principles of Seata AT pattern, from which we also know the three roles of AT pattern (RM, TM, TC). I will update the Seata source code analysis series. Today, we are going to analyse what Seata AT mode does at startup.']}),"\n",(0,a.jsx)(n.h1,{id:"client-startup-logic",children:"Client Startup Logic"}),"\n",(0,a.jsx)(n.p,{children:"TM is responsible for the whole global transaction manager, so a global transaction is started by TM, TM has a global management class GlobalTransaction, the structure is as follows:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.tm.api.GlobalTransaction"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public interface GlobalTransaction {\n\nvoid begin() throws TransactionException.\n\nvoid begin(int timeout) throws TransactionException.\n\nvoid begin(int timeout, String name) throws TransactionException; void commit() throws TransactionException.\n\nvoid commit() throws TransactionException.\n\nvoid rollback() throws TransactionException.\n\nGlobalStatus getStatus() throws TransactionException; // ...\n\n// ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"It is possible to create a GlobalTransaction via GlobalTransactionContext and then use the GlobalTransaction to open, commit, rollback, etc., a global transaction, so we're using the Seata AT mode directly in an API way:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'//init seata; TMClient.init(application)\nTMClient.init(applicationId, txServiceGroup); RMClient.init(applicationId, txServiceGroup)\nRMClient.init(applicationId, txServiceGroup);\n//trx\nGlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();\ntry {\n  tx.begin(60000, "testBiz");\n  // Transaction\n  // ...\n  tx.commit(); } catch (Exception exx)\n} catch (Exception exx) {\n  tx.rollback(); } catch (Exception exx) { tx.rollback(); }\n  throw exx; } catch (Exception exx) { tx.rollback(); throw exx; }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"If you write this every time you use a global transaction, it will inevitably cause code redundancy, our projects are based on the Spring container, we can use the characteristics of Spring AOP, with template patterns to encapsulate this redundant code in the template, reference Mybatis-spring also does this thing, so let's analyse what a Spring-based So let's analyse what a Spring-based project does when it starts Seata and registers a global transaction."}),"\n",(0,a.jsxs)(n.p,{children:["We enable a global transaction by adding the ",(0,a.jsx)(n.code,{children:"@GlobalTransactional"})," annotation to the method. Seata's Spring module has a GlobalTransactionScanner, which has the following inheritance relationship:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class GlobalTransactionScanner extends AbstractAutoProxyCreator implements InitialisingBean, ApplicationContextAware, DisposableBean {\n// ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"During the startup of a Spring-based project, the following initialisation process occurs for this class:"}),"\n",(0,a.jsxs)(n.p,{children:["! ",(0,a.jsx)(n.a,{href:"https://gitee.com/objcoding/md-picture/raw/master/img/image-20191124155455309.png",children:"image-20191124155455309"})]}),"\n",(0,a.jsx)(n.p,{children:"The afterPropertiesSet() method of InitialisingBean calls the initClient() method:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.spring.annotation.GlobalTransactionScanner#initClient"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"TMClient.init(applicationId, txServiceGroup);\nRMClient.init(applicationId, txServiceGroup).\n"})}),"\n",(0,a.jsx)(n.p,{children:"Initialisation operations are done for TM and RM."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"TM initialisation"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"io.seata.tm.TMClient#init"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static void init(String applicationId, String transactionServiceGroup) {\n  // Get the TmRpcClient instance.\n  TmRpcClient tmRpcClient = TmRpcClient.getInstance(applicationId, transactionServiceGroup); // Initialise the TM Client.\n  // Initialise the TM Client\n  tmRpcClient.init();\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Calling the TmRpcClient.getInstance() method acquires an instance of the TM Client, and during the acquisition process creates the Netty Client Profile object, as well as the messageExecutor thread pool, which is used to handle various message interactions with the server, and during the creation of the TmRpcClient instance, the Create a ClientBootstrap, which is used to manage the start and stop of the Netty service, and a ClientChannelManager, which is used to manage the Netty client object pool, which is used in conjunction with the Netty part of Seata, and which will be discussed later in the Analysing Networks module."}),"\n",(0,a.jsx)(n.p,{children:"io.seata.core.rpc.netty.AbstractRpcRemotingClient#init"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public void init() {\n  clientBootstrap.start();\n  // Timer to try to connect to the server\n  timerExecutor.scheduleAtFixedRate(new Runnable() {\n    @Override\n    public void run() {\n      clientChannelManager.reconnect(getTransactionServiceGroup());\n    }\n  }, SCHEDULE_INTERVAL_MILLS, SCHEDULE_INTERVAL_MILLS, TimeUnit.SECONDS);\n  mergeSendExecutorService = new ThreadPoolExecutor(MAX_MERGE_SEND_THREAD,\n                                                    MAX_MERGE_SEND_THREAD, MAX_MERGE_SEND_THREAD, KEEP_ALIVE_TIME\n                                                    KEEP_ALIVE_TIME, TimeUnit.\n                                                    new LinkedBlockingQueue<>(),\n                                                    new NamedThreadFactory(getThreadPrefix(), MAX_MERGE_SEND_THREAD));\n  mergeSendExecutorService.submit(new MergedSendRunnable());\n  super.init();\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Calling the TM client init() method will eventually start the netty client (it's not really started yet, it will be started when the object pool is called); a timed task is started to resend the RegisterTMRequest (the RM client sends the RegisterRMRequest) request to try to connect to the server, the logic for this is The logic is that the client channel is cached in channels in the NettyClientChannelManager, so if the channels don't exist and are out of date, then it will try to connect to the server in order to fetch the channel again and cache it in channels; a separate thread is started to handle asynchronous request sending. This is a very clever use of the network module, which will be analysed later in the analysis."}),"\n",(0,a.jsx)(n.p,{children:"io.seata.core.rpc.netty.AbstractRpcRemoting#init"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public void init() {\ntimerExecutor.scheduleAtFixedRate(new Runnable() {\npublic void run() { scheduleAtFixedRate(new Runnable() {\npublic void run() {\nfor (Map.Entry<Integer, MessageFuture> entry : futures.entrySet()) {\nif (entry.getValue().isTimeout()) {\nfutures.remove(entry.getKey());\nentry.getValue().setResultMessage(null);\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug("timeout clear future: {}", entry.getValue().getRequestMessage().getBody());\n}\n}\n}\n\n      nowMills = System.currentTimeMillis();\n    }\n}, TIMEOUT_CHECK_INTERNAL, TIMEOUT_CHECK_INTERNAL, TimeUnit.MILLISECONDS);\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"In the init method of AbstractRpcRemoting, it opens a timer task, which is mainly used to clear the expired futrue of futures. futures is a future object that saves the results of sending requests, and this object has a timeout period, after which an exception will be thrown. Therefore, you need to clear the expired futures regularly."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"RM Initialisation"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"io.seata.rm.RMClient#init\npublic static void init(String applicationId, String transactionServiceGroup) {\n  RmRpcClient rmRpcClient = RmRpcClient.getInstance(applicationId, transactionServiceGroup);\n  rmRpcClient.setResourceManager(DefaultResourceManager.get());\n  rmRpcClient.setClientMessageListener(new RmMessageListener(DefaultRMHandler.get());\n  rmRpcClient.init();\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"RmRpcClient.getInstance handles the same logic as the TM; ResourceManager is the RM resource manager responsible for branch transaction registration, commit, report, and rollback operations, as well as global lock querying operations, and DefaultResourceManager will hold all current RM resource managers. The DefaultResourceManager holds all current RM resource managers. DefaultResourceManager will hold all the current RM resource managers for unified call processing, and get() method is mainly to load the current resource manager, mainly using a mechanism similar to SPI, for flexible loading, as shown in the following figure, Seata will scan the META- INF/services/ directory for configuration classes and load them dynamically."}),"\n",(0,a.jsx)(n.p,{children:"ClientMessageListener is a RM message listener, which is responsible for processing commands sent from TC and performing branch commit, branch rollback, and undo log deletion operations on the branch; finally, the init method follows the same logic as the TM; DefaultRMHandler encapsulates some of the specific operation logic of RM branching transactions. logic."}),"\n",(0,a.jsx)(n.p,{children:"Let's take a look at what the wrapIfNecessary method does."}),"\n",(0,a.jsx)(n.p,{children:"io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { // Determine if there is a global transaction scanner turned on?\n// Determine if global transactions are enabled\nif (disableGlobalTransaction) {\nReturns the bean;\n}\ntry {\nsynchronized (PROXYED_SET) {\nif (PROXYED_SET.contains(beanName)) {\nReturn the bean;\n}\nInterceptor = null;\n// Check the TCC proxy\nif (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) { //TCC interceptor, proxy bean for sofa:reference/dubbo.\n//TCC interceptor, proxy bean for sofa:reference/dubbo:reference and LocalTCC.\ninterceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName));\n} else {\nClass<? > serviceInterface = SpringProxyUtils.findTargetClass(bean);\nClass<? >[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean);\n\n        // Determine if the bean has the GlobalTransactional and GlobalLock annotations.\n        if (!existsAnnotation(new Class[]{serviceInterface}))\n            && !existsAnnotation(interfacesIfJdk)) {\n          Return the bean;\n        }\n\n        if (interceptor == null) { // create the proxy class\n          // Create the proxy class\n          interceptor = new GlobalTransactionalInterceptor(failureHandlerHook);\n        }\n      }\n\n      LOGGER.info("Bean [{}] with name [{}] would use interceptor [{}]",\n                  bean.getClass().getName(),beanName,interceptor.getClass().getName());\n      if (!AopUtils.isAopProxy(bean)) {\n        bean = super.wrapIfNecessary(bean, beanName, cacheKey);\n      } else {\n        AdvisedSupport advised = SpringProxyUtils.getAdvisedSupport(bean);\n        // Perform wrapping the target object to the proxy object\n        Advisor[] advisor = super.buildAdvisors(beanName, getAdvicesAndAdvisorsForBean(null, null, null));\n        for (Advisor avr : advisor) {\n          advised.addAdvisor(0, avr);\n        }\n      }\n      PROXYED_SET.add(beanName);\n      Returns the bean;\n    }\n} catch (Exception exx) {\nthrow new RuntimeException(exx);\n}\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"GlobalTransactionScanner inherits AbstractAutoProxyCreator for Spring AOP support, and as you can see from the code, GlobalTransactionalInterceptor is used instead of the methods annotated with GlobalTransactional and GlobalLock annotated methods."}),"\n",(0,a.jsx)(n.p,{children:"GlobalTransactionalInterceptor implements MethodInterceptor: method interceptor."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"\nio.seata.spring.annotation.GlobalTransactionalInterceptor#invoke\npublic Object invoke(final MethodInvocation methodInvocation) throws Throwable {\n  Class<? > targetClass = methodInvocation.getThis() ! = null ? AopUtils.getTargetClass(methodInvocation.getThis()) : null;\n  Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);\n  final Method method = BridgeMethodResolver.findBridgedMethod(specificMethod);\n\n  final GlobalTransactional globalTransactionalAnnotation = getAnnotation(method, GlobalTransactional.class);\n  final GlobalLock globalLockAnnotation = getAnnotation(method, GlobalLock.class);\n  if (globalTransactionalAnnotation ! = null) { // globalTransactionalAnnotation !\n    // globalTransactionalAnnotation\n    return handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);\n  } else if (globalLockAnnotation ! = null) { // globalLockAnnotation !\n    // global lock annotation\n    return handleGlobalLock(methodInvocation);\n  } else {\n    return methodInvocation.proceed();\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The above is the logic executed by the proxy method, where the handleGlobalTransaction() method calls the TransactionalTemplate template inside: io.seata.spring.annotation.GlobalTransactionalInterceptor #handleGlobalTransaction()"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.spring.annotation.GlobalTransactionalInterceptor#handleGlobalTransaction"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"private Object handleGlobalTransaction(final MethodInvocation methodInvocation,\n                                       final GlobalTransactional globalTrxAnno) throws Throwable {\n  try {\n    return transactionalTemplate.execute(new TransactionalExecutor() {\n      @Override\n      public Object execute() throws Throwable {\n        return methodInvocation.proceed();\n      }\n      @Override\n      public TransactionInfo getTransactionInfo() {\n        // ...\n      }\n    });\n  } catch (TransactionalExecutor.ExecutionException e) {\n    // ...\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The handleGlobalTransaction() method executes the execute method of the TransactionalTemplate template class:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.tm.api.TransactionalTemplate#execute"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public Object execute(TransactionalExecutor business) throws Throwable {\n// 1. get or create a transaction\nGlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate(); // 1.1 get transactionInfo = GlobalTransactionContext.\n\n// 1.1 get transactionInfo\nTransactionInfo txInfo = business.getTransactionInfo(); if (txInfo = txInfo.getCurrentOrCreate())\nif (txInfo == null) {\nthrow new ShouldNeverHappenException("transactionInfo does not exist"); }\n}\ntry {\n\n    // 2. begin transaction\n\n\n    Object rs = null; } try { // 2.\n    try {\n\n      // Do Your Business\n      rs = business.execute(); } catch (Throwable ex) { // Do Your Business.\n\n    } catch (Throwable ex) {\n\n      // 3. the needed business exception to rollback.\n      completeTransactionAfterThrowing(txInfo,tx,ex); } throw ex; }\n      throw ex; } catch (Throwable ex) { // 3.\n    }\n\n    // 4. everything is fine, commit.\n    commitTransaction(tx); return rs; }\n\n    commitTransaction(tx); return rs.\n} finally {\n} finally { // 5. clear\ntriggerAfterCompletion(); cleanUp(); }\ncleanUp();\n}\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Doesn't the above give you a sense of d\xe9j\xe0 vu? That's right, the above is often written when we use the API redundant code, now Spring through the proxy model, the redundant code are encapsulated with the template inside it, it will be those redundant code is encapsulated in a unified process processing, and do not need to show you write out, interested can also go to look at the source code of the Mybatis-spring, is also written very exciting."}),"\n",(0,a.jsx)(n.h1,{id:"server-side-processing-logic",children:"server-side processing logic"}),"\n",(0,a.jsx)(n.p,{children:"The server receives the client's connection, that is, of course, the channel is also cached up, also said that the client will send RegisterRMRequest/RegisterTMRequest request to the server, the server receives the ServerMessageListener listener will be called to deal with:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.core.rpc.ServerMessageListener"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public interface ServerMessageListener {\n  // Handles various transactions, such as branch registration, branch commit, branch report, branch rollback, etc.\n  void onTrxMessage(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender); // Handle the registration of RM clients.\n\t// Handle the registration of the RM client's connection\n  void onRegRmMessage(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender); // Handle the registration of the RM client.\n                      ServerMessageSender sender, RegisterCheckAuthHandler checkAuthHandler); // Handle the registration of the TM client.\n  // Handle the registration of the TM client's connection.\n  void onRegTmMessage(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender, RegisterCheckAuthHandler checkAuthHandler)\n                      ServerMessageSender sender, RegisterCheckAuthHandler checkAuthHandler); // Handle TM client's registered connection.\n  // The server maintains a heartbeat with the client\n  void onCheckMessage(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender)\n\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"ChannelManager is the manager of the server channel, every time the server communicates with the client, it needs to get the corresponding channel of the client from the ChannelManager, which is used to save the cache structure of the TM and RM client channel as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"/**\n * resourceId -> applicationId -> ip -> port -> RpcContext\n */\nprivate static final ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<Integer.\nRpcContext>>>>\n  RM_CHANNELS = new ConcurrentHashMap<String, ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<Integer, RpcContext\nRpcContext>>>>();\n\n/**\n * ip+appname,port\n */\nprivate static final ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>> TM_CHANNELS\n  = new ConcurrentHashMap<String, ConcurrentMap<Integer, RpcContext>>();\n"})}),"\n",(0,a.jsx)(n.p,{children:"The above Map structure is a bit complicated:"}),"\n",(0,a.jsx)(n.p,{children:"RM_CHANNELS:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"resourceId refers to the database address of the RM client;"}),"\n",(0,a.jsx)(n.li,{children:"applicationId refers to the service Id of the RM client, for example, account-service in springboot's configuration spring.application.name=account-service is the applicationId. 3. ip refers to the service Id of the RM client, for example, account-service in spring.application.name=account-service is the applicationId;"}),"\n",(0,a.jsx)(n.li,{children:"ip refers to the RM client service address. 4. port refers to the RM client service address;"}),"\n",(0,a.jsx)(n.li,{children:"port refers to the RM client service address;"}),"\n",(0,a.jsx)(n.li,{children:"RpcContext saves the information of this registration request."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"TM_CHANNELS:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"ip+appname: the comment here should be written wrongly, it should be appname+ip, that is, the first key of the Map structure of TM_CHANNELS is appname+ip;"}),"\n",(0,a.jsx)(n.li,{children:"port: the port number of the client."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The following is the RM Client registration logic:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.core.rpc.ChannelManager#registerRMChannel"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static void registerRMChannel(RegisterRMRequest resourceManagerRequest, Channel channel)\nthrows IncompatibleVersionException {\nVersion.checkVersion(resourceManagerRequest.getVersion()); // Register the ResourceIds database.\n// Put the ResourceIds database connection connection information into a set\nSet<String> dbkeySet = dbKeytoSet(resourceManagerRequest.getResourceIds()); // put the ResourceIds database connection connection information into a set.\nRpcContext rpcContext;\n// Determine if the channel information is available from the cache\nif (!IDENTIFIED_CHANNELS.containsKey(channel)) {\n// Build the rpcContext based on the request registration information.\nrpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.RMROLE, resourceManagerRequest.getVersion(),\nresourceManagerRequest.getApplicationId(), resourceManagerRequest.getTransactionServiceGroup(),\nresourceManagerRequest.getTransactionServiceGroup(), resourceManagerRequest.getResourceIds(), channel);\n// Put the rpcContext into the cache\nrpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS); } else { rpcContext.\n} else {\nrpcContext = IDENTIFIED_CHANNELS.get(channel);\nrpcContext.addResources(dbkeySet);\n}\nif (null == dbkeySet || dbkeySet.isEmpty()) { return; }\nfor (String resourceId : dbkeySet) {\nString clientIp; // Store the request information into RM_Request.\n// Store the request information into RM_CHANNELS, using java8's computeIfAbsent method.\nConcurrentMap<Integer, RpcContext> portMap = RM_CHANNELS.computeIfAbsent(resourceId, resourceIdKey -> new ConcurrentHashMap<>())\n.computeIfAbsent(resourceManagerRequest.getApplicationId(), applicationId -> new ConcurrentHashMap<>())\n.computeIfAbsent(clientIp = getClientIpFromChannel(channel), clientIpKey -> new ConcurrentHashMap<>());\n// Put the current rpcContext into the portMap.\nrpcContext.holdInResourceManagerChannels(resourceId, portMap);\nupdateChannelsResource(resourceId, clientIp, resourceManagerRequest.getApplicationId()); }\n}\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"From the above code logic, we can see that the registration of RM client is mainly to put the registration request information into RM_CHANNELS cache, and at the same time, we will also judge from IDENTIFIED_CHANNELS whether the channel of this request has been verified or not, and the structure of IDENTIFIED_CHANNELS is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"private static final ConcurrentMap<Channel, RpcContext> IDENTIFIED_CHANNELS\n  = new ConcurrentHashMap<>();\n"})}),"\n",(0,a.jsx)(n.p,{children:"IDENTIFIED_CHANNELS contains all TM and RM registered channels."}),"\n",(0,a.jsx)(n.p,{children:"The following is the TM registration logic:"}),"\n",(0,a.jsx)(n.p,{children:"io.seata.core.rpc.ChannelManager#registerTMChannel"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static void registerTMChannel(RegisterTMRequest request, Channel channel)\nthrows IncompatibleVersionException {\nVersion.checkVersion(request.getVersion());\n// Build the RpcContext based on the request registration information.\nRpcContext rpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.TMROLE, request.getVersion(),\nrequest.getApplicationId(), request.getTransactionServiceHolder(NettyPoolKey.TransactionRole.\nrequest.getApplicationId(), request.getTransactionServiceGroup(),\nnull, channel);\n// Put the RpcContext into the IDENTIFIED_CHANNELS cache.\n\n\nrpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS); // put RpcContext into IDENTIFIED_CHANNELS cache; rpcContext.\n// account-service:127.0.0.1:63353\nString clientIdentified = rpcContext.getApplicationId() + Constants.CLIENT_ID_SPLIT_CHAR\n+ getClientIpFromChannel(channel);\n// Store the request information in the TM_CHANNELS cache.\nTM_CHANNELS.putIfAbsent(clientIdentified, new ConcurrentHashMap<Integer, RpcContext>()); // put the request information into the TM_CHANNELS cache.\n// Create the get from the previous step, and then put the rpcContext into the value of the map.\nConcurrentMap<Integer, RpcContext> clientIdentifiedMap = TM_CHANNELS.get(clientIdentified);\nrpcContext.holdInClientChannels(clientIdentifiedMap);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The registration of TM client is similar, the information registered is put into the corresponding cache, but the registration logic is simpler than that of RM client, mainly because RM client involves the information of branch transaction resources, and the information needed to be registered will be more than that of TM client."}),"\n",(0,a.jsx)(n.p,{children:"The above source code analysis is based on version 0.9.0."}),"\n",(0,a.jsx)(n.h1,{id:"about-the-author",children:"About the Author"}),"\n",(0,a.jsxs)(n.p,{children:['Zhang Chenghui, currently working in the Information Centre of China Communication Technology, Technology Platform Department, as a Java engineer, mainly responsible for the development of China Communication messaging platform and the whole link pressure test project, love to share technology, WeChat public number "back-end advanced" author, technology blog (',(0,a.jsx)(n.a,{href:"https://objcoding.com/",children:"https://objcoding.com/"}),") Blogger, Seata Contributor, GitHub ID: objcoding."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);
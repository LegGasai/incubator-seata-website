"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/explore-seata-journey","metadata":{"permalink":"/blog/explore-seata-journey","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/explore-seata-journey.md","source":"@site/blog/explore-seata-journey.md","title":"explore-seata-journey","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"how-to-support-spring-cloud","permalink":"/blog/how-to-support-spring-cloud"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/how-to-support-spring-cloud","metadata":{"permalink":"/blog/how-to-support-spring-cloud","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/how-to-support-spring-cloud.md","source":"@site/blog/how-to-support-spring-cloud.md","title":"how-to-support-spring-cloud","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"explore-seata-journey","permalink":"/blog/explore-seata-journey"},"nextItem":{"title":"integrate-seata-tcc-mode-with-spring-cloud","permalink":"/blog/integrate-seata-tcc-mode-with-spring-cloud"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/integrate-seata-tcc-mode-with-spring-cloud","metadata":{"permalink":"/blog/integrate-seata-tcc-mode-with-spring-cloud","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/integrate-seata-tcc-mode-with-spring-cloud.md","source":"@site/blog/integrate-seata-tcc-mode-with-spring-cloud.md","title":"integrate-seata-tcc-mode-with-spring-cloud","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"how-to-support-spring-cloud","permalink":"/blog/how-to-support-spring-cloud"},"nextItem":{"title":"integrate-seata-with-spring-cloud","permalink":"/blog/integrate-seata-with-spring-cloud"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/integrate-seata-with-spring-cloud","metadata":{"permalink":"/blog/integrate-seata-with-spring-cloud","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/integrate-seata-with-spring-cloud.md","source":"@site/blog/integrate-seata-with-spring-cloud.md","title":"integrate-seata-with-spring-cloud","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"integrate-seata-tcc-mode-with-spring-cloud","permalink":"/blog/integrate-seata-tcc-mode-with-spring-cloud"},"nextItem":{"title":"iscas2023","permalink":"/blog/iscas2023"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/iscas2023","metadata":{"permalink":"/blog/iscas2023","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/iscas2023.md","source":"@site/blog/iscas2023.md","title":"iscas2023","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"integrate-seata-with-spring-cloud","permalink":"/blog/integrate-seata-with-spring-cloud"},"nextItem":{"title":"seata-1.5.2","permalink":"/blog/seata-1.5.2"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-1.5.2","metadata":{"permalink":"/blog/seata-1.5.2","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-1.5.2.md","source":"@site/blog/seata-1.5.2.md","title":"seata-1.5.2","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"iscas2023","permalink":"/blog/iscas2023"},"nextItem":{"title":"seata-1.6.0","permalink":"/blog/seata-1.6.0"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-1.6.0","metadata":{"permalink":"/blog/seata-1.6.0","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-1.6.0.md","source":"@site/blog/seata-1.6.0.md","title":"seata-1.6.0","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-1.5.2","permalink":"/blog/seata-1.5.2"},"nextItem":{"title":"seata-analysis-UUID-generator","permalink":"/blog/seata-analysis-UUID-generator"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-UUID-generator","metadata":{"permalink":"/blog/seata-analysis-UUID-generator","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-UUID-generator.md","source":"@site/blog/seata-analysis-UUID-generator.md","title":"seata-analysis-UUID-generator","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-1.6.0","permalink":"/blog/seata-1.6.0"},"nextItem":{"title":"seata-analysis-config-modular","permalink":"/blog/seata-analysis-config-modular"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-config-modular","metadata":{"permalink":"/blog/seata-analysis-config-modular","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-config-modular.md","source":"@site/blog/seata-analysis-config-modular.md","title":"seata-analysis-config-modular","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-UUID-generator","permalink":"/blog/seata-analysis-UUID-generator"},"nextItem":{"title":"seata-analysis-core-modular","permalink":"/blog/seata-analysis-core-modular"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-core-modular","metadata":{"permalink":"/blog/seata-analysis-core-modular","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-core-modular.md","source":"@site/blog/seata-analysis-core-modular.md","title":"seata-analysis-core-modular","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-config-modular","permalink":"/blog/seata-analysis-config-modular"},"nextItem":{"title":"seata-analysis-dubbo-transmit-xid","permalink":"/blog/seata-analysis-dubbo-transmit-xid"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-dubbo-transmit-xid","metadata":{"permalink":"/blog/seata-analysis-dubbo-transmit-xid","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-dubbo-transmit-xid.md","source":"@site/blog/seata-analysis-dubbo-transmit-xid.md","title":"seata-analysis-dubbo-transmit-xid","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-core-modular","permalink":"/blog/seata-analysis-core-modular"},"nextItem":{"title":"seata-analysis-go-server","permalink":"/blog/seata-analysis-go-server"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-go-server","metadata":{"permalink":"/blog/seata-analysis-go-server","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-go-server.md","source":"@site/blog/seata-analysis-go-server.md","title":"seata-analysis-go-server","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-dubbo-transmit-xid","permalink":"/blog/seata-analysis-dubbo-transmit-xid"},"nextItem":{"title":"seata-analysis-java-client","permalink":"/blog/seata-analysis-java-client"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-java-client","metadata":{"permalink":"/blog/seata-analysis-java-client","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-java-client.md","source":"@site/blog/seata-analysis-java-client.md","title":"seata-analysis-java-client","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-go-server","permalink":"/blog/seata-analysis-go-server"},"nextItem":{"title":"seata-analysis-java-server","permalink":"/blog/seata-analysis-java-server"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-java-server","metadata":{"permalink":"/blog/seata-analysis-java-server","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-java-server.md","source":"@site/blog/seata-analysis-java-server.md","title":"seata-analysis-java-server","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-java-client","permalink":"/blog/seata-analysis-java-client"},"nextItem":{"title":"seata-analysis-simple","permalink":"/blog/seata-analysis-simple"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-simple","metadata":{"permalink":"/blog/seata-analysis-simple","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-simple.md","source":"@site/blog/seata-analysis-simple.md","title":"seata-analysis-simple","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-java-server","permalink":"/blog/seata-analysis-java-server"},"nextItem":{"title":"seata-analysis-tcc-modular","permalink":"/blog/seata-analysis-tcc-modular"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-analysis-tcc-modular","metadata":{"permalink":"/blog/seata-analysis-tcc-modular","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-analysis-tcc-modular.md","source":"@site/blog/seata-analysis-tcc-modular.md","title":"seata-analysis-tcc-modular","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-simple","permalink":"/blog/seata-analysis-simple"},"nextItem":{"title":"seata-at-demo-in-mac","permalink":"/blog/seata-at-demo-in-mac"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-demo-in-mac","metadata":{"permalink":"/blog/seata-at-demo-in-mac","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-demo-in-mac.md","source":"@site/blog/seata-at-demo-in-mac.md","title":"seata-at-demo-in-mac","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-analysis-tcc-modular","permalink":"/blog/seata-analysis-tcc-modular"},"nextItem":{"title":"seata-at-lock","permalink":"/blog/seata-at-lock"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-lock","metadata":{"permalink":"/blog/seata-at-lock","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-lock.md","source":"@site/blog/seata-at-lock.md","title":"seata-at-lock","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-demo-in-mac","permalink":"/blog/seata-at-demo-in-mac"},"nextItem":{"title":"seata-at-mode-design","permalink":"/blog/seata-at-mode-design"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-mode-design","metadata":{"permalink":"/blog/seata-at-mode-design","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-mode-design.md","source":"@site/blog/seata-at-mode-design.md","title":"seata-at-mode-design","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-lock","permalink":"/blog/seata-at-lock"},"nextItem":{"title":"seata-at-mode-start-rm-tm","permalink":"/blog/seata-at-mode-start-rm-tm"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-mode-start-rm-tm","metadata":{"permalink":"/blog/seata-at-mode-start-rm-tm","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-mode-start-rm-tm.md","source":"@site/blog/seata-at-mode-start-rm-tm.md","title":"seata-at-mode-start-rm-tm","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-mode-design","permalink":"/blog/seata-at-mode-design"},"nextItem":{"title":"seata-at-mode-start","permalink":"/blog/seata-at-mode-start"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-mode-start","metadata":{"permalink":"/blog/seata-at-mode-start","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-mode-start.md","source":"@site/blog/seata-at-mode-start.md","title":"seata-at-mode-start","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-mode-start-rm-tm","permalink":"/blog/seata-at-mode-start-rm-tm"},"nextItem":{"title":"seata-at-tcc-saga","permalink":"/blog/seata-at-tcc-saga"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-at-tcc-saga","metadata":{"permalink":"/blog/seata-at-tcc-saga","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-at-tcc-saga.md","source":"@site/blog/seata-at-tcc-saga.md","title":"seata-at-tcc-saga","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-mode-start","permalink":"/blog/seata-at-mode-start"},"nextItem":{"title":"seata-client-start-analysis-01","permalink":"/blog/seata-client-start-analysis-01"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-client-start-analysis-01","metadata":{"permalink":"/blog/seata-client-start-analysis-01","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-client-start-analysis-01.md","source":"@site/blog/seata-client-start-analysis-01.md","title":"seata-client-start-analysis-01","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-at-tcc-saga","permalink":"/blog/seata-at-tcc-saga"},"nextItem":{"title":"seata-client-start-analysis-02","permalink":"/blog/seata-client-start-analysis-02"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-client-start-analysis-02","metadata":{"permalink":"/blog/seata-client-start-analysis-02","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-client-start-analysis-02.md","source":"@site/blog/seata-client-start-analysis-02.md","title":"seata-client-start-analysis-02","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-client-start-analysis-01","permalink":"/blog/seata-client-start-analysis-01"},"nextItem":{"title":"seata-community-meetup-hangzhou-ready","permalink":"/blog/seata-community-meetup-hangzhou-ready"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-community-meetup-hangzhou-ready","metadata":{"permalink":"/blog/seata-community-meetup-hangzhou-ready","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-community-meetup-hangzhou-ready.md","source":"@site/blog/seata-community-meetup-hangzhou-ready.md","title":"seata-community-meetup-hangzhou-ready","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-client-start-analysis-02","permalink":"/blog/seata-client-start-analysis-02"},"nextItem":{"title":"seata-config-center","permalink":"/blog/seata-config-center"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-config-center","metadata":{"permalink":"/blog/seata-config-center","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-config-center.md","source":"@site/blog/seata-config-center.md","title":"seata-config-center","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-community-meetup-hangzhou-ready","permalink":"/blog/seata-community-meetup-hangzhou-ready"},"nextItem":{"title":"seata-config-manager","permalink":"/blog/seata-config-manager"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-config-manager","metadata":{"permalink":"/blog/seata-config-manager","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-config-manager.md","source":"@site/blog/seata-config-manager.md","title":"seata-config-manager","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-config-center","permalink":"/blog/seata-config-center"},"nextItem":{"title":"seata-datasource-proxy","permalink":"/blog/seata-datasource-proxy"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-datasource-proxy","metadata":{"permalink":"/blog/seata-datasource-proxy","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-datasource-proxy.md","source":"@site/blog/seata-datasource-proxy.md","title":"seata-datasource-proxy","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-config-manager","permalink":"/blog/seata-config-manager"},"nextItem":{"title":"seata-dsproxy-deadlock","permalink":"/blog/seata-dsproxy-deadlock"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-dsproxy-deadlock","metadata":{"permalink":"/blog/seata-dsproxy-deadlock","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-dsproxy-deadlock.md","source":"@site/blog/seata-dsproxy-deadlock.md","title":"seata-dsproxy-deadlock","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-datasource-proxy","permalink":"/blog/seata-datasource-proxy"},"nextItem":{"title":"seata-dynamic-config-and-dynamic-disable","permalink":"/blog/seata-dynamic-config-and-dynamic-disable"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-dynamic-config-and-dynamic-disable","metadata":{"permalink":"/blog/seata-dynamic-config-and-dynamic-disable","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-dynamic-config-and-dynamic-disable.md","source":"@site/blog/seata-dynamic-config-and-dynamic-disable.md","title":"seata-dynamic-config-and-dynamic-disable","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-dsproxy-deadlock","permalink":"/blog/seata-dsproxy-deadlock"},"nextItem":{"title":"seata-feature-undo-log-compress","permalink":"/blog/seata-feature-undo-log-compress"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-feature-undo-log-compress","metadata":{"permalink":"/blog/seata-feature-undo-log-compress","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-feature-undo-log-compress.md","source":"@site/blog/seata-feature-undo-log-compress.md","title":"seata-feature-undo-log-compress","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-dynamic-config-and-dynamic-disable","permalink":"/blog/seata-dynamic-config-and-dynamic-disable"},"nextItem":{"title":"seata-go-1.2.0","permalink":"/blog/seata-go-1.2.0"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-go-1.2.0","metadata":{"permalink":"/blog/seata-go-1.2.0","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-go-1.2.0.md","source":"@site/blog/seata-go-1.2.0.md","title":"seata-go-1.2.0","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-feature-undo-log-compress","permalink":"/blog/seata-feature-undo-log-compress"},"nextItem":{"title":"seata-golang-communication-mode","permalink":"/blog/seata-golang-communication-mode"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-golang-communication-mode","metadata":{"permalink":"/blog/seata-golang-communication-mode","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-golang-communication-mode.md","source":"@site/blog/seata-golang-communication-mode.md","title":"seata-golang-communication-mode","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-go-1.2.0","permalink":"/blog/seata-go-1.2.0"},"nextItem":{"title":"seata-ha-practice","permalink":"/blog/seata-ha-practice"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-ha-practice","metadata":{"permalink":"/blog/seata-ha-practice","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-ha-practice.md","source":"@site/blog/seata-ha-practice.md","title":"seata-ha-practice","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-golang-communication-mode","permalink":"/blog/seata-golang-communication-mode"},"nextItem":{"title":"seata-meetup-hangzhou","permalink":"/blog/seata-meetup-hangzhou"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-meetup-hangzhou","metadata":{"permalink":"/blog/seata-meetup-hangzhou","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-meetup-hangzhou.md","source":"@site/blog/seata-meetup-hangzhou.md","title":"seata-meetup-hangzhou","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-ha-practice","permalink":"/blog/seata-ha-practice"},"nextItem":{"title":"seata-mybatisplus-analysis","permalink":"/blog/seata-mybatisplus-analysis"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-mybatisplus-analysis","metadata":{"permalink":"/blog/seata-mybatisplus-analysis","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-mybatisplus-analysis.md","source":"@site/blog/seata-mybatisplus-analysis.md","title":"seata-mybatisplus-analysis","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-meetup-hangzhou","permalink":"/blog/seata-meetup-hangzhou"},"nextItem":{"title":"seata-nacos-analysis","permalink":"/blog/seata-nacos-analysis"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-nacos-analysis","metadata":{"permalink":"/blog/seata-nacos-analysis","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-nacos-analysis.md","source":"@site/blog/seata-nacos-analysis.md","title":"seata-nacos-analysis","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-mybatisplus-analysis","permalink":"/blog/seata-mybatisplus-analysis"},"nextItem":{"title":"seata-nacos-docker","permalink":"/blog/seata-nacos-docker"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-nacos-docker","metadata":{"permalink":"/blog/seata-nacos-docker","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-nacos-docker.md","source":"@site/blog/seata-nacos-docker.md","title":"seata-nacos-docker","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-nacos-analysis","permalink":"/blog/seata-nacos-analysis"},"nextItem":{"title":"seata-observable-practice","permalink":"/blog/seata-observable-practice"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-observable-practice","metadata":{"permalink":"/blog/seata-observable-practice","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-observable-practice.md","source":"@site/blog/seata-observable-practice.md","title":"seata-observable-practice","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-nacos-docker","permalink":"/blog/seata-nacos-docker"},"nextItem":{"title":"seata-quick-start","permalink":"/blog/seata-quick-start"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-quick-start","metadata":{"permalink":"/blog/seata-quick-start","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-quick-start.md","source":"@site/blog/seata-quick-start.md","title":"seata-quick-start","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-observable-practice","permalink":"/blog/seata-observable-practice"},"nextItem":{"title":"seata-raft-detailed-explanation","permalink":"/blog/seata-raft-detailed-explanation"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-raft-detailed-explanation","metadata":{"permalink":"/blog/seata-raft-detailed-explanation","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-raft-detailed-explanation.md","source":"@site/blog/seata-raft-detailed-explanation.md","title":"seata-raft-detailed-explanation","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-quick-start","permalink":"/blog/seata-quick-start"},"nextItem":{"title":"seata-rpc-refactor","permalink":"/blog/seata-rpc-refactor"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-rpc-refactor","metadata":{"permalink":"/blog/seata-rpc-refactor","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-rpc-refactor.md","source":"@site/blog/seata-rpc-refactor.md","title":"seata-rpc-refactor","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-raft-detailed-explanation","permalink":"/blog/seata-raft-detailed-explanation"},"nextItem":{"title":"seata-snowflake-explain","permalink":"/blog/seata-snowflake-explain"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-snowflake-explain","metadata":{"permalink":"/blog/seata-snowflake-explain","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-snowflake-explain.md","source":"@site/blog/seata-snowflake-explain.md","title":"seata-snowflake-explain","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-rpc-refactor","permalink":"/blog/seata-rpc-refactor"},"nextItem":{"title":"seata-sourcecode-client-bootstrap","permalink":"/blog/seata-sourcecode-client-bootstrap"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-sourcecode-client-bootstrap","metadata":{"permalink":"/blog/seata-sourcecode-client-bootstrap","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-sourcecode-client-bootstrap.md","source":"@site/blog/seata-sourcecode-client-bootstrap.md","title":"seata-sourcecode-client-bootstrap","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-snowflake-explain","permalink":"/blog/seata-snowflake-explain"},"nextItem":{"title":"seata-sourcecode-server-bootstrap","permalink":"/blog/seata-sourcecode-server-bootstrap"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-sourcecode-server-bootstrap","metadata":{"permalink":"/blog/seata-sourcecode-server-bootstrap","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-sourcecode-server-bootstrap.md","source":"@site/blog/seata-sourcecode-server-bootstrap.md","title":"seata-sourcecode-server-bootstrap","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-sourcecode-client-bootstrap","permalink":"/blog/seata-sourcecode-client-bootstrap"},"nextItem":{"title":"seata-spring-boot-aop-aspectj","permalink":"/blog/seata-spring-boot-aop-aspectj"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-spring-boot-aop-aspectj","metadata":{"permalink":"/blog/seata-spring-boot-aop-aspectj","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-spring-boot-aop-aspectj.md","source":"@site/blog/seata-spring-boot-aop-aspectj.md","title":"seata-spring-boot-aop-aspectj","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-sourcecode-server-bootstrap","permalink":"/blog/seata-sourcecode-server-bootstrap"},"nextItem":{"title":"seata-tcc-fence","permalink":"/blog/seata-tcc-fence"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-tcc-fence","metadata":{"permalink":"/blog/seata-tcc-fence","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-tcc-fence.md","source":"@site/blog/seata-tcc-fence.md","title":"seata-tcc-fence","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-spring-boot-aop-aspectj","permalink":"/blog/seata-spring-boot-aop-aspectj"},"nextItem":{"title":"seata-tcc","permalink":"/blog/seata-tcc"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-tcc","metadata":{"permalink":"/blog/seata-tcc","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-tcc.md","source":"@site/blog/seata-tcc.md","title":"seata-tcc","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-tcc-fence","permalink":"/blog/seata-tcc-fence"},"nextItem":{"title":"seata-xa-introduce","permalink":"/blog/seata-xa-introduce"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-xa-introduce","metadata":{"permalink":"/blog/seata-xa-introduce","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/seata-xa-introduce.md","source":"@site/blog/seata-xa-introduce.md","title":"seata-xa-introduce","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-tcc","permalink":"/blog/seata-tcc"},"nextItem":{"title":"springboot-dubbo-mybatisplus-seata","permalink":"/blog/springboot-dubbo-mybatisplus-seata"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/springboot-dubbo-mybatisplus-seata","metadata":{"permalink":"/blog/springboot-dubbo-mybatisplus-seata","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/springboot-dubbo-mybatisplus-seata.md","source":"@site/blog/springboot-dubbo-mybatisplus-seata.md","title":"springboot-dubbo-mybatisplus-seata","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"seata-xa-introduce","permalink":"/blog/seata-xa-introduce"},"nextItem":{"title":"tcc-mode-applicable-scenario-analysis","permalink":"/blog/tcc-mode-applicable-scenario-analysis"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/tcc-mode-applicable-scenario-analysis","metadata":{"permalink":"/blog/tcc-mode-applicable-scenario-analysis","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/tcc-mode-applicable-scenario-analysis.md","source":"@site/blog/tcc-mode-applicable-scenario-analysis.md","title":"tcc-mode-applicable-scenario-analysis","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"springboot-dubbo-mybatisplus-seata","permalink":"/blog/springboot-dubbo-mybatisplus-seata"},"nextItem":{"title":"tcc-mode-design-principle","permalink":"/blog/tcc-mode-design-principle"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/tcc-mode-design-principle","metadata":{"permalink":"/blog/tcc-mode-design-principle","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/blog/tcc-mode-design-principle.md","source":"@site/blog/tcc-mode-design-principle.md","title":"tcc-mode-design-principle","description":"Placeholder. DO NOT DELETE.","date":"2024-01-21T09:58:14.000Z","formattedDate":"January 21, 2024","tags":[],"readingTime":0.02,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"tcc-mode-applicable-scenario-analysis","permalink":"/blog/tcc-mode-applicable-scenario-analysis"},"nextItem":{"title":"Seata:Bridging Data and Applications","permalink":"/blog/seata-connect-data-and-application"}},"content":"Placeholder. DO NOT DELETE."},{"id":"/seata-connect-data-and-application","metadata":{"permalink":"/blog/seata-connect-data-and-application","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-connect-data-and-application.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/seata-connect-data-and-application.md","title":"Seata:Bridging Data and Applications","description":"This article introduces the past, present, and future evolution of Seata.","date":"2023-06-30T00:00:00.000Z","formattedDate":"June 30, 2023","tags":[],"readingTime":13.905,"hasTruncateMarker":false,"authors":[{"name":"Ji Min - Founder of the Seata Open Source Community, Leader of the Distributed Transactions Team"}],"frontMatter":{"title":"Seata:Bridging Data and Applications","keywords":["Seata","Distributed Transactions","Data Consistency","Microservices"],"description":"This article introduces the past, present, and future evolution of Seata.","author":"Ji Min - Founder of the Seata Open Source Community, Leader of the Distributed Transactions Team","date":"June 30, 2023"},"prevItem":{"title":"tcc-mode-design-principle","permalink":"/blog/tcc-mode-design-principle"},"nextItem":{"title":"Designing More Flexible Financial Applications with Seata Saga","permalink":"/blog/design-more-flexable-application-by-saga"}},"content":"This article mainly introduces the evolutionary journey of distributed transactions from internal development to commercialization and open source, as well as the current progress and future planning of the Seata community.\\nSeata is an open-source distributed transaction solution designed to provide a comprehensive solution for distributed transactions under modern microservices architecture. Seata offers complete distributed transaction solutions, including AT, TCC, Saga, and XA transaction modes, supporting various programming languages and data storage schemes. Seata also provides easy-to-use APIs, extensive documentation, and examples to facilitate quick development and deployment for enterprises applying Seata.\\n**Seata\'s advantages lie in its high availability, high performance, and high scalability, and it does not require extra complex operations for horizontal scaling.** Seata is currently used in thousands of customer business systems on Alibaba Cloud, and its reliability has been recognized and applied by major industry manufacturers.\\nAs an open-source project, the Seata community is also expanding continuously, becoming an important platform for developers to exchange, share, and learn, attracting more and more attention and support from enterprises.\\nToday, I will primarily share about Seata on the following three topics:\\n- **From TXC/GTS to Seata**\\n- **Latest developments in the Seata community**\\n- **Future planning for the Seata community**\\n  <br/>\\n### From TXC/GTS to Seata\\n#### The Origin of Distributed Transactions\\n![Product Matrix](/img/blog/\u4ea7\u54c1\u77e9\u9635.jpg)\\nSeata is internally codenamed TXC (taobao transaction constructor) within Alibaba, a name with a strong organizational structure flavor. TXC originated from Alibaba\'s Wushi (Five Color Stones) project, which in ancient mythology were the stones used by the goddess N\xfcwa to mend the heavens, symbolizing Alibaba\'s important milestone in the evolution from monolithic architecture to distributed architecture. During this project, a batch of epoch-making Internet middleware was developed, including the well-known \\"Big Three\\":\\n- **HSF service invocation framework**\\n  Solves service communication issues after the transition from monolithic applications to service-oriented architectures.\\n- **TDDL database sharding framework**\\n  Addresses storage capacity and connection count issues of databases at scale.\\n- **MetaQ messaging framework**\\n  Addresses asynchronous invocation issues.\\n  The birth of the Big Three satisfied the basic requirements of microservices-based business development, but the data consistency issues that arose after microservices were not properly addressed, lacking a unified solution. The likelihood of data consistency issues in microservices is much higher than in monolithic applications, and the increased complexity of moving from in-process calls to network calls exacerbates the production of exceptional scenarios. The increase in service hops also makes it impossible for upstream and downstream services to coordinate data rollback in the event of a business processing exception. TXC was born to address the pain points of data consistency at the application architecture layer, and the core data consistency scenarios it aimed to address included:\\n- **Consistency across services.** Coordinates rollback of upstream and downstream service nodes in the event of system exceptions such as call timeouts and business exceptions.\\n- **Data consistency in database sharding.** Ensures internal transactions during logical SQL operations on business layers are consistent across different data shards.\\n- **Data consistency in message sending.** Addresses the inconsistency between data operations and successful message sending.\\n  To overcome the common scenarios encountered, TXC was seamlessly integrated with the Big Three. When businesses use the Big Three for development, they are completely unaware of TXC\'s presence in the background, do not have to consider the design of data consistency, and leave it to the framework to ensure, allowing businesses to focus more on their own development, greatly improving development efficiency.\\n  <br/>\\n  ![GTS Architecture](/img/blog/GTS\u67b6\u6784.jpg)\\n  TXC has been widely used within Alibaba Group for many years and has been baptized by the surging traffic of large-scale events like Singles\' Day, significantly improving business development efficiency and ensuring data accuracy, eliminating financial and reputational issues caused by data inconsistencies. With the continuous evolution of the architecture, **a standard three-node cluster can now handle peak values of nearly 100K TPS and millisecond-level transaction processing. In terms of availability and performance, it has reached a four-nines SLA guarantee, ensuring no failures throughout the year even in unattended conditions.**\\n  <br/>\\n#### The Evolution of Distributed Transactions\\nThe birth of new things is always accompanied by doubts. Is middleware capable of ensuring data consistency reliable? The initial birth of TXC was just a vague theory, lacking theoretical models and engineering practice. After we conducted MVP (Minimum Viable Product) model testing and promoted business deployment, we often encountered faults and frequently had to wake up in the middle of the night to deal with issues, wearing wristbands to sleep to cope with emergency responses. These were the most painful years I went through technically after taking over the team.\\n![Evolution of Distributed Transactions](/img/blog/\u5206\u5e03\u5f0f\u4e8b\u52a1\u6f14\u8fdb.jpg)\\nSubsequently, we had extensive discussions and systematic reviews. We first needed to define the consistency problem. Were we to achieve majority consensus consistency like RAFT, solve database consistency issues like Google Spanner, or something else? Looking at the top-down layered structure from the application node, it mainly includes development frameworks, service invocation frameworks, data middleware, database drivers, and databases. We had to decide at which layer to solve the data consistency problem. We compared the consistency requirements, universality, implementation complexity, and business integration costs faced when solving data consistency issues at different levels. In the end, we weighed the pros and cons, decided to keep the implementation complexity to ourselves, and adopted the AT mode initially as a consistency component. We needed to ensure high consistency, but not be locked into specific database implementations, ensuring the generality of scenarios and the business integration costs were low enough to be easily implemented. This is also why TXC initially adopted the AT mode.\\n**A distributed transaction is not just a framework; it\'s a system.** We defined the consistency problem in theory, abstractly conceptualized modes, roles, actions, and isolation, etc. From an engineering practice perspective, we defined the programming model, including low-intrusion annotations, simple method templates, and flexible APIs, and defined basic and enhanced transaction capabilities (e.g., how to support a large number of activities at low cost), as well as capabilities in operations, security, performance, observability, and high availability.\\n![Transaction Logical Model](/img/blog/\u4e8b\u52a1\u903b\u8f91\u6a21\u578b.jpg)\\nWhat problems do distributed transactions solve? A classic and tangible example is the money transfer scenario. The transfer process includes subtracting balance and adding balance, how do we ensure the atomicity of the operation? Without any intervention, these two steps may encounter various problems, such as account B being canceled or service call timeouts, etc.\\n**Timeout issues have always been a difficult problem to solve in distributed applications**; we cannot accurately know whether service B has executed and in what order. From a data perspective, this means the money in account B may not be successfully added. After the service-oriented transformation, each node only has partial information, while the transaction itself requires global coordination of all nodes, thus requiring a centralized role with a god\'s-eye view, capable of obtaining all information, which is the **TC (transaction coordinator)**, used to globally coordinate the transaction state. The **TM (Transaction Manager)** is the role that drives the generation of transaction proposals. However, even gods nod off, and their judgments are not always correct, so we need an **RM (resource manager)** role to verify the authenticity of the transaction as a representative of the soul. This is TXC\'s most basic philosophical model. We have methodologically verified that its data consistency is very complete, of course, our cognition is bounded. Perhaps the future will prove we were turkey engineers, but under current circumstances, its model is already sufficient to solve most existing problems.\\n![Distributed Transaction Performance](/img/blog/\u5206\u5e03\u5f0f\u4e8b\u52a1\u6027\u80fd.jpg)\\n**After years of architectural evolution, from the perspective of transaction single-link latency, TXC takes an average of about 0.2 milliseconds to process at the start of the transaction and about 0.4 milliseconds for branch registration, with the entire transaction\'s additional latency within the millisecond range. This is also the theoretical limit value we have calculated. In terms of throughput, the TPS of a single node reaches 30,000 times/second, and the TPS of a standard cluster is close to 100,000 times/second.**\\n<br/>\\n#### Seata Open Source\\nWhy go open source? This is a question many people have asked me. In 2017, we commercialized the GTS (Global Transaction Service) product sold on Alibaba Cloud, with both public and private cloud forms. At this time, the internal group developed smoothly, but we encountered various problems in the process of commercialization. The problems can be summed up in two main categories: **First, developers are quite lacking in the theory of distributed transactions,** most people do not even understand what local transactions are, let alone distributed transactions. **Second, there are problems with product maturity,** often encountering various strange scenario issues, leading to a sharp rise in support and delivery costs, and R&D turning into after-sales customer service.\\nWe reflected on why we encountered so many problems. The main issue here is that Alibaba Group internally has a unified language stack and unified technology stack, and our polishing of specific scenarios is very mature. Serving Alibaba, one company, and serving thousands of enterprises on the cloud is fundamentally different, which also made us realize that our product\'s scenario ecology was not well developed. On GitHub, more than 80% of open-source software is basic software, and basic software primarily solves the problem of scenario universality, so it cannot be locked in by a single enterprise, like Linux, which has a large number of community distributions. Therefore, in order to make our product better, we chose to open source and co-build with developers to popularize more enterprise users.\\n![Alibaba Open Source](/img/blog/\u963f\u91cc\u5f00\u6e90.jpg)\\nAlibaba\'s open-source journey has gone through three main stages. **The first stage is the stage where Dubbo is located, where developers contribute out of love,** Dubbo has been open sourced for over 10 years, and time has fully proven that Dubbo is an excellent open-source software, and its microkernel plugin extensibility design is an important reference for me when I initially open sourced Seata. When designing software, we need to consider which is more important between extensibility and performance, whether we are doing a three-year design, a five-year design, or a ten-year design that meets business development. While solving the 0-1 service call problem, can we predict the governance problems after the 1-100 scale-up?\\n**The second stage is the closed loop of open source and commercialization, where commercialization feeds back into the open-source community, promoting the development of the open-source community.** I think cloud manufacturers are more likely to do open source well for the following reasons:\\n- First, the cloud is a scaled economy, which must be established on a stable and mature kernel foundation, packaging its product capabilities including high availability, maintenance-free, and elasticity on top of it. An unstable kernel will inevitably lead to excessive delivery and support costs, and high penetration of the R&D team\'s support Q&A will prevent large-scale replication, and high penetration rates will prevent rapid evolution and iteration of products.\\n- Second, commercial products know business needs better. Our internal technical teams often YY requirements from a development perspective, and what they make is not used by anyone, and thus does not form a value conversion. The business requirements collected through commercialization are all real, so its open source kernel must also evolve in this direction. Failure to evolve in this direction will inevitably lead to architectural splits on both sides, increasing the team\'s maintenance costs.\\n- Finally, the closed loop of open source and commercialization can promote better development of both parties. If the open-source kernel often has various problems, would you believe that its commercial product is good enough?\\n  **The third stage is systematization and standardization.** First, systematization is the basis of open-source solutions. Alibaba\'s open-source projects are mostly born out of internal e-commerce scenario practices. For example, Higress is used to connect Ant Group\'s gateways; Nacos carries services with millions of instances and tens of millions of connections; Sentinel provides degradation and throttling capabilities for high availability during major promotions; and Seata ensures transaction data consistency. This set of systematized open-source solutions is designed based on the best practices of Alibaba\'s e-commerce ecosystem. Second, standardization is another important feature. Taking OpenSergo as an example, it is both a standard and an implementation. In the past few years, the number of domestic open-source projects has exploded. However, the capabilities of various open-source products vary greatly, and many compatibility issues arise when integrating with each other. Therefore, open-source projects like OpenSergo can define some standardized capabilities and interfaces and provide some implementations, which will greatly help the development of the entire open-source ecosystem.\\n  <br/>\\n### Latest Developments in the Seata Community\\n#### Introduction to the Seata Community\\n![Community Introduction](/img/blog/\u793e\u533a\u7b80\u4ecb.jpg)\\n**At present, Seata has open-sourced 4 transaction modes, including AT, TCC, Saga, and XA, and is actively exploring other viable transaction solutions.** Seata has integrated with more than 10 mainstream RPC frameworks and relational databases, and has integrated or been integrated relationships with more than 20 communities. In addition, we are also exploring languages other than Java in the multi-language system, such as Golang, PHP, Python, and JS.\\nSeata has been applied to business systems by thousands of customers. Seata applications have become more mature, with successful cooperation with the community in the financial business scenarios of CITIC Bank and Everbright Bank, and successfully adopted into core accounting systems. The landing of microservices systems in financial scenarios is very stringent, which also marks a new level of maturity for Seata\'s kernel.\\n<br/>\\n#### Seata Ecosystem Expansion\\n![Ecosystem Expansion](/img/blog/\u6269\u5c55\u751f\u6001.jpg)\\n**Seata adopts a microkernel and plugin architecture design, exposing rich extension points in APIs, registry configuration centers, storage modes, lock control, SQL parsers, load balancing, transport, protocol encoding and decoding, observability, and more.** This allows businesses to easily perform flexible extensions and select technical components.\\n<br/>\\n#### Seata Application Cases\\n![Application Cases](/img/blog/\u5e94\u7528\u6848\u4f8b.jpg)\\n**Case 1: China Aviation Information\'s Air Travel Project**\\nThe China Aviation Information Air Travel project introduced Seata in the 0.2 version to solve the data consistency problem of ticket and coupon business, greatly improving development efficiency, reducing asset losses caused by data inconsistency, and enhancing user interaction experience.\\n**Case 2: Didi Chuxing\'s Two-Wheeler Business Unit**\\nDidi Chuxing\'s Two-Wheeler Business Unit introduced Seata in version 0.6.1, solving the data consistency problem of business processes such as blue bicycles, electric vehicles, and assets, optimizing the user experience, and reducing asset loss.\\n**Case 3: Meituan\'s Infrastructure**\\nMeituan\'s infrastructure team developed the internal distributed transaction solution Swan based on the open-source Seata project, which is used to solve distributed transaction problems within Meituan\'s various businesses.\\n**Case 4: Hema Town**\\nHema Town uses Seata to control the flower-stealing process in game interactions, significantly shortening the development cycle from 20 days to 5 days, effectively reducing development costs.\\n<br/>\\n#### Evolution of Seata Transaction Modes\\n![Mode Evolution](/img/blog/\u6a21\u5f0f\u6f14\u8fdb.jpg)\\n<br/>\\n#### Current Progress of Seata\\n- Support for Oracle and PostgreSQL multi-primary keys.\\n- Support for Dubbo3.\\n- Support for Spring Boot3.\\n- Support for JDK 17.\\n- Support for ARM64 images.\\n- Support for multiple registration models.\\n- Extended support for various SQL syntaxes.\\n- Support for GraalVM Native Image.\\n- Support for Redis lua storage mode.\\n  <br/>\\n### Seata 2.x Development Planning\\n![Development Planning](/img/blog/\u53d1\u5c55\u89c4\u5212.jpg)\\nMainly includes the following aspects:\\n- **Storage/Protocol/Features**\\n  Explore storage and computing separation in Raft cluster mode; better experience, unify the current 4 transaction mode APIs; compatible with GTS protocol; support Saga annotations; support distributed lock control; support data perspective insight and governance.\\n- **Ecosystem**\\n  Support more databases, more service frameworks, while exploring support for the domestic trust creation ecosystem; support the MQ ecosystem; further enhance APM support.\\n- **Solutions**\\n  In addition to supporting microservices ecosystems, explore multi-cloud solutions; closer to cloud-native solutions; add security and traffic protection capabilities; achieve self-convergence of core components in the architecture.\\n- **Multi-Language Ecosystem**\\n  Java is the most mature in the multi-language ecosystem, continue to improve other supported programming languages, while exploring Transaction Mesh solutions that are independent of languages.\\n- **R&D Efficiency/Experience**\\n  Improve test coverage, prioritize quality, compatibility, and stability; restructure the official website\'s documentation to improve the hit rate of document searches; simplify operations and deployment on the experience side, achieve one-click installation and metadata simplification; console supports transaction control and online analysis capabilities.\\n\\nIn one sentence, the 2.x plan is summarized as: **Bigger scenarios, bigger ecosystems, from usable to user-friendly.**\\n<br/>\\n### Contact Information for the Seata Community\\n![Contact Information](/img/blog/\u8054\u7cfb\u65b9\u5f0f.jpg)"},{"id":"/design-more-flexable-application-by-saga","metadata":{"permalink":"/blog/design-more-flexable-application-by-saga","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/design-more-flexable-application-by-saga.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/design-more-flexable-application-by-saga.md","title":"Designing More Flexible Financial Applications with Seata Saga","description":"This article delves into the pain points of developing distributed financial applications, analyzing solutions from both theoretical and practical perspectives. It explains how to design more flexible financial applications using Seata Saga.","date":"2019-11-04T00:00:00.000Z","formattedDate":"November 4, 2019","tags":[],"readingTime":19.94,"hasTruncateMarker":false,"authors":[{"name":"long187"}],"frontMatter":{"title":"Designing More Flexible Financial Applications with Seata Saga","keywords":["Saga","Seata","Consistency","Financial","Flexibility","Distributed","Transaction"],"description":"This article delves into the pain points of developing distributed financial applications, analyzing solutions from both theoretical and practical perspectives. It explains how to design more flexible financial applications using Seata Saga.","author":"long187","date":"2019-11-04T00:00:00.000Z"},"prevItem":{"title":"Seata:Bridging Data and Applications","permalink":"/blog/seata-connect-data-and-application"},"nextItem":{"title":"How to use Seata to ensure consistency between Dubbo Microservices","permalink":"/blog/quick-start-use-seata-and-dubbo-services"}},"content":"Seata, short for Simple Extensible Autonomous Transaction Architecture, is an all-in-one distributed transaction solution. It provides AT, TCC, Saga, and XA transaction modes. This article provides a detailed explanation of the Saga mode within Seata, with the project hosted on [GitHub](https://github.com/apache/incubator-seata).\\n\\nAuthor: Yiyuan (Chen Long), Core Developer of Distributed Transactions at Ant Financial, Seata Committer.\\n\\n\\n<a name=\\"uTwja\\"></a>\\n\\n# Pain Points in Financial Distributed Application Development\\n\\nDistributed systems face a prominent challenge where a business process requires a composition of various services. This challenge becomes even more pronounced in a microservices architecture, as it necessitates consistency guarantees at the business level. In other words, if a step fails, it either needs to roll back to the previous service invocation or continuously retry to ensure the success of all steps. - From \\"Left Ear Wind - Resilient Design: Compensation Transaction\\"\\n\\nIn the domain of financial microservices architecture, business processes are often more complex. Processes are lengthy, such as a typical internet microloan business process involving calls to more than ten services. When combined with exception handling processes, the complexity increases further. Developers with experience in financial business development can relate to these challenges.\\n\\nDuring the development of financial distributed applications, we encounter several pain points:\\n\\n- **Difficulty Ensuring Business Consistency**<br />\\n\\n    In many of the systems we encounter (e.g., in channel layers, product layers, and integration layers), ensuring eventual business consistency often involves adopting a \\"compensation\\" approach. Without a coordinator to support this, the development difficulty is significant. Each step requires handling \\"rollback\\" operations in catch blocks, resulting in a code structure resembling an \\"arrow,\\" with poor readability and maintainability. Alternatively, retrying exceptional operations, if unsuccessful, might lead to asynchronous retries or even manual intervention. These challenges impose a significant burden on developers, reducing development efficiency and increasing the likelihood of errors.\\n\\n- **Difficulty Managing Business State**<br />\\n\\n    With numerous business entities and their corresponding states, developers often update the entity\'s state in the database after completing a business activity. Lack of a state machine to manage the entire state transition process results in a lack of intuitiveness, increases the likelihood of errors, and causes the business to enter an incorrect state.\\n\\n- **Difficulty Ensuring Idempotence**<br />\\n\\n    Idempotence of services is a fundamental requirement in a distributed environment. Ensuring the idempotence of services often requires developers to design each service individually, using unique keys in databases or distributed caches. There is no unified solution, creating a significant burden on developers and increasing the chances of oversight, leading to financial losses.\\n\\n- **Challenges in Business Monitoring and Operations; Lack of Unified Error Guardian Capability**<br />\\n\\n    Monitoring the execution of business operations is usually done by logging, and monitoring platforms are based on log analysis. While this is generally sufficient, in the case of business errors, these monitors lack immediate access to the business context and require additional database queries. Additionally, the reliance on developers for log printing makes it prone to omissions. For compensatory transactions, there is often a need for \\"error guardian triggering compensation\\" and \\"worker-triggered compensation\\" operations. The lack of a unified error guardian and processing standard requires developers to implement these individually, resulting in a heavy development burden.\\n\\n\\n<a name=\\"hvEU6\\"></a>\\n\\n# Theoretical Foundation\\n\\nIn certain scenarios where strong consistency is required for data, we may adopt distributed transaction schemes like \\"Two-Phase Commit\\" at the business layer. However, in other scenarios, where such strong consistency is not necessary, ensuring eventual consistency is sufficient.\\n\\nFor example, Ant Financial currently employs the TCC (Try, Confirm, Cancel) pattern in its financial core systems. The characteristics of financial core systems include high consistency requirements (business isolation), short processes, and high concurrency.\\n\\nOn the other hand, in many business systems above the financial core (e.g., systems in the channel layer, product layer, and integration layer), the emphasis is on achieving eventual consistency. These systems typically have complex processes, long flows, and may need to call services from other companies (such as financial networks). Developing Try, Confirm, Cancel methods for each service in these scenarios incurs high costs. Additionally, when there are services from other companies in the transaction, it is impractical to require those services to follow the TCC development model. Long processes can negatively impact performance if transaction boundaries are too extensive.\\n\\nWhen it comes to transactions, we are familiar with ACID, and we are also acquainted with the CAP theorem, which states that at most two out of three\u2014Consistency (C), Availability (A), and Partition Tolerance (P)\u2014can be achieved simultaneously. To enhance performance, a variant of ACID known as BASE emerged. While ACID emphasizes consistency (C in CAP), BASE emphasizes availability (A in CAP). Achieving strong consistency (ACID) is often challenging, especially when dealing with multiple systems that are not provided by a single company. BASE systems are designed to create more resilient systems. In many situations, particularly when dealing with multiple systems and providers, BASE systems acknowledge the risk of data inconsistency in the short term. This allows new transactions to occur, with potentially problematic transactions addressed later through compensatory means to ensure eventual consistency.\\n\\nTherefore, in practical development, we make trade-offs. For many business systems above the financial core, compensatory transactions can be adopted. The concept of compensatory transactions has been proposed for about 30 years, with the Saga theory emerging as a solution for long transactions. With the recent rise of microservices, Saga has gradually gained attention in recent years. Currently, the industry generally recognizes Saga as a solution for handling long transactions.\\n\\n> [https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf](https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf)[1]\\n> [http://microservices.io/patterns/data/saga.html](http://microservices.io/patterns/data/saga.html)[2]\\n\\n\\n<a name=\\"k8kbY\\"></a>\\n\\n# Community and Industry Solutions\\n\\n<a name=\\"Oc5Er\\"></a>\\n## Apache Camel Saga\\n\\nCamel is an open-source product that implements Enterprise Integration Patterns (EIP). It is based on an event-driven architecture and offers good performance and throughput. In version 2.21, Camel introduced the Saga EIP.\\n\\nThe Saga EIP provides a way to define a series of related actions through Camel routes. These actions either all succeed or all roll back. Saga can coordinate distributed services or local services using any communication protocol, achieving global eventual consistency. Saga does not require the entire process to be completed in a short time because it does not occupy any database locks. It can support requests that require long processing times, ranging from seconds to days. Camel\'s Saga EIP is based on [MicroProfile\'s LRA](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA)[3] (Long Running Action). It also supports the coordination of distributed services implemented in any language using any communication protocol.\\n\\nThe implementation of Saga does not lock data. Instead, it defines \\"compensating operations\\" for each operation. When an error occurs during the normal process execution, the \\"compensating operations\\" for the operations that have already been executed are triggered to roll back the process. \\"Compensating operations\\" can be defined on Camel routes using Java or XML DSL (Definition Specific Language).\\n\\nHere is an example of Java DSL:\\n\\n```java\\n// Java DSL example goes here\\n\\n```java\\n// action\\nfrom(\\"direct:reserveCredit\\")\\n  .bean(idService, \\"generateCustomId\\") // generate a custom Id and set it in the body\\n  .to(\\"direct:creditReservation\\")\\n\\n// delegate action\\nfrom(\\"direct:creditReservation\\")\\n  .saga()\\n  .propagation(SagaPropagation.SUPPORTS)\\n  .option(\\"CreditId\\", body()) // mark the current body as needed in the compensating action\\n  .compensation(\\"direct:creditRefund\\")\\n    .bean(creditService, \\"reserveCredit\\")\\n    .log(\\"Credit ${header.amount} reserved. Custom Id used is ${body}\\");\\n\\n// called only if the saga is cancelled\\nfrom(\\"direct:creditRefund\\")\\n  .transform(header(\\"CreditId\\")) // retrieve the CreditId option from headers\\n  .bean(creditService, \\"refundCredit\\")\\n  .log(\\"Credit for Custom Id ${body} refunded\\");\\n```\\n\\nXML DSL sample:\\n```xml\\n<route>\\n  <from uri=\\"direct:start\\"/>\\n  <saga>\\n    <compensation uri=\\"direct:compensation\\" />\\n    <completion uri=\\"direct:completion\\" />\\n    <option optionName=\\"myOptionKey\\">\\n      <constant>myOptionValue</constant>\\n    </option>\\n    <option optionName=\\"myOptionKey2\\">\\n      <constant>myOptionValue2</constant>\\n    </option>\\n  </saga>\\n  <to uri=\\"direct:action1\\" />\\n  <to uri=\\"direct:action2\\" />\\n</route>\\n```\\n\\n<a name=\\"pQWuF\\"></a>\\n\\n## Eventuate Tram Saga\\n\\n[Eventuate Tram Saga](https://github.com/eventuate-tram/eventuate-tram-sagas)[4]\xa0The framework is a Saga framework for Java microservices using JDBC/JPA. Similar to Camel Saga, it also adopts Java DSL to define compensating operations:\\n\\n\\n```java\\npublic class CreateOrderSaga implements SimpleSaga<CreateOrderSagaData> {\\n\\n  private SagaDefinition<CreateOrderSagaData> sagaDefinition =\\n          step()\\n            .withCompensation(this::reject)\\n          .step()\\n            .invokeParticipant(this::reserveCredit)\\n          .step()\\n            .invokeParticipant(this::approve)\\n          .build();\\n\\n\\n  @Override\\n  public SagaDefinition<CreateOrderSagaData> getSagaDefinition() {\\n    return this.sagaDefinition;\\n  }\\n\\n\\n  private CommandWithDestination reserveCredit(CreateOrderSagaData data) {\\n    long orderId = data.getOrderId();\\n    Long customerId = data.getOrderDetails().getCustomerId();\\n    Money orderTotal = data.getOrderDetails().getOrderTotal();\\n    return send(new ReserveCreditCommand(customerId, orderId, orderTotal))\\n            .to(\\"customerService\\")\\n            .build();\\n\\n...\\n```\\n\\n<a name=\\"scN9h\\"></a>\\n\\n## Apache ServiceComb Saga\\n\\n[ServiceComb Saga](https://github.com/apache/incubator-servicecomb-saga)[5] is also a solution for achieving data eventual consistency in microservices applications. In contrast to [TCC](http://design.inf.usi.ch/sites/default/files/biblio/rest-tcc.pdf), Saga directly commits transactions in the try phase, and the subsequent rollback phase is completed through compensating operations in reverse. What sets it apart is the use of Java annotations and interceptors to define \\"compensating\\" services.<br />\\n\\n#### Architecture:\\n\\nSaga consists of **alpha** and **omega**, where:\\n\\n- Alpha acts as the coordinator, primarily responsible for managing and coordinating transactions;<br />\\n- Omega is an embedded agent in microservices, responsible for intercepting network requests and reporting transaction events to alpha;<br />\\n\\nThe diagram below illustrates the relationship between alpha, omega, and microservices:<br />\\n\\n![ServiceComb Saga](/img/saga/service-comb-saga.png?raw=true)\\n\\n<a name=\\"ggflbq\\"></a>\\n\\n#### sample\uff1a\\n```java\\npublic class ServiceA extends AbsService implements IServiceA {\\n\\n  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\\n\\n  @Autowired\\n  private IServiceB serviceB;\\n\\n  @Autowired\\n  private IServiceC serviceC;\\n\\n  @Override\\n  public String getServiceName() {\\n    return \\"servicea\\";\\n  }\\n\\n  @Override\\n  public String getTableName() {\\n    return \\"testa\\";\\n  }\\n\\n  @Override\\n  @SagaStart\\n  @Compensable(compensationMethod = \\"cancelRun\\")\\n  @Transactional(rollbackFor = Exception.class)\\n  public Object run(InvokeContext invokeContext) throws Exception {\\n    LOG.info(\\"A.run called\\");\\n    doRunBusi();\\n    if (invokeContext.isInvokeB(getServiceName())) {\\n      serviceB.run(invokeContext);\\n    }\\n    if (invokeContext.isInvokeC(getServiceName())) {\\n      serviceC.run(invokeContext);\\n    }\\n    if (invokeContext.isException(getServiceName())) {\\n      LOG.info(\\"A.run exception\\");\\n      throw new Exception(\\"A.run exception\\");\\n    }\\n    return null;\\n  }\\n\\n  public void cancelRun(InvokeContext invokeContext) {\\n    LOG.info(\\"A.cancel called\\");\\n    doCancelBusi();\\n  }\\n```\\n\\n<a name=\\"CnD8r\\"></a>\\n\\n## Ant Financial\'s Practice\\n\\nAnt Financial extensively uses the TCC mode for distributed transactions, mainly in scenarios where high consistency and performance are required, such as in financial core systems. In upper-level business systems with complex and lengthy processes, developing TCC can be costly. In such cases, most businesses opt for the Saga mode to achieve eventual business consistency. Due to historical reasons, different business units have their own set of \\"compensating\\" transaction solutions, basically falling into two categories:\\n\\n1. When a service needs to \\"retry\\" or \\"compensate\\" in case of failure, a record is inserted into the database with the status before executing the service. When an exception occurs, a scheduled task queries the database record and performs \\"retry\\" or \\"compensation.\\" If the business process is successful, the record is deleted.\\n\\n2. Designing a state machine engine and a simple DSL to orchestrate business processes and record business states. The state machine engine can define \\"compensating services.\\" In case of an exception, the state machine engine invokes \\"compensating services\\" in reverse. There is also an \\"error guardian\\" platform that monitors failed or uncompensated business transactions and continuously performs \\"compensation\\" or \\"retry.\\"\\n\\n## Solution Comparison\\n\\nGenerally, there are two common solutions in the community and industry: one is based on a state machine or a process engine that orchestrates processes and defines compensation through DSL; the other is based on Java annotations and interceptors to implement compensation. What are the advantages and disadvantages of these two approaches?\\n\\n| Approach             | Pros                                                                                                                                                                                                                                                                                                  | Cons                                                                                                                                                                            |\\n| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| State Machine + DSL  | <br />- Business processes can be defined using visual tools, standardized, readable, and can achieve service orchestration functionality<br />- Improves communication efficiency between business analysts and developers<br />- Business state management: Processes are essentially state machines, reflecting the flow of business states<br />- Enhances flexibility in exception handling: Can implement \\"forward retry\\" or \\"backward compensation\\" after recovery from a crash<br />- Naturally supports asynchronous processing engines such as Actor model or SEDA architecture, improving overall throughput<br /> | <br />- Business processes are composed of JAVA programs and DSL configurations, making development relatively cumbersome<br />- High intrusiveness into existing business if it is a transformation<br />- High implementation cost of the engine<br />          |\\n| Interceptor + Java Annotation | <br />- Programs and annotations are integrated, simple development, low learning curve<br />- Easy integration into existing businesses<br />- Low framework implementation cost                                                                                                                                                                              | <br />- The framework cannot provide asynchronous processing modes such as the Actor model or SEDA architecture to improve system throughput<br />- The framework cannot provide business state management<br />- Difficult to achieve \\"forward retry\\" after crash recovery due to the inability to restore thread context<br />          |\\n\\n## Seata Saga Approach\\n\\nThe introduction of Seata Saga can be found in [Seata Saga Official Documentation](http://seata.io/zh-cn/docs/user/saga.html)[6].\\n\\nSeata Saga adopts the state machine + DSL approach for the following reasons:\\n\\n- The state machine + DSL approach is more widely used in practical production scenarios.\\n- Can use asynchronous processing engines such as the Actor model or SEDA architecture to improve overall throughput.\\n- Typically, business systems above the core system have \\"service orchestration\\" requirements, and service orchestration has transactional eventual consistency requirements. These two are challenging to separate. The state machine + DSL approach can simultaneously meet these two requirements.\\n- Because Saga mode theoretically does not guarantee isolation, in extreme cases, it may not complete the rollback operation due to dirty writing. For example, in a distributed transaction, if you recharge user A first and then deduct the balance from user B, if A user consumes the balance before the transaction is committed, and the transaction is rolled back, there is no way to compensate. Some business scenarios may allow the business to eventually succeed, and in cases where rollback is impossible, it can continue to retry the subsequent process. The state machine + DSL approach can achieve the ability to \\"forward\\" recover context and continue execution, making the business eventually successful and achieving eventual consistency.\\n\\n> In cases where isolation is not guaranteed: When designing business processes, follow the principle of \\"prefer long\u6b3e, not short\u6b3e.\\" Long\u6b3e means fewer funds for customers and more funds for institutions. Institutions can refund customers based on their credibility. Conversely, short\u6b3e means less funding for institutions, and the funds may not be recovered. Therefore, in business process design, deduction should be done first.\\n\\n### State Definition Language (Seata State Language)\\n\\n1. Define the service call process through a state diagram and generate a JSON state language definition file.\\n2. In the state diagram, a node can be a service call, and the node can configure its compensating node.\\n3. The JSON state diagram is driven by the state machine engine. When an exception occurs, the state engine executes the compensating node corresponding to the successfully executed node to roll back the transaction.\\n> Note: Whether to compensate when an exception occurs can also be user-defined.\\n\\n4. It can meet service orchestration requirements, supporting one-way selection, concurrency, asynchronous, sub-state machine, parameter conversion, parameter mapping, service execution status judgment, exception capture, and other functions.\\n\\nAssuming a business process calls two services, deducting inventory (InventoryService) and deducting balance (BalanceService), to ensure that in a distributed scenario, either both succeed or both roll back. Both participant services have a `reduce` method for inventory deduction or balance deduction, and a `compensateReduce` method for compensating deduction operations. Let\'s take a look at the interface definition of InventoryService:\\n\\n```java\\npublic interface InventoryService {\\n\\n    /**\\n     * reduce\\n     * @param businessKey\\n     * @param amount\\n     * @param params\\n     * @return\\n     */\\n    boolean reduce(String businessKey, BigDecimal amount, Map<String, Object> params);\\n\\n    /**\\n     * compensateReduce\\n     * @param businessKey\\n     * @param params\\n     * @return\\n     */\\n    boolean compensateReduce(String businessKey, Map<String, Object> params);\\n}\\n```\\n\\n## This is the state diagram corresponding to the business process:\\n\\n![Example State Diagram](/img/saga/demo_statelang.png?raw=true)\\n<br />Corresponding JSON\\n\\n\\n```json\\n{\\n    \\"Name\\": \\"reduceInventoryAndBalance\\",\\n    \\"Comment\\": \\"reduce inventory then reduce balance in a transaction\\",\\n    \\"StartState\\": \\"ReduceInventory\\",\\n    \\"Version\\": \\"0.0.1\\",\\n    \\"States\\": {\\n        \\"ReduceInventory\\": {\\n            \\"Type\\": \\"ServiceTask\\",\\n            \\"ServiceName\\": \\"inventoryAction\\",\\n            \\"ServiceMethod\\": \\"reduce\\",\\n            \\"CompensateState\\": \\"CompensateReduceInventory\\",\\n            \\"Next\\": \\"ChoiceState\\",\\n            \\"Input\\": [\\n                \\"$.[businessKey]\\",\\n                \\"$.[count]\\"\\n            ],\\n            \\"Output\\": {\\n                \\"reduceInventoryResult\\": \\"$.#root\\"\\n            },\\n            \\"Status\\": {\\n                \\"#root == true\\": \\"SU\\",\\n                \\"#root == false\\": \\"FA\\",\\n                \\"$Exception{java.lang.Throwable}\\": \\"UN\\"\\n            }\\n        },\\n        \\"ChoiceState\\":{\\n            \\"Type\\": \\"Choice\\",\\n            \\"Choices\\":[\\n                {\\n                    \\"Expression\\":\\"[reduceInventoryResult] == true\\",\\n                    \\"Next\\":\\"ReduceBalance\\"\\n                }\\n            ],\\n            \\"Default\\":\\"Fail\\"\\n        },\\n        \\"ReduceBalance\\": {\\n            \\"Type\\": \\"ServiceTask\\",\\n            \\"ServiceName\\": \\"balanceAction\\",\\n            \\"ServiceMethod\\": \\"reduce\\",\\n            \\"CompensateState\\": \\"CompensateReduceBalance\\",\\n            \\"Input\\": [\\n                \\"$.[businessKey]\\",\\n                \\"$.[amount]\\",\\n                {\\n                    \\"throwException\\" : \\"$.[mockReduceBalanceFail]\\"\\n                }\\n            ],\\n            \\"Output\\": {\\n                \\"compensateReduceBalanceResult\\": \\"$.#root\\"\\n            },\\n            \\"Status\\": {\\n                \\"#root == true\\": \\"SU\\",\\n                \\"#root == false\\": \\"FA\\",\\n                \\"$Exception{java.lang.Throwable}\\": \\"UN\\"\\n            },\\n            \\"Catch\\": [\\n                {\\n                    \\"Exceptions\\": [\\n                        \\"java.lang.Throwable\\"\\n                    ],\\n                    \\"Next\\": \\"CompensationTrigger\\"\\n                }\\n            ],\\n            \\"Next\\": \\"Succeed\\"\\n        },\\n        \\"CompensateReduceInventory\\": {\\n            \\"Type\\": \\"ServiceTask\\",\\n            \\"ServiceName\\": \\"inventoryAction\\",\\n            \\"ServiceMethod\\": \\"compensateReduce\\",\\n            \\"Input\\": [\\n                \\"$.[businessKey]\\"\\n            ]\\n        },\\n        \\"CompensateReduceBalance\\": {\\n            \\"Type\\": \\"ServiceTask\\",\\n            \\"ServiceName\\": \\"balanceAction\\",\\n            \\"ServiceMethod\\": \\"compensateReduce\\",\\n            \\"Input\\": [\\n                \\"$.[businessKey]\\"\\n            ]\\n        },\\n        \\"CompensationTrigger\\": {\\n            \\"Type\\": \\"CompensationTrigger\\",\\n            \\"Next\\": \\"Fail\\"\\n        },\\n        \\"Succeed\\": {\\n            \\"Type\\":\\"Succeed\\"\\n        },\\n        \\"Fail\\": {\\n            \\"Type\\":\\"Fail\\",\\n            \\"ErrorCode\\": \\"PURCHASE_FAILED\\",\\n            \\"Message\\": \\"purchase failed\\"\\n        }\\n    }\\n}\\n```\\n\\n## This is the state language to some extent referring to [AWS Step Functions](https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-lambda-state-machine.html)[7].\\n\\n<a name=\\"2de9b28a\\"></a>\\n\\n#### Introduction to \\"State Machine\\" Attributes:\\n\\n- Name: Represents the name of the state machine, must be unique;\\n- Comment: Description of the state machine;\\n- Version: Version of the state machine definition;\\n- StartState: The first \\"state\\" to run when starting;\\n- States: List of states, a map structure, where the key is the name of the \\"state,\\" which must be unique within the state machine;\\n\\n<a name=\\"2b956670\\"></a>\\n\\n#### Introduction to \\"State\\" Attributes:\\n\\n- Type: The type of the \\"state,\\" such as:\\n  - ServiceTask: Executes the service task;\\n  - Choice: Single conditional choice route;\\n  - CompensationTrigger: Triggers the compensation process;\\n  - Succeed: Normal end of the state machine;\\n  - Fail: Exceptional end of the state machine;\\n  - SubStateMachine: Calls a sub-state machine;\\n- ServiceName: Service name, usually the beanId of the service;\\n- ServiceMethod: Service method name;\\n- CompensateState: Compensatory \\"state\\" for this state;\\n- Input: List of input parameters for the service call, an array corresponding to the parameter list of the service method, $. represents using an expression to retrieve parameters from the state machine context. The expression uses [SpringEL](https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html)[8], and if it is a constant, write the value directly;\\n- Output: Assigns the parameters returned by the service to the state machine context, a map structure, where the key is the key when placing it in the state machine context (the state machine context is also a map), and the value uses $. as a SpringEL expression, indicating the value is taken from the return parameters of the service, #root represents the entire return parameters of the service;\\n- Status: Mapping of the service execution status, the framework defines three statuses, SU success, FA failure, UN unknown. We need to map the execution status of the service into these three statuses, helping the framework judge the overall consistency of the transaction. It is a map structure, where the key is a condition expression, usually based on the return value of the service or the exception thrown for judgment. The default is a SpringEL expression to judge the return parameters of the service. Those starting with $Exception{ indicate judging the exception type, and the value is mapped to this value when this condition expression is true;\\n- Catch: Route after catching an exception;\\n- Next: The next \\"state\\" to execute after the service is completed;\\n- Choices: List of optional branches in the Choice type \\"state,\\" where Expression is a SpringEL expression, and Next is the next \\"state\\" to execute when the expression is true;\\n- ErrorCode: Error code for the Fail type \\"state\\";\\n- Message: Error message for the Fail type \\"state\\";\\n\\nFor more detailed explanations of the state language, please refer to [Seata Saga Official Documentation](http://seata.io/zh-cn/docs/user/saga.html)[6[http://seata.io/zh-cn/docs/user/saga.html](http://seata.io/zh-cn/docs/user/saga.html)].\\n\\n<a name=\\"209f0e37\\"></a>\\n\\n### State Machine Engine Principle:\\n\\n![State Machine Engine Principle](/img/saga/saga_engine_mechanism.png?raw=true)\\n\\n- The state diagram in the image first executes stateA, then executes stateB, and then executes stateC;\\n- The execution of \\"states\\" is based on an event-driven model. After stateA is executed, a routing message is generated and placed in the EventQueue. The event consumer takes the message from the EventQueue and executes stateB;\\n- When the entire state machine is started, Seata Server is called to start a distributed transaction, and the xid is generated. Then, the start event of the \\"state machine instance\\" is recorded in the local database;\\n- When a \\"state\\" is executed, Seata Server is called to register a branch transaction, and the branchId is generated. Then, the start event of the \\"state instance\\" is recorded in the local database;\\n- After a \\"state\\" is executed, the end event of the \\"state instance\\" is recorded in the local database, and Seata Server is called to report the status of the branch transaction;\\n- When the entire state machine is executed, the completion event of the \\"state machine instance\\" is recorded in the local database, and Seata Server is called to commit or roll back the distributed transaction;\\n\\n\\n<a name=\\"808e95dc\\"></a>\\n\\n### Design of State Machine Engine:\\n\\n![Design of State Machine Engine](/img/saga/saga_engine.png?raw=true)\\n\\nThe design of the state machine engine is mainly divided into three layers, with the upper layer depending on the lower layer. From bottom to top, they are:\\n\\n- Eventing Layer:\\n  - Implements an event-driven architecture that can push events and be consumed by a consumer. This layer does not care about what the event is or what the consumer executes; it is implemented by the upper layer.\\n\\n- ProcessController Layer:\\n  - Driven by the above Eventing to execute a \\"empty\\" process. The behavior and routing of \\"states\\" are not implemented. It is implemented by the upper layer.\\n> Based on the above two layers, theoretically, any \\"process\\" engine can be customly extended. The design of these two layers is based on the internal design of the financial network platform.\\n\\n\\n- StateMachineEngine Layer:\\n  - Implements the behavior and routing logic of each type of state in the state machine engine;\\n  - Provides API and state machine language repository;\\n\\n<a name=\\"73a9fddd\\"></a>\\n\\n### Practical Experience in Service Design under Saga Mode\\n\\nBelow are some practical experiences summarized in the design of microservices under Saga mode. Of course, these are recommended practices, not necessarily to be followed 100%. There are \\"workaround\\" solutions even if not followed.\\n> Good news: Seata Saga mode has no specific requirements for the interface parameters of microservices, making Saga mode suitable for integrating legacy systems or services from external institutions.\\n\\n\\n<a name=\\"d64c5051\\"></a>\\n\\n#### Allow Empty Compensation\\n\\n- Empty Compensation: The original service was not executed, but the compensation service was executed;\\n- Reasons:\\n  - Timeout (packet loss) of the original service;\\n  - Saga transaction triggers a rollback;\\n  - The request of the original service is not received, but the compensation request is received first;\\n\\nTherefore, when designing services, it is necessary to allow empty compensation, that is, if the business primary key to be compensated is not found, return compensation success and record the original business primary key.\\n\\n<a name=\\"88a92b17\\"></a>\\n\\n#### Hang Prevention Control\\n\\n- Hang: Compensation service is executed before the original service;\\n- Reasons:\\n  - Timeout (congestion) of the original service;\\n  - Saga transaction rollback triggers a rollback;\\n  - Congested original service arrives;\\n\\nTherefore, check whether the current business primary key already exists in the business primary keys recorded by empty compensation. If it exists, reject the execution of the service.\\n\\n<a name=\\"ce766631\\"></a>\\n\\n#### Idempotent Control\\n\\n- Both the original service and the compensation service need to ensure idempotence. Due to possible network timeouts, a retry strategy can be set. When a retry occurs, idempotent control should be used to avoid duplicate updates to business data.\\n\\n<a name=\\"FO5YS\\"></a>\\n\\n# Summary\\n\\nMany times, we don\'t need to emphasize strong consistency. We design more resilient systems based on the BASE and Saga theories to achieve better performance and fault tolerance in distributed architecture. There is no silver bullet in distributed architecture, only solutions suitable for specific scenarios. In fact, Seata Saga is a product with the capabilities of \\"service orchestration\\" and \\"Saga distributed transactions.\\" Summarizing, its applicable scenarios are:\\n\\n- Suitable for handling \\"long transactions\\" in a microservices architecture;\\n- Suitable for \\"service orchestration\\" requirements in a microservices architecture;\\n- Suitable for business systems with a large number of composite services above the financial core system (such as systems in the channel layer, product layer, integration layer);\\n- Suitable for scenarios where integration with services provided by legacy systems or external institutions is required (these services are immutable and cannot be required to be modified).\\n\\n<a name=\\"3X7vO\\"></a>\\n\\n## Related Links Mentioned in the Article\\n\\n[1][https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf](https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf)<br />[2][http://microservices.io/patterns/data/saga.html](http://microservices.io/patterns/data/saga.html)<br />[3][Microprofile \u7684 LRA](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA)\uff1a[https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA)<br />[4][Eventuate Tram Saga](https://github.com/eventuate-tram/eventuate-tram-sagas)\uff1a[https://github.com/eventuate-tram/eventuate-tram-sagas](https://github.com/eventuate-tram/eventuate-tram-sagas)<br />[5][ServiceComb Saga](https://github.com/apache/incubator-servicecomb-saga)\uff1a[https://github.com/apache/servicecomb-pack](https://github.com/apache/servicecomb-pack)<br />[6][Seata Saga \u5b98\u7f51\u6587\u6863](http://seata.io/zh-cn/docs/user/saga.html)\uff1a[http://seata.io/zh-cn/docs/user/saga.html](http://seata.io/zh-cn/docs/user/saga.html)<br />[7][AWS Step Functions](https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-lambda-state-machine.html)\uff1a[https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-lambda-state-machine.html](https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-lambda-state-machine.html)<br />[8][SpringEL](https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html)\uff1a[https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html](https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html)<br />"},{"id":"/quick-start-use-seata-and-dubbo-services","metadata":{"permalink":"/blog/quick-start-use-seata-and-dubbo-services","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/quick-start-use-seata-and-dubbo-services.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/quick-start-use-seata-and-dubbo-services.md","title":"How to use Seata to ensure consistency between Dubbo Microservices","description":"This article will introduce you how to use Seata to ensure consistency between Dubbo Microservices.","date":"2019-03-07T00:00:00.000Z","formattedDate":"March 7, 2019","tags":[],"readingTime":2.84,"hasTruncateMarker":false,"authors":[{"name":"slievrly"}],"frontMatter":{"title":"How to use Seata to ensure consistency between Dubbo Microservices","keywords":["Dubbo","Seata","Consistency"],"description":"This article will introduce you how to use Seata to ensure consistency between Dubbo Microservices.","author":"slievrly","date":"2019-03-07T00:00:00.000Z"},"prevItem":{"title":"Designing More Flexible Financial Applications with Seata Saga","permalink":"/blog/design-more-flexable-application-by-saga"},"nextItem":{"title":"MT mode","permalink":"/blog/manual-transaction-mode"}},"content":"## Use case\\n\\nA business logic for user purchasing commodities. The whole business logic is powered by 3 microservices:\\n\\n- Storage service: deduct storage count on given commodity.\\n- Order service: create order according to purchase request.\\n- Account service: debit the balance of user\'s account.\\n\\n### Architecture\\n\\n![Architecture](/img/blog/seata/seata-1.png) \\n\\n\\n### StorageService\\n\\n```java\\npublic interface StorageService {\\n\\n    /**\\n     * deduct storage count\\n     */\\n    void deduct(String commodityCode, int count);\\n}\\n```\\n\\n### OrderService\\n\\n```java\\npublic interface OrderService {\\n\\n    /**\\n     * create order\\n     */\\n    Order create(String userId, String commodityCode, int orderCount);\\n}\\n```\\n\\n### AccountService\\n\\n```java\\npublic interface AccountService {\\n\\n    /**\\n     * debit balance of user\'s account\\n     */\\n    void debit(String userId, int money);\\n}\\n```\\n\\n### Main business logic\\n\\n```java\\npublic class BusinessServiceImpl implements BusinessService {\\n\\n    private StorageService storageService;\\n\\n    private OrderService orderService;\\n\\n    /**\\n     * purchase\\n     */\\n    public void purchase(String userId, String commodityCode, int orderCount) {\\n\\n        storageService.deduct(commodityCode, orderCount);\\n\\n        orderService.create(userId, commodityCode, orderCount);\\n    }\\n}\\n```\\n\\n```java\\npublic class StorageServiceImpl implements StorageService {\\n\\n  private StorageDAO storageDAO;\\n  \\n    @Override\\n    public void deduct(String commodityCode, int count) {\\n        Storage storage = new Storage();\\n        storage.setCount(count);\\n        storage.setCommodityCode(commodityCode);\\n        storageDAO.update(storage);\\n    }\\n}\\n```\\n\\n```java\\npublic class OrderServiceImpl implements OrderService {\\n\\n    private OrderDAO orderDAO;\\n\\n    private AccountService accountService;\\n\\n    public Order create(String userId, String commodityCode, int orderCount) {\\n\\n        int orderMoney = calculate(commodityCode, orderCount);\\n\\n        accountService.debit(userId, orderMoney);\\n\\n        Order order = new Order();\\n        order.userId = userId;\\n        order.commodityCode = commodityCode;\\n        order.count = orderCount;\\n        order.money = orderMoney;\\n\\n        return orderDAO.insert(order);\\n    }\\n}\\n```\\n\\n## Distributed Transaction Solution with Seata\\n\\n![undefined](/img/blog/seata/seata-2.png) \\n\\nWe just need an annotation `@GlobalTransactional` on business method: \\n\\n```java\\n\\n    @GlobalTransactional\\n    public void purchase(String userId, String commodityCode, int orderCount) {\\n        ......\\n    }\\n```\\n\\n## Example powered by Dubbo + Seata\\n\\n### Step 1: Setup database\\n\\n- Requirement: MySQL with InnoDB engine.\\n\\n**Note:** In fact, there should be 3 database for the 3 services in the example use case. However, we can just create one database and configure 3 data sources for simple. \\n\\nModify Spring XML with the database URL/username/password you just created.\\n\\ndubbo-account-service.xml\\ndubbo-order-service.xml\\ndubbo-storage-service.xml\\n\\n```xml\\n    <property name=\\"url\\" value=\\"jdbc:mysql://x.x.x.x:3306/xxx\\" />\\n    <property name=\\"username\\" value=\\"xxx\\" />\\n    <property name=\\"password\\" value=\\"xxx\\" />\\n```\\n### Step 2: Create UNDO_LOG table for Seata\\n\\n`UNDO_LOG` table is required by Seata AT mode.\\n\\n```sql\\nCREATE TABLE `undo_log` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `branch_id` bigint(20) NOT NULL,\\n  `xid` varchar(100) NOT NULL,\\n  `rollback_info` longblob NOT NULL,\\n  `log_status` int(11) NOT NULL,\\n  `log_created` datetime NOT NULL,\\n  `log_modified` datetime NOT NULL,\\n  `ext` varchar(100) DEFAULT NULL,\\n  PRIMARY KEY (`id`),\\n  KEY `idx_unionkey` (`xid`,`branch_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=159 DEFAULT CHARSET=utf8\\n```\\n\\n### Step 3: Create tables for example business\\n\\n```sql\\n\\nDROP TABLE IF EXISTS `storage_tbl`;\\nCREATE TABLE `storage_tbl` (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `commodity_code` varchar(255) DEFAULT NULL,\\n  `count` int(11) DEFAULT 0,\\n  PRIMARY KEY (`id`),\\n  UNIQUE KEY (`commodity_code`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\\n\\n\\nDROP TABLE IF EXISTS `order_tbl`;\\nCREATE TABLE `order_tbl` (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` varchar(255) DEFAULT NULL,\\n  `commodity_code` varchar(255) DEFAULT NULL,\\n  `count` int(11) DEFAULT 0,\\n  `money` int(11) DEFAULT 0,\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\\n\\n\\nDROP TABLE IF EXISTS `account_tbl`;\\nCREATE TABLE `account_tbl` (\\n  `id` int(11) NOT NULL AUTO_INCREMENT,\\n  `user_id` varchar(255) DEFAULT NULL,\\n  `money` int(11) DEFAULT 0,\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\\n```\\n### Step 4: Start Seata-Server\\n\\n- Download server [package](https://github.com/apache/incubator-seata/releases), unzip it.\\n- Start Seata-Server\\n\\n```shell\\nsh seata-server.sh $LISTEN_PORT $PATH_FOR_PERSISTENT_DATA\\n\\ne.g.\\n\\nsh seata-server.sh 8091 /home/admin/seata/data/\\n```\\n\\n### Step 5: Run example\\n\\n- Start AccountService ([DubboAccountServiceStarter](https://github.com/apache/incubator-seata-samples/blob/master/dubbo/src/main/java/com/seata/seata/samples/dubbo/starter/DubboAccountServiceStarter.java)).\\n- Start StorageService ([DubboStorageServiceStarter](https://github.com/apache/incubator-seata-samples/blob/master/dubbo/src/main/java/com/seata/seata/samples/dubbo/starter/DubboStorageServiceStarter.java)).\\n- Start OrderService ([DubboOrderServiceStarter](https://github.com/apache/incubator-seata-samples/blob/master/dubbo/src/main/java/com/seata/seata/samples/dubbo/starter/DubboOrderServiceStarter.java)).\\n- Run BusinessService for test ([DubboBusinessTester](https://github.com/apache/incubator-seata-samples/blob/master/dubbo/src/main/java/com/seata/seata/samples/dubbo/starter/DubboBusinessTester.java)).\\n\\n### Related projects\\n* seata:          https://github.com/apache/incubator-seata/\\n* seata-samples : https://github.com/apache/incubator-seata-samples"},{"id":"/manual-transaction-mode","metadata":{"permalink":"/blog/manual-transaction-mode","editUrl":"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/manual-transaction-mode.md","source":"@site/i18n/en/docusaurus-plugin-content-blog/manual-transaction-mode.md","title":"MT mode","description":"introduce MT mode","date":"2019-02-13T00:00:00.000Z","formattedDate":"February 13, 2019","tags":[],"readingTime":1.12,"hasTruncateMarker":false,"authors":[{"name":"kmmshmily"}],"frontMatter":{"title":"MT mode","keywords":["MT mode"],"description":"introduce MT mode","author":"kmmshmily","date":"2019-02-13T00:00:00.000Z"},"prevItem":{"title":"How to use Seata to ensure consistency between Dubbo Microservices","permalink":"/blog/quick-start-use-seata-and-dubbo-services"}},"content":"Review the description in the overview: a distributed global transaction, the whole is a model of **the two-phase commit**. A global transaction consists of several branch transactions that meet the model requirements of **the two-phase commit**, which requires each branch transaction to have its own:\\n\\n- One phase prepare behavior\\n- Two phase commit or rollback behavior\\n\\n![Overview of a global transaction](https://upload-images.jianshu.io/upload_images/4420767-e48f0284a037d1df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\\n\\nAccording to the two phase behavior pattern\uff0cWe divide the branch transaction into **Automatic (Branch) Transaction Mode** and **Manual (Branch) Transaction Mode**.\\n\\nThe AT mode is based on the **Relational Database** that **supports local ACID transactions**\uff1a\\n\\n- One phase prepare behavior: In the local transaction, the business data update and the corresponding rollback log record are submitted together.\\n- Two phase commit behavior: Immediately ended successfully, **Auto** asynchronous batch cleanup of the rollback log.\\n- Two phase rollback behavior: By rolling back the log, **automatic** generates a compensation operation to complete the data rollback.\\n\\nAccordingly, the MT mode does not rely on transaction support for the underlying data resources:\\n\\n- One phase prepare behavior: Call the prepare logic of **custom** .\\n- Two phase commit behavior:Call the commit logic of **custom** .\\n- Two phase rollback behavior:Call the rollback logic of **custom** .\\n\\nThe so-called MT mode refers to the support of the branch transaction of **custom** into the management of global transactions."}]}')}}]);
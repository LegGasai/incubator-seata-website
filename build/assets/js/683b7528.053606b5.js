"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[68328],{55810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=t(74848),a=t(28453);const s={title:"Seata Source Code - Client Startup Process in Distributed Transactions",author:"xiaobin.yang",date:"2020/08/25",keywords:["fescar","seata","distributed transaction"]},o=void 0,i={permalink:"/blog/seata-sourcecode-client-bootstrap",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-sourcecode-client-bootstrap.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-sourcecode-client-bootstrap.md",title:"Seata Source Code - Client Startup Process in Distributed Transactions",description:"\u3010Distributed Transaction Seata source code interpretation II\u3011 Client-side startup process",date:"2020-08-25T00:00:00.000Z",formattedDate:"August 25, 2020",tags:[],readingTime:10.1,hasTruncateMarker:!1,authors:[{name:"xiaobin.yang"}],frontMatter:{title:"Seata Source Code - Client Startup Process in Distributed Transactions",author:"xiaobin.yang",date:"2020/08/25",keywords:["fescar","seata","distributed transaction"]},unlisted:!1,prevItem:{title:"Analysis of Seata Data Source Proxy",permalink:"/blog/seata-datasource-proxy"},nextItem:{title:"Setting Up Seata Demo Environment on Mac (AT Mode)",permalink:"/blog/seata-at-demo-in-mac"}},c={authorsImageUrls:[void 0]},l=[{value:"\u3010Distributed Transaction Seata source code interpretation II\u3011 Client-side startup process",id:"distributed-transaction-seata-source-code-interpretation-ii-client-side-startup-process",level:2},{value:"seata-spring-boot-starter",id:"seata-spring-boot-starter",level:2},{value:"GlobalTransactionScanner",id:"globaltransactionscanner",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"distributed-transaction-seata-source-code-interpretation-ii-client-side-startup-process",children:"\u3010Distributed Transaction Seata source code interpretation II\u3011 Client-side startup process"}),"\n",(0,r.jsx)(n.p,{children:"In this paper, we analyse the Client-side startup process in AT mode from the source code point of view, the so-called Client-side, i.e. the business application side. Distributed transactions are divided into three modules: TC, TM, RM, where TC is located in the seata-server side, while TM, RM through the SDK way to run in the client side."}),"\n",(0,r.jsx)(n.p,{children:"The following figure shows a distributed transaction scenario of Seata's official demo, divided into the following several microservices, which together implement a distributed transaction of placing an order, deducting inventory, and deducting balance."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"**BusinessService: ** business service, the entrance to the order placing service"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"StorageService\uff1a"})," Inventory microservice, used to deduct the inventory of goods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OrderService:"})," Order microservice, to create orders"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AccountService:"})," Account microservice, debits the balance of the user's account"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["! [Insert image description here](",(0,r.jsx)(n.a,{href:"https://img-blog.csdnimg.cn/20200820184156758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10",children:"https://img-blog.csdnimg.cn/20200820184156758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10"}),", text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE0NTg0OA==,size_16,colour_FFFFFF,t_70#pic_center)"]}),"\n",(0,r.jsx)(n.p,{children:"It can also be seen from the above figure that in AT mode Seata Client side implements distributed transactions mainly through the following three modules:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GlobalTransactionScanner:"})," GlobalTransactionScanner is responsible for initialising the TM, RM module and adding interceptors for methods that add distributed transaction annotations, the interceptors are responsible for the opening, committing or rolling back of the global transaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DatasourceProxy:"})," DatasourceProxy for DataSource to add interception , the interceptor will intercept all SQL execution , and as RM transaction participant role in the distributed transaction execution ."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rpc Interceptor:"})," In the previous article ",(0,r.jsx)(n.a,{href:"https://blog.csdn.net/weixin_45145848/article/details/106930538",children:"Distributed Transaction Seata Source Code Interpretation I"})," there are a few core points of distributed transaction mentioned, one of which is Cross-Service Instance Propagation of Distributed Transactions The Rpc Interceptor is responsible for propagating transactions across multiple microservices."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"seata-spring-boot-starter",children:"seata-spring-boot-starter"}),"\n",(0,r.jsx)(n.p,{children:"There are two ways to refer to the seata Distributed Transaction SDK, relying on seata-all or seata-spring-boot-starter. It is recommended to use the seata-spring-boot-starter because the starter has automatically injected the three modules mentioned above, and the user only needs to add the corresponding configuration in the business code to add a global distributed transaction annotation can be. Here's how to start with the code in the seata-spring-boot-starter project:"}),"\n",(0,r.jsxs)(n.p,{children:["The following figure shows the project structure of seata-spring-boot-starter:\n! [Insert image description here](",(0,r.jsx)(n.a,{href:"https://img-blog.csdnimg.cn/20200810204518853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10",children:"https://img-blog.csdnimg.cn/20200810204518853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10"}),", text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE0NTg0OA==,size_16,colour_FFFFFF,t_70)\nIt is mainly divided into the following modules:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"properties:"})," The properties directory contains the configuration classes that Springboot adapts to seata, i.e., you can use SpringBoot's configuration to configure the parameters of seata."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"provider:"})," The classes in the provider directory are responsible for adapting Springboot and SpringCloud configurations to the Seata configuration."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"resources:"})," There are two main files in the resources directory, spring.facts for registering Springboot auto-assembly classes and ExtConfigurationProvider for registering the SpringbootConfigurationProvider class, the Provider class is responsible for adapting SpringBoot related configuration classes to Seata."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For the springboot-starter project, let's first look at the resources/META-INF/spring.factors file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-properties.",children:"# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\nio.seata.spring.boot.autoconfigure.SeataAutoConfiguration\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can see that the autoconfiguration class is configured in spring.facts: SeataAutoConfiguration, in which two instances of GlobalTransactionScanner and seataAutoDataSourceProxyCreator are injected. The code is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java.",children:'@ComponentScan(basePackages = "io.seata.spring.boot.autoconfigure.properties")\n@ConditionalOnProperty(prefix = StarterConstants.SEATA_PREFIX, name = "enabled",\n        havingValue = "true",\n        matchIfMissing = true)\n@Configuration\n@EnableConfigurationProperties({SeataProperties.class})\npublic class SeataAutoConfiguration {\n\n  ...\n\n  // GlobalTransactionScanner is responsible for adding interceptors to methods that add the GlobalTransaction annotation.\n  // and is responsible for initialising the RM, TM\n  @Bean\n  @DependsOn({BEAN_NAME_SPRING_APPLICATION_CONTEXT_PROVIDER, BEAN_NAME_FAILURE_HANDLER})\n  @ConditionalOnMissingBean(GlobalTransactionScanner.class)\n  public GlobalTransactionScanner globalTransactionScanner(SeataProperties seataProperties,\n                                                           FailureHandler failureHandler) {\n    if (LOGGER.isInfoEnabled()) {\n      LOGGER.info("Automatically configure Seata");\n    }\n    return new GlobalTransactionScanner(seataProperties.getApplicationId(),\n            seataProperties.getApplicationId(), seataProperties.getTxServiceGroup(), failureHandler); }\n            failureHandler); }\n  }\n\n  // The SeataAutoDataSourceProxyCreator is responsible for generating proxies for all DataSources in Spring.\n  // This enables the interception of all SQL execution.\n  @Bean(BEAN_NAME_SEATA_AUTO_DATA_SOURCE_PROXY_CREATOR)\n  @ConditionalOnProperty(prefix = StarterConstants.SEATA_PREFIX, name = {\n          "enableAutoDataSourceProxy", "enable-auto" +\n          "-data-source-proxy"}, havingValue = "true", matchIfMissing = true)\n  @ConditionalOnMissingBean(SeataAutoDataSourceProxyCreator.class)\n  public SeataAutoDataSourceProxyCreator seataAutoDataSourceProxyCreator(SeataProperties seataProperties) {\n    return new SeataAutoDataSourceProxyCreator(seataProperties.isUseJdkProxy(), seataProperties.getExpressionCreator(seataProperties.getExpressionCreator))\n            seataProperties.getExcludesForAutoProxying());\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"globaltransactionscanner",children:"GlobalTransactionScanner"}),"\n",(0,r.jsx)(n.p,{children:"GlobalTransactionScanner inherits from AutoProxyCreator, which is a way to implement AOP in Spring to intercept all instances in Spring and determine whether they need to be proxied. Below is a list of some of the more important fields in GlobalTransactionScanner and the core methods for intercepting proxies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class GlobalTransactionScanner extends AbstractAutoProxyCreator\n        implements InitialisingBean, ApplicationContextAware,\n        DisposableBean {\n  ...\n  // The interceptor field is the interceptor corresponding to a proxy object.\n  // It can be thought of as a temporary variable with an expiration date of a proxied object.\n  private MethodInterceptor interceptor; // globalTransactionalInterceptor.\n\n  // globalTransactionalInterceptor is the generic Interceptor.\n  // It is used by all non-TCC transactional methods.\n  private MethodInterceptor globalTransactionalInterceptor; // PROXYED_SETTING_OBJECT\n\n  // PROXYED_SET stores instances that have already been proxied to prevent duplicate processing.\n  private static final Set<String> PROXYED_SET = new HashSet<>(); // applicationId is the name of a service.\n\n  // applicationId is a unique identifier for a service.\n  // corresponds to spring.application.name in the springcloud project\n  private final String applicationId; // The group identifier of the transaction.\n  // Grouping identifier for the transaction, refer to the wiki article: https://seata.apache.org/zh-cn/docs/user/txgroup/transaction-group/\n  private final String txServiceGroup; // The group identifier of the transaction.\n\n  ...\n\n // Determine whether the target object needs to be proxied, and if so, generate an interceptor and assign it to the class variable interceptor.\n  @Override\n  protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n  \t// Determine if distributed transactions are disabled\n    if (disableGlobalTransaction) {\n      return bean; }\n    }\n    try {\n      synchronized (PROXYED_SET) {\n        if (PROXYED_SET.contains(beanName)) {\n          return bean; }\n        }\n\n        // Each time a proxied object is processed, the intermediary is set to null, so the intermediary's // lifecycle is that of a proxied object.\n        // lifecycle is a proxied object, and since the intermediary is used in a separate method, getAdvicesAndAdvisorsForBean\n        // Since the interceptor is used in a separate method getAdvicesAndAdvisorsForBean, the interceptor is defined as a class variable\n        interceptor = null; // Determine if this is a TCC transaction.\n\n        // Determine whether this is TCC transaction mode, primarily based on the presence of the TwoPhaseBusinessAction annotation on the method\n        if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) { if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName,\n                applicationContext)) {\n          // Create an interceptor for the TCC transaction\n          interceptor =\n                  new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName));\n        } else {\n          // Get the class type of the object to be processed\n          Class<? > serviceInterface = SpringProxyUtils.findTargetClass(bean); } else { // Get the class type of the object to be processed.\n          // Get all interfaces inherited by the object to be processed\n          Class<? >[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean); // Get all interfaces inherited by the pending object.\n\n          // If there is a GlobalTransactional annotation on the class of the pending object or on the inherited interfaces.\n          // or any of the methods of the class of the object to be handled have a GlobalTransactional or\n          // GlobalLock annotation on any of the methods of the class of the object to be handled returns true, i.e., it needs to be proxied.\n          if (!existsAnnotation(new Class[]{serviceInterface})\n                  && !existsAnnotation(interfacesIfJdk)) {\n            return bean;\n          }\n\n          // If the interceptor is null, i.e. not in TCC mode.\n          // then use globalTransactionalInterceptor as the interceptor\n          if (interceptor == null) {\n            // globalTransactionalInterceptor will only be created once\n            if (globalTransactionalInterceptor == null) {\n              globalTransactionalInterceptor =\n                      new GlobalTransactionalInterceptor(failureHandlerHook);\n              ConfigurationCache.addConfigListener(\n                      ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION, (ConfigurationChangeListener.addConfigListener(\n                      (ConfigurationChangeListener) globalTransactionalInterceptor);\n            }\n            interceptor = globalTransactionalInterceptor;\n          }\n        }\n\n        if (!AopUtils.isAopProxy(bean)) {\n          // If the bean itself is not a Proxy object, then the parent class wrapIfNecessary is called to generate the proxy object\n          // In the parent class, getAdvicesAndAdvisorsForBean is called to get the interceptor defined above.\n          bean = super.wrapIfNecessary(bean, beanName, cacheKey); } else { getAdvicesAndAdvisorsForBean(bean, beanName, cacheKey); }\n        } else {\n          // If the bean is already a proxy, add a new interceptor directly to the proxy's interceptor call chain, AdvisedSupport\n          // and add the new interceptor directly to the proxy's interception invocation chain.\n          AdvisedSupport advised = SpringProxyUtils.getAdvisedSupport(bean);\n          Advisor[] advisor = buildAdvisors(beanName,\n                  getAdvicesAndAdvisorsForBean(null, null, null));\n          for (Advisor avr : advisor) {\n            advised.addAdvisor(0, avr);\n          }\n        }\n        // Mark that the beanName has been processed\n        PROXYED_SET.add(beanName);\n        return bean; }\n      }\n    } catch (Exception exx) {\n      throw new RuntimeException(exx); }\n    }\n  }\n\n  // Return the interceptor object computed in the wrapIfNecessary method.\n  @Override\n  protected Object[] getAdvicesAndAdvisorsForBean(Class beanClass, String beanName,\n                                                  TargetSource customTargetSource)\n          throws BeansException {\n    return new Object[]{interceptor};\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The above describes how GlobalTransactionScanner intercepts global transactions via annotations, the specific interceptor implementations are TccActionInterceptor and GlobalTransactionalInterceptor, for the AT pattern we are mainly concerned with the GlobalTransactionalInterceptor, in subsequent articles will introduce the specific implementation of GlobalTransactionalInterceptor."}),"\n",(0,r.jsx)(n.p,{children:"In addition GloabalTransactionScanner is also responsible for the initialisation of TM, RM, which is implemented in the initClient method:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void initClient() {\n...\n\n    // Initialise the TM\n    TMClient.init(applicationId, txServiceGroup); ...\n    ...\n\n    //Initialise RM\n    RMClient.init(applicationId, txServiceGroup); ...\n\t...\n\n    // Register the Spring shutdown callback to free up resources.\n    registerSpringShutdownHook(); ... // Register the Spring shutdown callback for releasing resources.\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"TMClient, RMClient are Seata based on Netty implementation of the Rpc framework of the client class, just business logic is different, due to TMClient is relatively more simple, we take RMClient as an example to see the source code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class RMClient {\n  // RMClient's init is a static method that creates an instance of RmNettyRemotingClient and calls the init method.\n  public static void init(String applicationId, String transactionServiceGroup) {\n    RmNettyRemotingClient rmNettyRemotingClient =\n            RmNettyRemotingClient.getInstance(applicationId, transactionServiceGroup);\n    rmNettyRemotingClient.setResourceManager(DefaultResourceManager.get());\n    rmNettyRemotingClient.setTransactionMessageHandler(DefaultRMHandler.get()); rmNettyRemotingClient.setTransactionMessageHandler(DefaultRMHandler.get());\n    rmNettyRemotingClient.init();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"RmNettyRemotingClient is implemented as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Sharable\npublic final class RmNettyRemotingClient extends AbstractNettyRemotingClient {\n  // ResourceManager is responsible for handling transaction participants, supports AT, TCC and Saga modes.\n\n  // RmNettyRemotingClient singleton.\n  private static volatile RmNettyRemotingClient instance; // RmNettyRemotingClient instance; // RmNettyRemotingClient instance.\n  private final AtomicBoolean initialised = new AtomicBoolean(false); // The unique identifier of the microservice.\n  // Unique identifier of the microservice\n  private String applicationId; // Distributed transaction group name.\n  // Distributed transaction group name\n  private String transactionServiceGroup; // The name of the distributed transaction group.\n\n  // The init method is called by the init method in RMClient.\n  public void init() {\n    // Register the Processor for Seata's custom Rpc.\n    registerProcessor(); // If (initialised.compareAndAndroid)\n    if (initialised.compareAndSet(false, true)) {\n      // Call the init method of the parent class, which is responsible for initialising Netty and establishing a connection to the Seata-Server in the parent class\n      super.init();\n    }\n  }\n\n  // Register the Processor for the Seata custom Rpc.\n  private void registerProcessor() {\n    // 1. Register the Processor for the Seata-Server initiating the branchCommit.\n    RmBranchCommitProcessor rmBranchCommitProcessor =\n            new RmBranchCommitProcessor(getTransactionMessageHandler(), this);\n    super.registerProcessor(MessageType.TYPE_BRANCH_COMMIT, rmBranchCommitProcessor,\n            messageExecutor); messageExecutor\n\n    // 2. Register the Processor for the Seata-Server initiating the branchRollback.\n    RmBranchRollbackProcessor rmBranchRollbackProcessor =\n            new RmBranchRollbackProcessor(getTransactionMessageHandler(), this);\n    super.registerProcessor(MessageType.TYPE_BRANCH_ROLLBACK, rmBranchRollbackProcessor\n            , messageExecutor);\n\n    // 3. Register the Processor for the Seata-Server initiating the deletion of the undoLog.\n    RmUndoLogProcessor rmUndoLogProcessor =\n            new RmUndoLogProcessor(getTransactionMessageHandler());\n    super.registerProcessor(MessageType.TYPE_RM_DELETE_UNDOLOG, rmUndoLogProcessor,\n            rmUndoLogProcessor, rmUndoLogProcessor); messageExecutor);\n\n    // 4. Register the Processor for the response returned by Seata-Server, ClientOnResponseProcessor.\n    // Used to process the Request initiated by the Client and the Response returned by the Seata-Server.\n    The ClientOnResponseProcessor // is responsible for processing the Request sent by the Client and the Response returned by the Seata-Server.\n    // Response returned by the Seata-Server, thus implementing Rpc.\n    ClientOnResponseProcessor onResponseProcessor =\n            new ClientOnResponseProcessor(mergeMsgMap, super.getFutures(),\n                    getTransactionMessageHandler());\n    super.registerProcessor(MessageType.TYPE_SEATA_MERGE_RESULT, onResponseProcessor,\n            null); super.registerProcessor(MessageType.TYPE_SEATA_MERGE_RESULT, onResponseProcessor, null)\n    super.registerProcessor(MessageType.TYPE_BRANCH_REGISTER_RESULT, onResponseProcessor, null); super.registerProcessor(MessageType.\n            onResponseProcessor, null); super.registerProcessor(MessageType.\n    super.registerProcessor(MessageType.TYPE_BRANCH_STATUS_REPORT_RESULT, onResponseProcessor, null); super.registerProcessor(MessageType.\n            onResponseProcessor, null);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_LOCK_QUERY_RESULT,\n            onResponseProcessor, null); super.registerProcessor(MessageType.\n    super.registerProcessor(MessageType.TYPE_REG_RM_RESULT, onResponseProcessor, null);\n\n    // 5. Processing Pong messages returned by Seata-Server\n    ClientHeartbeatProcessor clientHeartbeatProcessor = new ClientHeartbeatProcessor();\n    super.registerProcessor(MessageType.TYPE_HEARTBEAT_MSG, clientHeartbeatProcessor,\n            null);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The above logic seems to be quite complex, and there are many related classes, such as Processor, MessageType, TransactionMessageHandler, ResourceManager, etc. In fact, it's essentially an Rpc call, which can be divided into Rm-initiated and Seata-initiated calls."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rm active call methods:"})," such as: registering branches, reporting branch status, applying global locks, etc. Rm active call methods need to be in the ClientOnResponseProcessor to handle the Response returned by Seata-Server."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Seata-Server active call methods:"})," such as: commit branch transactions, rollback branch transactions, delete undolog log. Seata-Server active call methods, the Client side corresponds to a different Processor to deal with, and after the end of processing to return to the Seata-Server processing results. Response. The core implementation logic of transaction commit and rollback are in TransactionMessageHandler and ResourceManager."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"About TransactionMessageHandler, ResourceManager implementation will also be described in detail in subsequent chapters."}),"\n",(0,r.jsx)(n.p,{children:"The next article will introduce the SeataAutoDataSourceProxyCreator, Rpc Interceptor is how to initialise and intercept."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(96540);const a={},s=r.createContext(a);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);
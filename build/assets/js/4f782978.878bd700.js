"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[60358],{50362:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(74848),o=t(28453);const i={title:"Unveiling the Principles of Fescar Distributed Transaction",author:"kailin.chen",keywords:["Fescar","distributed transaction"],date:"2019/02/18"},r="Introduction",s={permalink:"/blog/seata-analysis-simple",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-analysis-simple.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-analysis-simple.md",title:"Unveiling the Principles of Fescar Distributed Transaction",description:"Fescar has been released for a while, and distributed transactions have always been a highly focused area in the industry. Fescar received nearly 5000 stars within a month of its release, indicating its popularity. Of course, before Fescar, there were already relatively mature open-source distributed transaction solutions, such as the 2PC non-intrusive transaction of LCN, which has now evolved to version 5.0 and supports TCX transactions similar to Fescar's transaction model. Other implementations of TCC transactions include hmily and tcc-transaction. In the current era of microservice architecture, and given Alibaba's extensive background in open source, the release of Fescar has undoubtedly sparked a new wave of research into distributed transactions. Fescar originated from Alibaba Cloud's commercial distributed transaction service GTS, a model that has undergone rigorous testing in online environments. The TXC distributed transaction model of Fescar is similar to the traditional XA transaction model, with the main difference being the positioning of the resource manager\u2014one at the application layer and the other at the database layer. The author believes that Fescar's TXC model implementation is of significant research value, so today we will thoroughly explore the Fescar project's code. This article is lengthy and will take about 30-60 minutes to read and understand.",date:"2019-02-18T00:00:00.000Z",formattedDate:"February 18, 2019",tags:[],readingTime:16.97,hasTruncateMarker:!1,authors:[{name:"kailin.chen"}],frontMatter:{title:"Unveiling the Principles of Fescar Distributed Transaction",author:"kailin.chen",keywords:["Fescar","distributed transaction"],date:"2019/02/18"},unlisted:!1,prevItem:{title:"How to use Seata to ensure consistency between Dubbo Microservices",permalink:"/blog/quick-start-use-seata-and-dubbo-services"},nextItem:{title:"MT mode",permalink:"/blog/manual-transaction-mode"}},l={authorsImageUrls:[void 0]},c=[{value:"First, Analyze the Configuration File",id:"first-analyze-the-configuration-file",level:2},{value:"[TM] Module Starts Global Transactions",id:"tm-module-starts-global-transactions",level:2},{value:"Passing Global Transaction xid with [dubbo]",id:"passing-global-transaction-xid-with-dubbo",level:2},{value:"Intervention of Local Resource Management in the [RM] Module",id:"intervention-of-local-resource-management-in-the-rm-module",level:2},{value:"PlainExecutor:",id:"plainexecutor",level:3},{value:"UpdateExecutor, DeleteExecutor, InsertExecutor:",id:"updateexecutor-deleteexecutor-insertexecutor",level:3},{value:"SelectForUpdateExecutor:",id:"selectforupdateexecutor",level:3},{value:"Registration and Reporting of Branch Transactions",id:"registration-and-reporting-of-branch-transactions",level:2},{value:"Coordinating the Global Transaction with the [server] Module",id:"coordinating-the-global-transaction-with-the-server-module",level:2},{value:"About the Author:",id:"about-the-author",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Fescar has been released for a while, and distributed transactions have always been a highly focused area in the industry. Fescar received nearly 5000 stars within a month of its release, indicating its popularity. Of course, before Fescar, there were already relatively mature open-source distributed transaction solutions, such as the 2PC non-intrusive transaction of ",(0,a.jsx)(n.a,{href:"https://github.com/codingapi/tx-lcn",children:"LCN"}),", which has now evolved to version 5.0 and supports TCX transactions similar to Fescar's transaction model. Other implementations of TCC transactions include ",(0,a.jsx)(n.a,{href:"https://github.com/yu199195/hmily",children:"hmily"})," and ",(0,a.jsx)(n.a,{href:"https://github.com/changmingxie/tcc-transaction",children:"tcc-transaction"}),". In the current era of microservice architecture, and given Alibaba's extensive background in open source, the release of Fescar has undoubtedly sparked a new wave of research into distributed transactions. Fescar originated from Alibaba Cloud's commercial distributed transaction service GTS, a model that has undergone rigorous testing in online environments. The TXC distributed transaction model of Fescar is similar to the traditional XA transaction model, with the main difference being the positioning of the resource manager\u2014one at the application layer and the other at the database layer. The author believes that Fescar's TXC model implementation is of significant research value, so today we will thoroughly explore the Fescar project's code. This article is lengthy and will take about 30-60 minutes to read and understand."]}),"\n",(0,a.jsx)(n.h1,{id:"project-address",children:"Project Address"}),"\n",(0,a.jsxs)(n.p,{children:["Fescar: ",(0,a.jsx)(n.a,{href:"https://github.com/alibaba/fescar",children:"https://github.com/alibaba/fescar"})]}),"\n",(0,a.jsx)(n.p,{children:"The code discussed in this blog post is from the 0.1.2-SNAPSHOT version of Fescar. As Fescar evolves, the project structure and module implementations might change significantly."}),"\n",(0,a.jsx)(n.h1,{id:"fescars-txc-model",children:"Fescar's TXC Model"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(37814).A+"",width:"764",height:"416"})}),"\n",(0,a.jsx)(n.p,{children:"The above image is an official schematic of the TXC model created by Fescar. The quality of visuals produced by large companies is indeed impressive. From the schematic, we can see the overall implementation of TXC. TXC is implemented through three components, as depicted in the three dark yellow sections in the image, with the following roles:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"TM: Global Transaction Manager, which starts the Fescar distributed transaction on the server side and sends the global transaction to the TC (Transaction Coordinator) for management."}),"\n",(0,a.jsx)(n.li,{children:"TC: Transaction Coordinator, which controls the global transaction's commit or rollback. This component requires independent deployment and maintenance, currently only supporting a single-machine version. Future iterations plan to include a clustered version."}),"\n",(0,a.jsx)(n.li,{children:"RM: Resource Manager, mainly responsible for reporting branch transactions and managing local transactions."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"A brief description of its implementation process: The initiating service starts a global transaction and registers it with the TC. When calling a cooperating service, the branch transaction of the cooperating service completes the first phase of transaction commit or rollback and generates an undo_log for transaction rollback, then registers the current cooperating service with the TC and reports its transaction status, merging it into the global transaction of the same business. If no issues arise, it proceeds to the next cooperating service call. If any branch transaction of the cooperating service rolls back, it will notify the TC, which then notifies all branch transactions of the global transaction that have completed the first phase to roll back. If all branch transactions proceed normally, it will notify the TC when returning to the global transaction initiator, and the TC will notify all branches of the global transaction to delete the rollback logs. To solve write isolation and degree isolation issues during this process, global locks managed by the TC will be involved."}),"\n",(0,a.jsx)(n.p,{children:"The goal of this blog post is to delve into the code details and explore how its basic ideas are implemented. We will first outline the role of each module from the project's structure, then investigate the entire distributed transaction implementation process using the official examples."}),"\n",(0,a.jsx)(n.h1,{id:"project-structure-analysis",children:"Project Structure Analysis"}),"\n",(0,a.jsx)(n.p,{children:"After pulling the project and opening it with an IDE, the directory structure is as follows. Let's take a look at the implementation of each module:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(21972).A+"",width:"705",height:"363"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"common: Common components, providing commonly used utility classes, static variables, extension mechanism class loaders, and defining global exceptions, etc."}),"\n",(0,a.jsx)(n.li,{children:"config: Configuration loading and parsing module, providing basic interfaces for configuration. Currently, only file configuration is implemented, with plans for implementations of configuration centers like Nacos."}),"\n",(0,a.jsx)(n.li,{children:"core: The core module mainly encapsulating RPC-related content for communication between TM, RM, and TC."}),"\n",(0,a.jsx)(n.li,{children:"dubbo: The Dubbo module mainly adapts the Dubbo communication framework, using Dubbo's filter mechanism to pass global transaction information to branches."}),"\n",(0,a.jsx)(n.li,{children:"examples: A simple example module that we will explore to understand the implementation."}),"\n",(0,a.jsx)(n.li,{children:'rm-datasource: The resource management module, a core module that proxies some JDBC classes to parse SQL, generate rollback logs, and coordinate local transactions. Personally, I think naming this module "core" would be more appropriate.'}),"\n",(0,a.jsx)(n.li,{children:"server: The TC component, mainly coordinating and managing global transactions, responsible for committing or rolling back global transactions, and maintaining global locks."}),"\n",(0,a.jsx)(n.li,{children:"spring: The module integrated with Spring, mainly consisting of AOP logic, serving as the entry point for the entire distributed transaction, and the breakthrough point for studying Fescar."}),"\n",(0,a.jsx)(n.li,{children:"tm: The global transaction management module, managing the boundaries of global transactions, and controlling the initiation and rollback points of global transactions."}),"\n"]}),"\n",(0,a.jsx)(n.h1,{id:"viewing-the-effects-through-the-examples-module",children:"Viewing the Effects through the [examples] Module"}),"\n",(0,a.jsx)(n.p,{children:"First, start the TC (Server) module, and start the main method directly. The default server port is 8091."}),"\n",(0,a.jsx)(n.p,{children:"Second, go to the examples module and configure the configuration files for the order, business, account, and storage services, mainly the MySQL data source and Zookeeper connection address. Note that the default Dubbo Zookeeper registry dependency is missing, and starting it will throw a class not found exception. Add the following dependency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>com.101tec</groupId>\n    <artifactId>zkclient</artifactId>\n    <version>0.10</version>\n    <exclusions>\n        <exclusion>\n            <artifactId>slf4j-log4j12</artifactId>\n            <groupId>org.slf4j</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Third, place a breakpoint at the simulated exception in BusinessServiceImpl. Start OrderServiceImpl, StorageServiceImpl, AccountServiceImpl, and BusinessServiceImpl services one by one. After hitting the breakpoint, check the account_tbl table in the database; the amount has been reduced by 400 yuan, to 599 yuan. Then, release the breakpoint to trigger the simulated exception in the BusinessServiceImpl module. The global transaction rolls back, and the account_tbl table amount returns to 999 yuan."}),"\n",(0,a.jsx)(n.p,{children:"As shown above, we have experienced the control capability of Fescar transactions. Next, let's look at how it controls transactions in detail."}),"\n",(0,a.jsx)(n.h1,{id:"analysis-of-fescar-transaction-process",children:"Analysis of Fescar Transaction Process"}),"\n",(0,a.jsx)(n.h2,{id:"first-analyze-the-configuration-file",children:"First, Analyze the Configuration File"}),"\n",(0,a.jsx)(n.p,{children:"This is a golden rule: to integrate any technology or framework, the configuration file is definitely a breakthrough point. From the above example, we learned that the configuration file in the example module configured an instance of a global transaction scanner, as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<bean class="com.alibaba.fescar.spring.annotation.GlobalTransactionScanner">\n    <constructor-arg value="dubbo-demo-app"/>\n    <constructor-arg value="my_test_tx_group"/>\n</bean>\n'})}),"\n",(0,a.jsx)(n.p,{children:"This instance scans all instances when the project starts. The specific implementation can be found in the [spring] module, and methods marked with the @GlobalTransactional annotation are woven into the logic of GlobalTransactionalInterceptor's invoke method. When the application starts, instances of TM (TmRpcClient) and RM (RmRpcClient) are initialized, connecting the service with the TC (Transaction Coordinator). Going further involves the TransactionalTemplate class in the TM module."}),"\n",(0,a.jsx)(n.h2,{id:"tm-module-starts-global-transactions",children:"[TM] Module Starts Global Transactions"}),"\n",(0,a.jsx)(n.p,{children:"The opening, committing, and rolling back of global transactions are encapsulated in the TransactionalTemplate. The code is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"\npublic Object execute(TransactionalExecutor business) throws TransactionalExecutor.ExecutionException {\n    // 1. get or create a transaction\n    GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();\n    // 2. begin transaction\n    try {\n        tx.begin(business.timeout(), business.name());\n    } catch (TransactionException txe) {\n        throw new TransactionalExecutor.ExecutionException(tx, txe,\n            TransactionalExecutor.Code.BeginFailure);\n    }\n    Object rs = null;\n    try {\n        // Do Your Business\n        rs = business.execute();\n    } catch (Throwable ex) {\n        // 3. any business exception, rollback.\n        try {\n            tx.rollback();\n            // 3.1 Successfully rolled back\n            throw new TransactionalExecutor.ExecutionException(tx, TransactionalExecutor.Code.RollbackDone, ex);\n        } catch (TransactionException txe) {\n            // 3.2 Failed to rollback\n            throw new TransactionalExecutor.ExecutionException(tx, txe,\n                TransactionalExecutor.Code.RollbackFailure, ex);\n        }\n    }\n    // 4. everything is fine, commit.\n    try {\n        tx.commit();\n    } catch (TransactionException txe) {\n        // 4.1 Failed to commit\n        throw new TransactionalExecutor.ExecutionException(tx, txe,\n            TransactionalExecutor.Code.CommitFailure);\n    }\n    return rs;\n}\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"The more detailed implementation in the [TM] module is divided into two classes, as follows:"}),"\n",(0,a.jsx)(n.p,{children:"DefaultGlobalTransaction: Responsible for the specific actions of starting, committing, and rolling back global transactions."}),"\n",(0,a.jsx)(n.p,{children:"DefaultTransactionManager: Responsible for using TmRpcClient to send commands to the TC control center, such as starting a global transaction (GlobalBeginRequest), committing (GlobalCommitRequest), rolling back (GlobalRollbackRequest), and querying status (GlobalStatusRequest)."}),"\n",(0,a.jsx)(n.p,{children:"The above are the core contents of the TM module. After the TM module completes the global transaction start, we then look at how the global transaction ID, xid, is passed and how the RM component intervenes."}),"\n",(0,a.jsx)(n.h2,{id:"passing-global-transaction-xid-with-dubbo",children:"Passing Global Transaction xid with [dubbo]"}),"\n",(0,a.jsx)(n.p,{children:"First is the transmission of xid. Currently, the transmission in a microservice architecture implemented with the Dubbo framework has been realized. It is also easy to implement for others like Spring Cloud and Motan. By using the filter mechanism that general RPC communication frameworks have, xid is passed from the initiating node of the global transaction to the service's subordinate nodes. After being received by the subordinate nodes, it is bound to the current thread context environment to determine whether to join the global transaction when the branch transaction executes SQL. Fescar's implementation can be seen in the [dubbo] module as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Activate(group = { Constants.PROVIDER, Constants.CONSUMER }, order = 100)\npublic class TransactionPropagationFilter implements Filter {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionPropagationFilter.class);\n\n    @Override\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n        String xid = RootContext.getXID();\n        String rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug("xid in RootContext\\[" + xid + "\\] xid in RpcContext\\[" + rpcXid + "\\]");\n        }\n        boolean bind = false;\n        if (xid != null) {\n            RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);\n        } else {\n            if (rpcXid != null) {\n                RootContext.bind(rpcXid);\n                bind = true;\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug("bind\\[" + rpcXid + "\\] to RootContext");\n                }\n            }\n        }\n        try {\n            return invoker.invoke(invocation);\n\n        } finally {\n            if (bind) {\n                String unbindXid = RootContext.unbind();\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug("unbind\\[" + unbindXid + "\\] from RootContext");\n                }\n                if (!rpcXid.equalsIgnoreCase(unbindXid)) {\n                    LOGGER.warn("xid in change during RPC from " + rpcXid + " to " + unbindXid);\n                    if (unbindXid != null) {\n                        RootContext.bind(unbindXid);\n                        LOGGER.warn("bind \\[" + unbindXid + "\\] back to RootContext");\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"When rpcXid is not null, it is added to the ContextCore of RootContext. Let's delve into this a bit. ContextCore is an extensible interface, and the default implementation is ThreadLocalContextCore, which maintains the current xid based on ThreadLocal. Fescar provides an extensible mechanism implemented in the [common] module. Through a custom class loader, EnhancedServiceLoader, it loads the service classes that need to be extended. By adding the @LoadLevel annotation with a high order attribute to the extension class, the purpose of extension implementation can be achieved."}),"\n",(0,a.jsx)(n.h2,{id:"intervention-of-local-resource-management-in-the-rm-module",children:"Intervention of Local Resource Management in the [RM] Module"}),"\n",(0,a.jsx)(n.p,{children:"Fescar implements proxy classes for local transaction-related interfaces through a proxy mechanism, such as DataSourceProxy, ConnectionProxy, and StatementProxy. This can be seen in the configuration file, indicating that to use Fescar distributed transactions, the proxy data source provided by Fescar must be configured. For example:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(45169).A+"",width:"960",height:"382"})}),"\n",(0,a.jsx)(n.p,{children:"After configuring the proxy data source, starting from DataSourceProxy, we can freely control all local operations on the database. From the xid transmission above, we know that the xid is saved in RootContext. Now, look at the following code to see it clearly:"}),"\n",(0,a.jsx)(n.p,{children:"First, look at a piece of code from StatementProxy:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(96709).A+"",width:"916",height:"512"})}),"\n",(0,a.jsx)(n.p,{children:"Then, look at the code in ExecuteTemplate:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(22776).A+"",width:"960",height:"625"})}),"\n",(0,a.jsx)(n.p,{children:"Similar to the transaction management template class TransactionalTemplate in the [TM] module, the crucial logic proxy here is encapsulated in the ExecuteTemplate template class. By overriding Statement with StatementProxy implementation, the execute logic of ExecuteTemplate is called when the original JDBC executeUpdate method is executed. Before the SQL is actually executed, it checks whether the current context in RootContext contains xid, i.e., whether it is a global distributed transaction. If not, the local transaction is used directly. If it is, RM adds some distributed transaction-related logic. Fescar has encapsulated five different executors to handle different types of SQL, namely UpdateExecutor, DeleteExecutor, InsertExecutor, SelectForUpdateExecutor, and PlainExecutor. The structure is as follows:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(46390).A+"",width:"945",height:"419"})}),"\n",(0,a.jsx)(n.h3,{id:"plainexecutor",children:"PlainExecutor:"}),"\n",(0,a.jsx)(n.p,{children:"The native JDBC interface implementation, without any processing, is used for ordinary select queries in global transactions."}),"\n",(0,a.jsx)(n.h3,{id:"updateexecutor-deleteexecutor-insertexecutor",children:"UpdateExecutor, DeleteExecutor, InsertExecutor:"}),"\n",(0,a.jsx)(n.p,{children:"The three DML (Data Manipulation Language) executors for updating, deleting, and inserting, mainly analyze the SQL statements before and after execution and implement the following two abstract interface methods:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"protected abstract TableRecords beforeImage() throws SQLException;\n\nprotected abstract TableRecords afterImage(TableRecords beforeImage) throws SQLException;\n"})}),"\n",(0,a.jsx)(n.p,{children:"During this process, the undo_log for rollback operation is generated by analyzing the SQL, and the log is currently saved in MySQL, sharing the same transaction with the business SQL operation. The table structure is as follows:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(43259).A+"",width:"731",height:"332"})}),"\n",(0,a.jsx)(n.p,{children:"The rollback_info column contains the detailed information of the undo_log, which is of type longblob. The structure is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n\xa0\xa0\xa0\xa0"branchId":3958194,\n\xa0\xa0\xa0\xa0"sqlUndoLogs":[\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"afterImage":{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"rows":[\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"fields":[\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"keyType":"PrimaryKey",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"name":"ID",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"type":4,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"value":10\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0},\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"keyType":"NULL",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"name":"COUNT",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"type":4,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"value":98\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0]\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0],\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"tableName":"storage_tbl"\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0},\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"beforeImage":{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"rows":[\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"fields":[\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"keyType":"PrimaryKey",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"name":"ID",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"type":4,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"value":10\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0},\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"keyType":"NULL",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"name":"COUNT",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"type":4,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"value":100\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0]\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0],\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"tableName":"storage_tbl"\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0},\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"sqlType":"UPDATE",\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"tableName":"storage_tbl"\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0],\n\xa0\xa0\xa0\xa0"xid":"192.168.7.77:8091:3958193"\n}\n\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"Here is an example of an update operation. The undo_log records very detailed information. It associates the branch ID with the global transaction xid, records the table name, the operation field names, and the records before and after the SQL execution. For instance, this record shows table name = storage_tbl, before SQL execution ID = 10, count = 100, after SQL execution ID = 10, count = 98. If the entire global transaction fails and needs to be rolled back, it can generate the following rollback SQL statement:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"update storage_tbl set count = 100 where id = 10;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"selectforupdateexecutor",children:"SelectForUpdateExecutor:"}),"\n",(0,a.jsx)(n.p,{children:"In Fescar's AT mode, the default isolation level above the local transaction is read uncommitted. However, through the SelectForUpdateExecutor, it can support the read committed isolation level. The code is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Override\npublic Object doExecute(Object... args) throws Throwable {\n    SQLSelectRecognizer recognizer = (SQLSelectRecognizer) sqlRecognizer;\n\n    Connection conn = statementProxy.getConnection();\n    ResultSet rs = null;\n    Savepoint sp = null;\n    LockRetryController lockRetryController = new LockRetryController();\n    boolean originalAutoCommit = conn.getAutoCommit();\n\n    StringBuffer selectSQLAppender = new StringBuffer("SELECT ");\n    selectSQLAppender.append(getTableMeta().getPkName());\n    selectSQLAppender.append(" FROM " + getTableMeta().getTableName());\n    String whereCondition = null;\n    ArrayList<Object> paramAppender = new ArrayList<>();\n    if (statementProxy instanceof ParametersHolder) {\n        whereCondition = recognizer.getWhereCondition((ParametersHolder) statementProxy, paramAppender);\n    } else {\n        whereCondition = recognizer.getWhereCondition();\n    }\n    if (!StringUtils.isEmpty(whereCondition)) {\n        selectSQLAppender.append(" WHERE " + whereCondition);\n    }\n    selectSQLAppender.append(" FOR UPDATE");\n    String selectPKSQL = selectSQLAppender.toString();\n\n    try {\n        if (originalAutoCommit) {\n            conn.setAutoCommit(false);\n        }\n        sp = conn.setSavepoint();\n        rs = statementCallback.execute(statementProxy.getTargetStatement(), args);\n\n        while (true) {\n            // Try to get global lock of those rows selected\n            Statement stPK = null;\n            PreparedStatement pstPK = null;\n            ResultSet rsPK = null;\n            try {\n                if (paramAppender.isEmpty()) {\n                    stPK = statementProxy.getConnection().createStatement();\n                    rsPK = stPK.executeQuery(selectPKSQL);\n                } else {\n                    pstPK = statementProxy.getConnection().prepareStatement(selectPKSQL);\n                    for (int i = 0; i < paramAppender.size(); i++) {\n                        pstPK.setObject(i + 1, paramAppender.get(i));\n                    }\n                    rsPK = pstPK.executeQuery();\n                }\n\n                TableRecords selectPKRows = TableRecords.buildRecords(getTableMeta(), rsPK);\n                statementProxy.getConnectionProxy().checkLock(selectPKRows);\n                break;\n\n            } catch (LockConflictException lce) {\n                conn.rollback(sp);\n                lockRetryController.sleep(lce);\n\n            } finally {\n                if (rsPK != null) {\n                    rsPK.close();\n                }\n                if (stPK != null) {\n                    stPK.close();\n                }\n                if (pstPK != null) {\n                    pstPK.close();\n                }\n            }\n        }\n\n    } finally {\n        if (sp != null) {\n            conn.releaseSavepoint(sp);\n        }\n        if (originalAutoCommit) {\n            conn.setAutoCommit(true);\n        }\n    }\n    return rs;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The key code is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"TableRecords selectPKRows = TableRecords.buildRecords(getTableMeta(), rsPK);\nstatementProxy.getConnectionProxy().checkLock(selectPKRows);\n"})}),"\n",(0,a.jsx)(n.p,{children:"By operating on the selectPKRows table records, lockKeys are obtained, and then it checks with the TC controller to see if they are globally locked. If they are locked, it retries until the lock is released and then returns the query result."}),"\n",(0,a.jsx)(n.h2,{id:"registration-and-reporting-of-branch-transactions",children:"Registration and Reporting of Branch Transactions"}),"\n",(0,a.jsx)(n.p,{children:"Before the local transaction is committed, Fescar registers and reports information related to the branch transaction. This can be seen in the commit part of the ConnectionProxy class code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Override\npublic void commit() throws SQLException {\n    if (context.inGlobalTransaction()) {\n        try {\n            register();\n        } catch (TransactionException e) {\n            recognizeLockKeyConflictException(e);\n        }\n\n        try {\n            if (context.hasUndoLog()) {\n                UndoLogManager.flushUndoLogs(this);\n            }\n            targetConnection.commit();\n        } catch (Throwable ex) {\n            report(false);\n            if (ex instanceof SQLException) {\n                throw (SQLException) ex;\n            } else {\n                throw new SQLException(ex);\n            }\n        }\n        report(true);\n        context.reset();\n\n    } else {\n        targetConnection.commit();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"From this code, we can see that it first checks whether it is a global transaction. If it is not, it commits directly. If it is, it first registers the branch transaction with the TC controller. For write isolation, it involves obtaining global locks on the TC side. Then, it saves the undo_log used for rollback operations and finally commits the local transaction. Lastly, it reports the transaction status to the TC controller. At this point, the first phase of the local transaction is complete."}),"\n",(0,a.jsx)(n.h2,{id:"coordinating-the-global-transaction-with-the-server-module",children:"Coordinating the Global Transaction with the [server] Module"}),"\n",(0,a.jsx)(n.p,{children:"For the server module, we can focus on the DefaultCoordinator class. This is the default implementation of the AbstractTCInboundHandler controller handler. It mainly implements interfaces for starting, committing, rolling back, querying the status of global transactions, registering branch transactions, reporting, and checking locks, such as:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(83910).A+"",width:"756",height:"426"})}),"\n",(0,a.jsx)(n.p,{children:"Returning to the TransactionalTemplate at the beginning, if the entire distributed transaction fails and needs to be rolled back, TM first initiates a rollback instruction to TC. After TC receives it and parses the request, it is routed to the doGlobalRollback method of the default controller class. The code executed on the TC controller side is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Override\npublic void doGlobalRollback(GlobalSession globalSession, boolean retrying) throws TransactionException {\n    for (BranchSession branchSession : globalSession.getReverseSortedBranches()) {\n        BranchStatus currentBranchStatus = branchSession.getStatus();\n        if (currentBranchStatus == BranchStatus.PhaseOne_Failed) {\n            continue;\n        }\n        try {\n            BranchStatus branchStatus = resourceManagerInbound.branchRollback(XID.generateXID(branchSession.getTransactionId()), branchSession.getBranchId(),\n                    branchSession.getResourceId(), branchSession.getApplicationData());\n\n            switch (branchStatus) {\n                case PhaseTwo_Rollbacked:\n                    globalSession.removeBranch(branchSession);\n                    LOGGER.error("Successfully rolled back branch " + branchSession);\n                    continue;\n                case PhaseTwo\\_RollbackFailed\\_Unretryable:\n                    GlobalStatus currentStatus = globalSession.getStatus();\n                    if (currentStatus.name().startsWith("Timeout")) {\n                        globalSession.changeStatus(GlobalStatus.TimeoutRollbackFailed);\n                    } else {\n                        globalSession.changeStatus(GlobalStatus.RollbackFailed);\n                    }\n                    globalSession.end();\n                    LOGGER.error("Failed to rollback global\\[" + globalSession.getTransactionId() + "\\] since branch\\[" + branchSession.getBranchId() + "\\] rollback failed");\n                    return;\n                default:\n                    LOGGER.info("Failed to rollback branch " + branchSession);\n                    if (!retrying) {\n                        queueToRetryRollback(globalSession);\n                    }\n                    return;\n\n            }\n        } catch (Exception ex) {\n            LOGGER.info("Exception rollbacking branch " + branchSession, ex);\n            if (!retrying) {\n                queueToRetryRollback(globalSession);\n                if (ex instanceof TransactionException) {\n                    throw (TransactionException) ex;\n                } else {\n                    throw new TransactionException(ex);\n                }\n            }\n\n        }\n\n    }\n    GlobalStatus currentStatus = globalSession.getStatus();\n    if (currentStatus.name().startsWith("Timeout")) {\n        globalSession.changeStatus(GlobalStatus.TimeoutRollbacked);\n    } else {\n        globalSession.changeStatus(GlobalStatus.Rollbacked);\n    }\n    globalSession.end();\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"As seen from the above code, during rollback, each branch transaction is iterated from the global transaction session, and then each branch transaction is notified to rollback. When the branch service receives the request, it is first routed to the doBranchRollback method in RMHandlerAT, and then the branchRollback method in RM is called. The code is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Override\npublic BranchStatus branchRollback(String xid, long branchId, String resourceId, String applicationData) throws TransactionException {\n    DataSourceProxy dataSourceProxy = get(resourceId);\n    if (dataSourceProxy == null) {\n        throw new ShouldNeverHappenException();\n    }\n    try {\n        UndoLogManager.undo(dataSourceProxy, xid, branchId);\n    } catch (TransactionException te) {\n        if (te.getCode() == TransactionExceptionCode.BranchRollbackFailed_Unretriable) {\n            return BranchStatus.PhaseTwo_RollbackFailed_Unretryable;\n        } else {\n            return BranchStatus.PhaseTwo_RollbackFailed_Retryable;\n        }\n    }\n    return BranchStatus.PhaseTwo_Rollbacked;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"On the RM branch transaction side, the UndoLogManager's undo method is ultimately executed. It retrieves the rollback log from the database using xid and branchId to complete the data rollback operation. The entire process is completed synchronously. If the global transaction is successful, TC will have a similar coordination process as mentioned above, but it will be asynchronous, clearing the undo_log related to the global transaction. At this point, the two-phase commit or rollback is completed, thus achieving complete control of the global transaction."}),"\n",(0,a.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"If you've made it this far, thank you very much for patiently taking the time to learn amidst your busy schedule. I believe the time spent was worthwhile. By thoroughly reading and understanding this article, you likely have a comprehensive understanding of the main flow of Fescar's implementation. This article took approximately one person-day from conception to completion. During this process, I also gained a deeper understanding of Fescar's implementation. Due to space constraints, I did not delve into every detail of the implementation, such as how SQL parsing is done, but instead focused on the key points of the implementation process of Fescar's TXC model. This article has been proofread, but due to personal knowledge limitations and finite energy, errors or misunderstandings may inevitably occur. Corrections are welcome."}),"\n",(0,a.jsx)(n.h3,{id:"about-the-author",children:"About the Author:"}),"\n",(0,a.jsxs)(n.p,{children:["Chen Kailing joined Kaijing Technology in May 2016. Formerly a senior developer and project manager, currently the head of the Architecture & Operations Department of Kaijing Technology's R&D Center. PMP project management certification, Alibaba Cloud MVP. Enthusiastic about open source, having open-sourced several popular projects. Passionate about sharing technical insights, and author of the independent blog KL Blog (",(0,a.jsx)(n.a,{href:"http://www.kailing.pub/",children:"http://www.kailing.pub"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},22776:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/04488a2745a5d564498462ed64c506174d2-f982f1865728c70f4e9dc802a6f70c54.jpg"},96709:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/17896deea47b9aee518812b039c39101d8f-17aee47c7b0181e494847cd605377176.jpg"},83910:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/3da6fd82debb9470eb4a5feb1eecac6d6a2-b042b32322c41b9cbe7563f9ccfdcf87.jpg"},21972:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/a88cf147f489f913886ef1785d94183bf09-675292f77733fca39c09b525924847ad.jpg"},45169:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/af317255c71a5c1bf46f7140387acf365f8-89383a2f18f6ee0c38517552ef7c838b.jpg"},46390:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/bb9a2f07054f19bc21adc332671de4f7b75-0b10f570ec26e2246b4d02e607fb42f9.jpg"},37814:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/c45496461bca15ecd522e497d98ba954f95-4483e7e2aab41db92fd1ee606abf0cf5.jpg"},43259:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/fd5c423815d3b84bdbc70d7efeb9cd16757-8fed493519894148d20b0102af49138a.jpg"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);
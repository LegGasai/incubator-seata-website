<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Seata、TCC、幂等、悬挂、空回滚" />
	<meta name="description" content="Seata 在 1.5.1 版本解决了 TCC 模式的幂等、悬挂和空回滚问题，这篇文章主要讲解 Seata 是怎么解决的。" />
	<meta name="aes-config" content="pid=xux-opensource&user_type=101&uid=&username=&dim10=seata"/>

	<!-- 网页标签标题 -->
	<title>阿里 Seata 新版本终于解决了 TCC 模式的幂等、悬挂和空回滚问题</title>
  <link rel="shortcut icon" href="/img/seata_logo_small.jpeg"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="//img.alicdn.com/tfs/TB1gqL1w4D1gK0jSZFyXXciOVXa-1497-401.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="https://img.alicdn.com/tfs/TB14eEmw7P2gK0jSZPxXXacQpXa-38-32.png"/><ul><li class="menu-item menu-item-normal"><span><a href="/zh-cn/index.html">首页</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/docs/overview/what-is-seata.html">文档</a></span></li><li class="menu-item menu-item-normal"><span><a href="https://cn.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0">Seata企业版</a><img class="menu-img" src="https://img.alicdn.com/imgextra/i4/O1CN01iksJGI1TOscjbXlOD_!!6000000002373-2-tps-30-30.png"/></span></li><li class="menu-item menu-item-normal"><div class="nav-container"><div class="word"><a>解决方案</a><img class="menu-img" src="https://img.alicdn.com/tfs/TB1esl_m.T1gK0jSZFrXXcNCXXa-200-200.png"/></div><ul class="sub-nav-container" style="width:220px"><li><a href="https://cn.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0" target="_blank">分布式事务解决方案</a></li><li><a href="https://cn.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0" target="_blank">微服务解决方案</a></li><li><a href="https://www.aliyun.com/product/ahas?spm=seata-website.topbar.0.0.0" target="_blank">高可用解决方案</a></li><li><a href="https://cn.aliyun.com/product/aliware/sae?spm=seata-website.topbar.0.0.0" target="_blank">微服务Serverless解决方案</a></li><li><a href="https://www.aliyun.com/product/edas?spm=seata-website.topbar.0.0.0" target="_blank">PaaS解决方案</a></li><li><a href="https://www.aliyun.com/product/servicemesh?spm=seata-website.topbar.0.0.0" target="_blank">服务网格解决方案</a></li></ul> </div></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></span></li><li class="menu-item menu-item-normal"><span><a href="https://mp.weixin.qq.com/s/q6J-swbdWqZebuSiq2JDWg">开源之夏2022</a></span></li><li class="menu-item menu-item-normal menu-item-normal-active"><span><a href="/zh-cn/blog/index.html">博客</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/community/index.html">社区</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/blog/download.html">下载</a></span></li></ul></div></div></header><section class="blog-content markdown-body"><p>今天来聊一聊阿里巴巴 Seata 新版本（1.5.1）是怎么解决 TCC 模式下的幂等、悬挂和空回滚问题的。</p>
<h2>1 TCC 回顾</h2>
<p>TCC 模式是最经典的分布式事务解决方案，它将分布式事务分为两个阶段来执行，try 阶段对每个分支事务进行预留资源，如果所有分支事务都预留资源成功，则进入 commit 阶段提交全局事务，如果有一个节点预留资源失败则进入 cancel 阶段回滚全局事务。</p>
<p>以传统的订单、库存、账户服务为例，在 try 阶段尝试预留资源，插入订单、扣减库存、扣减金额，这三个服务都是要提交本地事务的，这里可以把资源转入中间表。在 commit 阶段，再把 try 阶段预留的资源转入最终表。而在 cancel 阶段，把 try 阶段预留的资源进行释放，比如把账户金额返回给客户的账户。</p>
<p><strong>注意：try 阶段必须是要提交本地事务的，比如扣减订单金额，必须把钱从客户账户扣掉，如果不扣掉，在 commit 阶段客户账户钱不够了，就会出问题。</strong></p>
<h3>1.1 try-commit</h3>
<p>try 阶段首先进行预留资源，然后在 commit 阶段扣除资源。如下图：</p>
<p><img src="/img/blog/fence-try-commit.png" alt="fence-try-commit"></p>
<h3>1.2 try-cancel</h3>
<p>try 阶段首先进行预留资源，预留资源时扣减库存失败导致全局事务回滚，在 cancel 阶段释放资源。如下图：</p>
<p><img src="/img/blog/fence-try-cancel.png" alt="fence-try-cancel"></p>
<h2>2 TCC 优势</h2>
<p>TCC 模式最大的优势是效率高。TCC 模式在 try 阶段的锁定资源并不是真正意义上的锁定，而是真实提交了本地事务，将资源预留到中间态，并不需要阻塞等待，因此效率比其他模式要高。</p>
<p>同时 TCC 模式还可以进行如下优化：</p>
<h3>2.1 异步提交</h3>
<p>try 阶段成功后，不立即进入 confirm/cancel 阶段，而是认为全局事务已经结束了，启动定时任务来异步执行 confirm/cancel，扣减或释放资源，这样会有很大的性能提升。</p>
<h3>2.2 同库模式</h3>
<p>TCC 模式中有三个角色：</p>
<ul>
<li>TM：管理全局事务，包括开启全局事务，提交/回滚全局事务；</li>
<li>RM：管理分支事务；</li>
<li>TC: 管理全局事务和分支事务的状态。</li>
</ul>
<p>下图来自 Seata 官网：</p>
<p><img src="/img/blog/fence-fiffrent-db.png" alt="fence-fiffrent-db"></p>
<p>TM 开启全局事务时，RM 需要向 TC 发送注册消息，TC 保存分支事务的状态。TM 请求提交或回滚时，TC 需要向 RM 发送提交或回滚消息。这样包含两个个分支事务的分布式事务中，TC 和 RM 之间有四次 RPC。</p>
<p>优化后的流程如下图：</p>
<p><img src="/img/blog/fence-same-db.png" alt="fence-same-db"></p>
<p>TC 保存全局事务的状态。TM 开启全局事务时，RM 不再需要向 TC 发送注册消息，而是把分支事务状态保存在了本地。TM 向 TC 发送提交或回滚消息后，RM 异步线程首先查出本地保存的未提交分支事务，然后向 TC 发送消息获取（本地分支事务）所在的全局事务状态，以决定是提交还是回滚本地事务。</p>
<p>这样优化后，RPC 次数减少了 50%，性能大幅提升。</p>
<h2>3 RM 代码示例</h2>
<p>以库存服务为例，RM 库存服务接口代码如下：</p>
<pre><code class="language-Java"><span class="hljs-meta">@LocalTCC</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageService</span> </span>{

    <span class="hljs-comment">/**
     * 扣减库存
     * <span class="hljs-doctag">@param</span> xid 全局xid
     * <span class="hljs-doctag">@param</span> productId 产品id
     * <span class="hljs-doctag">@param</span> count 数量
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@TwoPhaseBusinessAction</span>(name = <span class="hljs-string">"storageApi"</span>, commitMethod = <span class="hljs-string">"commit"</span>, rollbackMethod = <span class="hljs-string">"rollback"</span>, useTCCFence = <span class="hljs-keyword">true</span>)
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">decrease</span><span class="hljs-params">(String xid, Long productId, Integer count)</span></span>;

    <span class="hljs-comment">/**
     * 提交事务
     * <span class="hljs-doctag">@param</span> actionContext
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;

    <span class="hljs-comment">/**
     * 回滚事务
     * <span class="hljs-doctag">@param</span> actionContext
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;
}
</code></pre>
<p>通过 @LocalTCC 这个注解，RM 初始化的时候会向 TC 注册一个分支事务。在 try 阶段的方法（decrease方法）上有一个 @TwoPhaseBusinessAction 注解，这里定义了分支事务的 resourceId，commit 方法和 cancel 方法，useTCCFence 这个属性下一节再讲。</p>
<h2>4 TCC 存在问题</h2>
<p>TCC 模式中存在的三大问题是幂等、悬挂和空回滚。在 Seata1.5.1 版本中，增加了一张事务控制表，表名是 tcc_fence_log 来解决这个问题。而在上一节 @TwoPhaseBusinessAction 注解中提到的属性 useTCCFence 就是来指定是否开启这个机制，这个属性值默认是 false。</p>
<p>tcc_fence_log 建表语句如下（MySQL 语法）：</p>
<pre><code class="language-SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`tcc_fence_log`</span>
(
    <span class="hljs-string">`xid`</span>           <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'global id'</span>,
    <span class="hljs-string">`branch_id`</span>     <span class="hljs-built_in">BIGINT</span>        <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'branch id'</span>,
    <span class="hljs-string">`action_name`</span>   <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">64</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'action name'</span>,
    <span class="hljs-string">`status`</span>        <span class="hljs-built_in">TINYINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'status(tried:1;committed:2;rollbacked:3;suspended:4)'</span>,
    <span class="hljs-string">`gmt_create`</span>    DATETIME(<span class="hljs-number">3</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'create time'</span>,
    <span class="hljs-string">`gmt_modified`</span>  DATETIME(<span class="hljs-number">3</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'update time'</span>,
    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`xid`</span>, <span class="hljs-string">`branch_id`</span>),
    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_gmt_modified`</span> (<span class="hljs-string">`gmt_modified`</span>),
    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_status`</span> (<span class="hljs-string">`status`</span>)
) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>
<span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8mb4;
</code></pre>
<h3>4.1 幂等</h3>
<p>在 commit/cancel 阶段，因为 TC 没有收到分支事务的响应，需要进行重试，这就要分支事务支持幂等。</p>
<p>我们看一下新版本是怎么解决的。下面的代码在 TCCResourceManager 类：</p>
<pre><code class="language-Java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> BranchStatus <span class="hljs-title">branchCommit</span><span class="hljs-params">(BranchType branchType, String xid, <span class="hljs-keyword">long</span> branchId, String resourceId,
								 String applicationData)</span> <span class="hljs-keyword">throws</span> TransactionException </span>{
	TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);
	<span class="hljs-comment">//省略判断</span>
	Object targetTCCBean = tccResource.getTargetBean();
	Method commitMethod = tccResource.getCommitMethod();
	<span class="hljs-comment">//省略判断</span>
	<span class="hljs-keyword">try</span> {
		<span class="hljs-comment">//BusinessActionContext</span>
		BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,
			applicationData);
		Object[] args = <span class="hljs-keyword">this</span>.getTwoPhaseCommitArgs(tccResource, businessActionContext);
		Object ret;
		<span class="hljs-keyword">boolean</span> result;
		<span class="hljs-comment">//注解 useTCCFence 属性是否设置为 true</span>
		<span class="hljs-keyword">if</span> (Boolean.TRUE.equals(businessActionContext.getActionContext(Constants.USE_TCC_FENCE))) {
			<span class="hljs-keyword">try</span> {
				result = TCCFenceHandler.commitFence(commitMethod, targetTCCBean, xid, branchId, args);
			} <span class="hljs-keyword">catch</span> (SkipCallbackWrapperException | UndeclaredThrowableException e) {
				<span class="hljs-keyword">throw</span> e.getCause();
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">//省略逻辑</span>
		}
		LOGGER.info(<span class="hljs-string">"TCC resource commit result : {}, xid: {}, branchId: {}, resourceId: {}"</span>, result, xid, branchId, resourceId);
		<span class="hljs-keyword">return</span> result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;
	} <span class="hljs-keyword">catch</span> (Throwable t) {
		<span class="hljs-comment">//省略</span>
		<span class="hljs-keyword">return</span> BranchStatus.PhaseTwo_CommitFailed_Retryable;
	}
}
</code></pre>
<p>上面的代码可以看到，执行分支事务提交方法时，首先判断 useTCCFence 属性是否为 true，如果为 true，则走 TCCFenceHandler 类中的 commitFence 逻辑，否则走普通提交逻辑。</p>
<p>TCCFenceHandler 类中的 commitFence 方法调用了 TCCFenceHandler 类的 commitFence 方法，代码如下：</p>
<pre><code class="language-Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commitFence</span><span class="hljs-params">(Method commitMethod, Object targetTCCBean,
								  String xid, Long branchId, Object[] args)</span> </span>{
	<span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
		<span class="hljs-keyword">try</span> {
			Connection conn = DataSourceUtils.getConnection(dataSource);
			TCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);
			<span class="hljs-keyword">if</span> (tccFenceDO == <span class="hljs-keyword">null</span>) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TCCFenceException(String.format(<span class="hljs-string">"TCC fence record not exists, commit fence method failed. xid= %s, branchId= %s"</span>, xid, branchId),
						FrameworkErrorCode.RecordAlreadyExists);
			}
			<span class="hljs-keyword">if</span> (TCCFenceConstant.STATUS_COMMITTED == tccFenceDO.getStatus()) {
				LOGGER.info(<span class="hljs-string">"Branch transaction has already committed before. idempotency rejected. xid: {}, branchId: {}, status: {}"</span>, xid, branchId, tccFenceDO.getStatus());
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
			}
			<span class="hljs-keyword">if</span> (TCCFenceConstant.STATUS_ROLLBACKED == tccFenceDO.getStatus() || TCCFenceConstant.STATUS_SUSPENDED == tccFenceDO.getStatus()) {
				<span class="hljs-keyword">if</span> (LOGGER.isWarnEnabled()) {
					LOGGER.warn(<span class="hljs-string">"Branch transaction status is unexpected. xid: {}, branchId: {}, status: {}"</span>, xid, branchId, tccFenceDO.getStatus());
				}
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
			}
			<span class="hljs-keyword">return</span> updateStatusAndInvokeTargetMethod(conn, commitMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_COMMITTED, status, args);
		} <span class="hljs-keyword">catch</span> (Throwable t) {
			status.setRollbackOnly();
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SkipCallbackWrapperException(t);
		}
	});
}
</code></pre>
<p>从代码中可以看到，提交事务时首先会判断 tcc_fence_log 表中是否已经有记录，如果有记录，则判断事务执行状态并返回。这样如果判断到事务的状态已经是 STATUS_COMMITTED，就不会再次提交，保证了幂等。如果 tcc_fence_log 表中没有记录，则插入一条记录，供后面重试时判断。</p>
<p>Rollback 的逻辑跟 commit 类似，逻辑在类 TCCFenceHandler 的 rollbackFence 方法。</p>
<h3>4.2 空回滚</h3>
<p>如下图，账户服务是两个节点的集群，在 try 阶段账户服务 1 这个节点发生了故障，try 阶段在不考虑重试的情况下，全局事务必须要走向结束状态，这样就需要在账户服务上执行一次 cancel 操作。</p>
<p><img src="/img/blog/fence-empty-rollback.png" alt="fence-empty-rollback"></p>
<p>Seata 的解决方案是在 try 阶段 往 tcc_fence_log  表插入一条记录，status 字段值是 STATUS_TRIED，在 Rollback 阶段判断记录是否存在，如果不存在，则不执行回滚操作。代码如下：</p>
<pre><code class="language-Java"><span class="hljs-comment">//TCCFenceHandler 类</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">prepareFence</span><span class="hljs-params">(String xid, Long branchId, String actionName, Callback&lt;Object&gt; targetCallback)</span> </span>{
	<span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
		<span class="hljs-keyword">try</span> {
			Connection conn = DataSourceUtils.getConnection(dataSource);
			<span class="hljs-keyword">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_TRIED);
			LOGGER.info(<span class="hljs-string">"TCC fence prepare result: {}. xid: {}, branchId: {}"</span>, result, xid, branchId);
			<span class="hljs-keyword">if</span> (result) {
				<span class="hljs-keyword">return</span> targetCallback.execute();
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TCCFenceException(String.format(<span class="hljs-string">"Insert tcc fence record error, prepare fence failed. xid= %s, branchId= %s"</span>, xid, branchId),
						FrameworkErrorCode.InsertRecordError);
			}
		} <span class="hljs-keyword">catch</span> (TCCFenceException e) {
			<span class="hljs-comment">//省略</span>
		} <span class="hljs-keyword">catch</span> (Throwable t) {
			<span class="hljs-comment">//省略</span>
		}
	});
}
</code></pre>
<p>在 Rollback 阶段的处理逻辑如下:</p>
<pre><code class="language-Java"><span class="hljs-comment">//TCCFenceHandler 类</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollbackFence</span><span class="hljs-params">(Method rollbackMethod, Object targetTCCBean,
									String xid, Long branchId, Object[] args, String actionName)</span> </span>{
	<span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
		<span class="hljs-keyword">try</span> {
			Connection conn = DataSourceUtils.getConnection(dataSource);
			TCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);
			<span class="hljs-comment">// non_rollback</span>
			<span class="hljs-keyword">if</span> (tccFenceDO == <span class="hljs-keyword">null</span>) {
				<span class="hljs-comment">//不执行回滚逻辑</span>
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span> (TCCFenceConstant.STATUS_ROLLBACKED == tccFenceDO.getStatus() || TCCFenceConstant.STATUS_SUSPENDED == tccFenceDO.getStatus()) {
					LOGGER.info(<span class="hljs-string">"Branch transaction had already rollbacked before, idempotency rejected. xid: {}, branchId: {}, status: {}"</span>, xid, branchId, tccFenceDO.getStatus());
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
				}
				<span class="hljs-keyword">if</span> (TCCFenceConstant.STATUS_COMMITTED == tccFenceDO.getStatus()) {
					<span class="hljs-keyword">if</span> (LOGGER.isWarnEnabled()) {
						LOGGER.warn(<span class="hljs-string">"Branch transaction status is unexpected. xid: {}, branchId: {}, status: {}"</span>, xid, branchId, tccFenceDO.getStatus());
					}
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
				}
			}
			<span class="hljs-keyword">return</span> updateStatusAndInvokeTargetMethod(conn, rollbackMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_ROLLBACKED, status, args);
		} <span class="hljs-keyword">catch</span> (Throwable t) {
			status.setRollbackOnly();
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SkipCallbackWrapperException(t);
		}
	});
}
</code></pre>
<p>updateStatusAndInvokeTargetMethod 方法执行的 sql 如下：</p>
<pre><code class="language-sql"><span class="hljs-keyword">update</span> tcc_fence_log <span class="hljs-keyword">set</span> <span class="hljs-keyword">status</span> = ?, gmt_modified = ?
    <span class="hljs-keyword">where</span> xid = ? <span class="hljs-keyword">and</span>  branch_id = ? <span class="hljs-keyword">and</span> <span class="hljs-keyword">status</span> = ? ;
</code></pre>
<p>可见就是把 tcc_fence_log 表记录的  status  字段值从 STATUS_TRIED 改为 STATUS_ROLLBACKED，如果更新成功，就执行回滚逻辑。</p>
<h3>4.3 悬挂</h3>
<p>悬挂是指因为网络问题，RM 开始没有收到 try 指令，但是执行了 Rollback 后 RM 又收到了 try 指令并且预留资源成功，这时全局事务已经结束，最终导致预留的资源不能释放。如下图：</p>
<p><img src="/img/blog/fence-suspend.png" alt="fence-suspend"></p>
<p>Seata 解决这个问题的方法是执行 Rollback 方法时先判断 tcc_fence_log 是否存在当前 xid 的记录，如果没有则向 tcc_fence_log 表插入一条记录，状态是 STATUS_SUSPENDED，并且不再执行回滚操作。代码如下：</p>
<pre><code class="language-Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollbackFence</span><span class="hljs-params">(Method rollbackMethod, Object targetTCCBean,
									String xid, Long branchId, Object[] args, String actionName)</span> </span>{
	<span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
		<span class="hljs-keyword">try</span> {
			Connection conn = DataSourceUtils.getConnection(dataSource);
			TCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);
			<span class="hljs-comment">// non_rollback</span>
			<span class="hljs-keyword">if</span> (tccFenceDO == <span class="hljs-keyword">null</span>) {
			    <span class="hljs-comment">//插入防悬挂记录</span>
				<span class="hljs-keyword">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_SUSPENDED);
				<span class="hljs-comment">//省略逻辑</span>
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-comment">//省略逻辑</span>
			}
			<span class="hljs-keyword">return</span> updateStatusAndInvokeTargetMethod(conn, rollbackMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_ROLLBACKED, status, args);
		} <span class="hljs-keyword">catch</span> (Throwable t) {
			<span class="hljs-comment">//省略逻辑</span>
		}
	});
}
</code></pre>
<p>而后面执行 try 阶段方法时首先会向 tcc_fence_log 表插入一条当前 xid 的记录，这样就造成了主键冲突。代码如下：</p>
<pre><code class="language-Java"><span class="hljs-comment">//TCCFenceHandler 类</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">prepareFence</span><span class="hljs-params">(String xid, Long branchId, String actionName, Callback&lt;Object&gt; targetCallback)</span> </span>{
	<span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
		<span class="hljs-keyword">try</span> {
			Connection conn = DataSourceUtils.getConnection(dataSource);
			<span class="hljs-keyword">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_TRIED);
			<span class="hljs-comment">//省略逻辑</span>
		} <span class="hljs-keyword">catch</span> (TCCFenceException e) {
			<span class="hljs-keyword">if</span> (e.getErrcode() == FrameworkErrorCode.DuplicateKeyException) {
				LOGGER.error(<span class="hljs-string">"Branch transaction has already rollbacked before,prepare fence failed. xid= {},branchId = {}"</span>, xid, branchId);
				addToLogCleanQueue(xid, branchId);
			}
			status.setRollbackOnly();
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SkipCallbackWrapperException(e);
		} <span class="hljs-keyword">catch</span> (Throwable t) {
			<span class="hljs-comment">//省略</span>
		}
	});
}
</code></pre>
<p><strong>注意：queryTCCFenceDO 方法 sql 中使用了 for update，这样就不用担心 Rollback 方法中获取不到 tcc_fence_log 表记录而无法判断 try 阶段本地事务的执行结果了。</strong></p>
<h2>5 总结</h2>
<p>TCC 模式是分布式事务中非常重要的事务模式，但是幂等、悬挂和空回滚一直是 TCC 模式需要考虑的问题，Seata 框架在 1.5.1 版本完美解决了这些问题。</p>
<p>对 tcc_fence_log 表的操作也需要考虑事务的控制，Seata 使用了代理数据源，使 tcc_fence_log 表操作和 RM 业务操作在同一个本地事务中执行，这样就能保证本地操作和对 tcc_fence_log 的操作同时成功或失败。</p>
</section><footer class="footer-container"><div class="footer-body"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png"/><p class="docsite-power">website powered by docsite</p><div class="cols-container"><div class="col col-12"><h3>愿景</h3><p>Seata 是一款阿里巴巴开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/overview/what-is-seata.html" target="_self">Seata 是什么？</a></dd><dd><a href="/zh-cn/docs/user/quickstart.html" target="_self">快速开始</a></dd><dd><a href="https://github.com/seata/seata.github.io/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/seata/seata.github.io" target="_self">在Github上编辑此文档</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2022 Seata</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script src="//g.alicdn.com/alilog/mlog/aplus_v2.js" id="beacon-aplus" exparams="clog=o&aplus&sidx=aplusSidx&ckx=aplusCkx"></script>
     <script src="//g.alicdn.com/aes/??tracker/1.0.34/index.js,tracker-plugin-pv/2.4.5/index.js,tracker-plugin-event/1.2.5/index.js,tracker-plugin-jserror/1.0.13/index.js,tracker-plugin-api/1.1.14/index.js,tracker-plugin-perf/1.1.8/index.js,tracker-plugin-eventTiming/1.0.4/index.js">
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-X4LJGF90X2"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
	<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();

    window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-X4LJGF90X2');
    </script>
</body>
</html>

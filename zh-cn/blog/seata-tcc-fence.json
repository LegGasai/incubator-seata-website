{
  "filename": "seata-tcc-fence.md",
  "__html": "<p>今天来聊一聊阿里巴巴 Seata 新版本（1.5.1）是怎么解决 TCC 模式下的幂等、悬挂和空回滚问题的。</p>\n<h2>1 TCC 回顾</h2>\n<p>TCC 模式是最经典的分布式事务解决方案，它将分布式事务分为两个阶段来执行，try 阶段对每个分支事务进行预留资源，如果所有分支事务都预留资源成功，则进入 commit 阶段提交全局事务，如果有一个节点预留资源失败则进入 cancel 阶段回滚全局事务。</p>\n<p>以传统的订单、库存、账户服务为例，在 try 阶段尝试预留资源，插入订单、扣减库存、扣减金额，这三个服务都是要提交本地事务的，这里可以把资源转入中间表。在 commit 阶段，再把 try 阶段预留的资源转入最终表。而在 cancel 阶段，把 try 阶段预留的资源进行释放，比如把账户金额返回给客户的账户。</p>\n<p><strong>注意：try 阶段必须是要提交本地事务的，比如扣减订单金额，必须把钱从客户账户扣掉，如果不扣掉，在 commit 阶段客户账户钱不够了，就会出问题。</strong></p>\n<h3>1.1 try-commit</h3>\n<p>try 阶段首先进行预留资源，然后在 commit 阶段扣除资源。如下图：</p>\n<p><img src=\"/img/blog/fence-try-commit.png\" alt=\"fence-try-commit\"></p>\n<h3>1.2 try-cancel</h3>\n<p>try 阶段首先进行预留资源，预留资源时扣减库存失败导致全局事务回滚，在 cancel 阶段释放资源。如下图：</p>\n<p><img src=\"/img/blog/fence-try-cancel.png\" alt=\"fence-try-cancel\"></p>\n<h2>2 TCC 优势</h2>\n<p>TCC 模式最大的优势是效率高。TCC 模式在 try 阶段的锁定资源并不是真正意义上的锁定，而是真实提交了本地事务，将资源预留到中间态，并不需要阻塞等待，因此效率比其他模式要高。</p>\n<p>同时 TCC 模式还可以进行如下优化：</p>\n<h3>2.1 异步提交</h3>\n<p>try 阶段成功后，不立即进入 confirm/cancel 阶段，而是认为全局事务已经结束了，启动定时任务来异步执行 confirm/cancel，扣减或释放资源，这样会有很大的性能提升。</p>\n<h3>2.2 同库模式</h3>\n<p>TCC 模式中有三个角色：</p>\n<ul>\n<li>TM：管理全局事务，包括开启全局事务，提交/回滚全局事务；</li>\n<li>RM：管理分支事务；</li>\n<li>TC: 管理全局事务和分支事务的状态。</li>\n</ul>\n<p>下图来自 Seata 官网：</p>\n<p><img src=\"/img/blog/fence-fiffrent-db.png\" alt=\"fence-fiffrent-db\"></p>\n<p>TM 开启全局事务时，RM 需要向 TC 发送注册消息，TC 保存分支事务的状态。TM 请求提交或回滚时，TC 需要向 RM 发送提交或回滚消息。这样包含两个个分支事务的分布式事务中，TC 和 RM 之间有四次 RPC。</p>\n<p>优化后的流程如下图：</p>\n<p><img src=\"/img/blog/fence-same-db.png\" alt=\"fence-same-db\"></p>\n<p>TC 保存全局事务的状态。TM 开启全局事务时，RM 不再需要向 TC 发送注册消息，而是把分支事务状态保存在了本地。TM 向 TC 发送提交或回滚消息后，RM 异步线程首先查出本地保存的未提交分支事务，然后向 TC 发送消息获取（本地分支事务）所在的全局事务状态，以决定是提交还是回滚本地事务。</p>\n<p>这样优化后，RPC 次数减少了 50%，性能大幅提升。</p>\n<h2>3 RM 代码示例</h2>\n<p>以库存服务为例，RM 库存服务接口代码如下：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@LocalTCC</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StorageService</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * 扣减库存\n     * <span class=\"hljs-doctag\">@param</span> xid 全局xid\n     * <span class=\"hljs-doctag\">@param</span> productId 产品id\n     * <span class=\"hljs-doctag\">@param</span> count 数量\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@TwoPhaseBusinessAction</span>(name = <span class=\"hljs-string\">\"storageApi\"</span>, commitMethod = <span class=\"hljs-string\">\"commit\"</span>, rollbackMethod = <span class=\"hljs-string\">\"rollback\"</span>, useTCCFence = <span class=\"hljs-keyword\">true</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">decrease</span><span class=\"hljs-params\">(String xid, Long productId, Integer count)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * 提交事务\n     * <span class=\"hljs-doctag\">@param</span> actionContext\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">(BusinessActionContext actionContext)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * 回滚事务\n     * <span class=\"hljs-doctag\">@param</span> actionContext\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">rollback</span><span class=\"hljs-params\">(BusinessActionContext actionContext)</span></span>;\n}\n</code></pre>\n<p>通过 @LocalTCC 这个注解，RM 初始化的时候会向 TC 注册一个分支事务。在 try 阶段的方法（decrease方法）上有一个 @TwoPhaseBusinessAction 注解，这里定义了分支事务的 resourceId，commit 方法和 cancel 方法，useTCCFence 这个属性下一节再讲。</p>\n<h2>4 TCC 存在问题</h2>\n<p>TCC 模式中存在的三大问题是幂等、悬挂和空回滚。在 Seata1.5.1 版本中，增加了一张事务控制表，表名是 tcc_fence_log 来解决这个问题。而在上一节 @TwoPhaseBusinessAction 注解中提到的属性 useTCCFence 就是来指定是否开启这个机制，这个属性值默认是 false。</p>\n<p>tcc_fence_log 建表语句如下（MySQL 语法）：</p>\n<pre><code class=\"language-SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span> <span class=\"hljs-string\">`tcc_fence_log`</span>\n(\n    <span class=\"hljs-string\">`xid`</span>           <span class=\"hljs-built_in\">VARCHAR</span>(<span class=\"hljs-number\">128</span>)  <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'global id'</span>,\n    <span class=\"hljs-string\">`branch_id`</span>     <span class=\"hljs-built_in\">BIGINT</span>        <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'branch id'</span>,\n    <span class=\"hljs-string\">`action_name`</span>   <span class=\"hljs-built_in\">VARCHAR</span>(<span class=\"hljs-number\">64</span>)   <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'action name'</span>,\n    <span class=\"hljs-string\">`status`</span>        <span class=\"hljs-built_in\">TINYINT</span>       <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'status(tried:1;committed:2;rollbacked:3;suspended:4)'</span>,\n    <span class=\"hljs-string\">`gmt_create`</span>    DATETIME(<span class=\"hljs-number\">3</span>)   <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'create time'</span>,\n    <span class=\"hljs-string\">`gmt_modified`</span>  DATETIME(<span class=\"hljs-number\">3</span>)   <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'update time'</span>,\n    PRIMARY <span class=\"hljs-keyword\">KEY</span> (<span class=\"hljs-string\">`xid`</span>, <span class=\"hljs-string\">`branch_id`</span>),\n    <span class=\"hljs-keyword\">KEY</span> <span class=\"hljs-string\">`idx_gmt_modified`</span> (<span class=\"hljs-string\">`gmt_modified`</span>),\n    <span class=\"hljs-keyword\">KEY</span> <span class=\"hljs-string\">`idx_status`</span> (<span class=\"hljs-string\">`status`</span>)\n) <span class=\"hljs-keyword\">ENGINE</span> = <span class=\"hljs-keyword\">InnoDB</span>\n<span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">CHARSET</span> = utf8mb4;\n</code></pre>\n<h3>4.1 幂等</h3>\n<p>在 commit/cancel 阶段，因为 TC 没有收到分支事务的响应，需要进行重试，这就要分支事务支持幂等。</p>\n<p>我们看一下新版本是怎么解决的。下面的代码在 TCCResourceManager 类：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BranchStatus <span class=\"hljs-title\">branchCommit</span><span class=\"hljs-params\">(BranchType branchType, String xid, <span class=\"hljs-keyword\">long</span> branchId, String resourceId,\n\t\t\t\t\t\t\t\t String applicationData)</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n\tTCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);\n\t<span class=\"hljs-comment\">//省略判断</span>\n\tObject targetTCCBean = tccResource.getTargetBean();\n\tMethod commitMethod = tccResource.getCommitMethod();\n\t<span class=\"hljs-comment\">//省略判断</span>\n\t<span class=\"hljs-keyword\">try</span> {\n\t\t<span class=\"hljs-comment\">//BusinessActionContext</span>\n\t\tBusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,\n\t\t\tapplicationData);\n\t\tObject[] args = <span class=\"hljs-keyword\">this</span>.getTwoPhaseCommitArgs(tccResource, businessActionContext);\n\t\tObject ret;\n\t\t<span class=\"hljs-keyword\">boolean</span> result;\n\t\t<span class=\"hljs-comment\">//注解 useTCCFence 属性是否设置为 true</span>\n\t\t<span class=\"hljs-keyword\">if</span> (Boolean.TRUE.equals(businessActionContext.getActionContext(Constants.USE_TCC_FENCE))) {\n\t\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\t\tresult = TCCFenceHandler.commitFence(commitMethod, targetTCCBean, xid, branchId, args);\n\t\t\t} <span class=\"hljs-keyword\">catch</span> (SkipCallbackWrapperException | UndeclaredThrowableException e) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> e.getCause();\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-comment\">//省略逻辑</span>\n\t\t}\n\t\tLOGGER.info(<span class=\"hljs-string\">\"TCC resource commit result : {}, xid: {}, branchId: {}, resourceId: {}\"</span>, result, xid, branchId, resourceId);\n\t\t<span class=\"hljs-keyword\">return</span> result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;\n\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t<span class=\"hljs-comment\">//省略</span>\n\t\t<span class=\"hljs-keyword\">return</span> BranchStatus.PhaseTwo_CommitFailed_Retryable;\n\t}\n}\n</code></pre>\n<p>上面的代码可以看到，执行分支事务提交方法时，首先判断 useTCCFence 属性是否为 true，如果为 true，则走 TCCFenceHandler 类中的 commitFence 逻辑，否则走普通提交逻辑。</p>\n<p>TCCFenceHandler 类中的 commitFence 方法调用了 TCCFenceHandler 类的 commitFence 方法，代码如下：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">commitFence</span><span class=\"hljs-params\">(Method commitMethod, Object targetTCCBean,\n\t\t\t\t\t\t\t\t  String xid, Long branchId, Object[] args)</span> </span>{\n\t<span class=\"hljs-keyword\">return</span> transactionTemplate.execute(status -&gt; {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tConnection conn = DataSourceUtils.getConnection(dataSource);\n\t\t\tTCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);\n\t\t\t<span class=\"hljs-keyword\">if</span> (tccFenceDO == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TCCFenceException(String.format(<span class=\"hljs-string\">\"TCC fence record not exists, commit fence method failed. xid= %s, branchId= %s\"</span>, xid, branchId),\n\t\t\t\t\t\tFrameworkErrorCode.RecordAlreadyExists);\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> (TCCFenceConstant.STATUS_COMMITTED == tccFenceDO.getStatus()) {\n\t\t\t\tLOGGER.info(<span class=\"hljs-string\">\"Branch transaction has already committed before. idempotency rejected. xid: {}, branchId: {}, status: {}\"</span>, xid, branchId, tccFenceDO.getStatus());\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> (TCCFenceConstant.STATUS_ROLLBACKED == tccFenceDO.getStatus() || TCCFenceConstant.STATUS_SUSPENDED == tccFenceDO.getStatus()) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (LOGGER.isWarnEnabled()) {\n\t\t\t\t\tLOGGER.warn(<span class=\"hljs-string\">\"Branch transaction status is unexpected. xid: {}, branchId: {}, status: {}\"</span>, xid, branchId, tccFenceDO.getStatus());\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">return</span> updateStatusAndInvokeTargetMethod(conn, commitMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_COMMITTED, status, args);\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t\tstatus.setRollbackOnly();\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SkipCallbackWrapperException(t);\n\t\t}\n\t});\n}\n</code></pre>\n<p>从代码中可以看到，提交事务时首先会判断 tcc_fence_log 表中是否已经有记录，如果有记录，则判断事务执行状态并返回。这样如果判断到事务的状态已经是 STATUS_COMMITTED，就不会再次提交，保证了幂等。如果 tcc_fence_log 表中没有记录，则插入一条记录，供后面重试时判断。</p>\n<p>Rollback 的逻辑跟 commit 类似，逻辑在类 TCCFenceHandler 的 rollbackFence 方法。</p>\n<h3>4.2 空回滚</h3>\n<p>如下图，账户服务是两个节点的集群，在 try 阶段账户服务 1 这个节点发生了故障，try 阶段在不考虑重试的情况下，全局事务必须要走向结束状态，这样就需要在账户服务上执行一次 cancel 操作。</p>\n<p><img src=\"/img/blog/fence-empty-rollback.png\" alt=\"fence-empty-rollback\"></p>\n<p>Seata 的解决方案是在 try 阶段 往 tcc_fence_log  表插入一条记录，status 字段值是 STATUS_TRIED，在 Rollback 阶段判断记录是否存在，如果不存在，则不执行回滚操作。代码如下：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-comment\">//TCCFenceHandler 类</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title\">prepareFence</span><span class=\"hljs-params\">(String xid, Long branchId, String actionName, Callback&lt;Object&gt; targetCallback)</span> </span>{\n\t<span class=\"hljs-keyword\">return</span> transactionTemplate.execute(status -&gt; {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tConnection conn = DataSourceUtils.getConnection(dataSource);\n\t\t\t<span class=\"hljs-keyword\">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_TRIED);\n\t\t\tLOGGER.info(<span class=\"hljs-string\">\"TCC fence prepare result: {}. xid: {}, branchId: {}\"</span>, result, xid, branchId);\n\t\t\t<span class=\"hljs-keyword\">if</span> (result) {\n\t\t\t\t<span class=\"hljs-keyword\">return</span> targetCallback.execute();\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TCCFenceException(String.format(<span class=\"hljs-string\">\"Insert tcc fence record error, prepare fence failed. xid= %s, branchId= %s\"</span>, xid, branchId),\n\t\t\t\t\t\tFrameworkErrorCode.InsertRecordError);\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">catch</span> (TCCFenceException e) {\n\t\t\t<span class=\"hljs-comment\">//省略</span>\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t\t<span class=\"hljs-comment\">//省略</span>\n\t\t}\n\t});\n}\n</code></pre>\n<p>在 Rollback 阶段的处理逻辑如下:</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-comment\">//TCCFenceHandler 类</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">rollbackFence</span><span class=\"hljs-params\">(Method rollbackMethod, Object targetTCCBean,\n\t\t\t\t\t\t\t\t\tString xid, Long branchId, Object[] args, String actionName)</span> </span>{\n\t<span class=\"hljs-keyword\">return</span> transactionTemplate.execute(status -&gt; {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tConnection conn = DataSourceUtils.getConnection(dataSource);\n\t\t\tTCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);\n\t\t\t<span class=\"hljs-comment\">// non_rollback</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> (tccFenceDO == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t\t<span class=\"hljs-comment\">//不执行回滚逻辑</span>\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (TCCFenceConstant.STATUS_ROLLBACKED == tccFenceDO.getStatus() || TCCFenceConstant.STATUS_SUSPENDED == tccFenceDO.getStatus()) {\n\t\t\t\t\tLOGGER.info(<span class=\"hljs-string\">\"Branch transaction had already rollbacked before, idempotency rejected. xid: {}, branchId: {}, status: {}\"</span>, xid, branchId, tccFenceDO.getStatus());\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (TCCFenceConstant.STATUS_COMMITTED == tccFenceDO.getStatus()) {\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (LOGGER.isWarnEnabled()) {\n\t\t\t\t\t\tLOGGER.warn(<span class=\"hljs-string\">\"Branch transaction status is unexpected. xid: {}, branchId: {}, status: {}\"</span>, xid, branchId, tccFenceDO.getStatus());\n\t\t\t\t\t}\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">return</span> updateStatusAndInvokeTargetMethod(conn, rollbackMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_ROLLBACKED, status, args);\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t\tstatus.setRollbackOnly();\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SkipCallbackWrapperException(t);\n\t\t}\n\t});\n}\n</code></pre>\n<p>updateStatusAndInvokeTargetMethod 方法执行的 sql 如下：</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">update</span> tcc_fence_log <span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">status</span> = ?, gmt_modified = ?\n    <span class=\"hljs-keyword\">where</span> xid = ? <span class=\"hljs-keyword\">and</span>  branch_id = ? <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">status</span> = ? ;\n</code></pre>\n<p>可见就是把 tcc_fence_log 表记录的  status  字段值从 STATUS_TRIED 改为 STATUS_ROLLBACKED，如果更新成功，就执行回滚逻辑。</p>\n<h3>4.3 悬挂</h3>\n<p>悬挂是指因为网络问题，RM 开始没有收到 try 指令，但是执行了 Rollback 后 RM 又收到了 try 指令并且预留资源成功，这时全局事务已经结束，最终导致预留的资源不能释放。如下图：</p>\n<p><img src=\"/img/blog/fence-suspend.png\" alt=\"fence-suspend\"></p>\n<p>Seata 解决这个问题的方法是执行 Rollback 方法时先判断 tcc_fence_log 是否存在当前 xid 的记录，如果没有则向 tcc_fence_log 表插入一条记录，状态是 STATUS_SUSPENDED，并且不再执行回滚操作。代码如下：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">rollbackFence</span><span class=\"hljs-params\">(Method rollbackMethod, Object targetTCCBean,\n\t\t\t\t\t\t\t\t\tString xid, Long branchId, Object[] args, String actionName)</span> </span>{\n\t<span class=\"hljs-keyword\">return</span> transactionTemplate.execute(status -&gt; {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tConnection conn = DataSourceUtils.getConnection(dataSource);\n\t\t\tTCCFenceDO tccFenceDO = TCC_FENCE_DAO.queryTCCFenceDO(conn, xid, branchId);\n\t\t\t<span class=\"hljs-comment\">// non_rollback</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> (tccFenceDO == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t    <span class=\"hljs-comment\">//插入防悬挂记录</span>\n\t\t\t\t<span class=\"hljs-keyword\">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_SUSPENDED);\n\t\t\t\t<span class=\"hljs-comment\">//省略逻辑</span>\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-comment\">//省略逻辑</span>\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">return</span> updateStatusAndInvokeTargetMethod(conn, rollbackMethod, targetTCCBean, xid, branchId, TCCFenceConstant.STATUS_ROLLBACKED, status, args);\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t\t<span class=\"hljs-comment\">//省略逻辑</span>\n\t\t}\n\t});\n}\n</code></pre>\n<p>而后面执行 try 阶段方法时首先会向 tcc_fence_log 表插入一条当前 xid 的记录，这样就造成了主键冲突。代码如下：</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-comment\">//TCCFenceHandler 类</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title\">prepareFence</span><span class=\"hljs-params\">(String xid, Long branchId, String actionName, Callback&lt;Object&gt; targetCallback)</span> </span>{\n\t<span class=\"hljs-keyword\">return</span> transactionTemplate.execute(status -&gt; {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tConnection conn = DataSourceUtils.getConnection(dataSource);\n\t\t\t<span class=\"hljs-keyword\">boolean</span> result = insertTCCFenceLog(conn, xid, branchId, actionName, TCCFenceConstant.STATUS_TRIED);\n\t\t\t<span class=\"hljs-comment\">//省略逻辑</span>\n\t\t} <span class=\"hljs-keyword\">catch</span> (TCCFenceException e) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (e.getErrcode() == FrameworkErrorCode.DuplicateKeyException) {\n\t\t\t\tLOGGER.error(<span class=\"hljs-string\">\"Branch transaction has already rollbacked before,prepare fence failed. xid= {},branchId = {}\"</span>, xid, branchId);\n\t\t\t\taddToLogCleanQueue(xid, branchId);\n\t\t\t}\n\t\t\tstatus.setRollbackOnly();\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SkipCallbackWrapperException(e);\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n\t\t\t<span class=\"hljs-comment\">//省略</span>\n\t\t}\n\t});\n}\n</code></pre>\n<p><strong>注意：queryTCCFenceDO 方法 sql 中使用了 for update，这样就不用担心 Rollback 方法中获取不到 tcc_fence_log 表记录而无法判断 try 阶段本地事务的执行结果了。</strong></p>\n<h2>5 总结</h2>\n<p>TCC 模式是分布式事务中非常重要的事务模式，但是幂等、悬挂和空回滚一直是 TCC 模式需要考虑的问题，Seata 框架在 1.5.1 版本完美解决了这些问题。</p>\n<p>对 tcc_fence_log 表的操作也需要考虑事务的控制，Seata 使用了代理数据源，使 tcc_fence_log 表操作和 RM 业务操作在同一个本地事务中执行，这样就能保证本地操作和对 tcc_fence_log 的操作同时成功或失败。</p>\n",
  "link": "/zh-cn/blog/seata-tcc-fence.html",
  "meta": {
    "title": "阿里 Seata 新版本终于解决了 TCC 模式的幂等、悬挂和空回滚问题",
    "author": "朱晋君",
    "keywords": "Seata、TCC、幂等、悬挂、空回滚",
    "description": "Seata 在 1.5.1 版本解决了 TCC 模式的幂等、悬挂和空回滚问题，这篇文章主要讲解 Seata 是怎么解决的。",
    "date": "2022/06/25"
  }
}
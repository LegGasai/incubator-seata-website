"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[60839],{16364:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=t(74848),o=t(28453);const a={layout:"post",comments:!0,title:"Analysis of Seata Application-Side Startup Process - How RM & TM Establish Connections with TC",date:new Date("2021-02-28T21:08:00.000Z"),author:"booogu",catalog:!0,tags:["Seata"]},s=void 0,r={permalink:"/blog/seata-client-start-analysis-01",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-client-start-analysis-01.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-client-start-analysis-01.md",title:"Analysis of Seata Application-Side Startup Process - How RM & TM Establish Connections with TC",description:"\"Just started with Seata and don't have a deep understanding of its various modules?",date:"2021-02-28T21:08:00.000Z",formattedDate:"February 28, 2021",tags:[{label:"Seata",permalink:"/blog/tags/seata"}],readingTime:8.15,hasTruncateMarker:!1,authors:[{name:"booogu"}],frontMatter:{layout:"post",comments:!0,title:"Analysis of Seata Application-Side Startup Process - How RM & TM Establish Connections with TC",date:"2021-02-28T21:08:00.000Z",author:"booogu",catalog:!0,tags:["Seata"]},unlisted:!1,prevItem:{title:"Seata Application-Side Startup Process Analysis \u2014 Registry and Configuration Module",permalink:"/blog/seata-client-start-analysis-02"},nextItem:{title:"Integration of Spring Cloud with Seata for Distributed Transaction - TCC Mode",permalink:"/blog/integrate-seata-tcc-mode-with-spring-cloud"}},l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Starting with GlobalTransactionScanner",id:"starting-with-globaltransactionscanner",level:2},{value:"Initialisation and connection process of RM &amp; TM",id:"initialisation-and-connection-process-of-rm--tm",level:2},{value:"Design of class relationship",id:"design-of-class-relationship",level:3},{value:"The complete flow of initialisation",id:"the-complete-flow-of-initialisation",level:3},{value:"Grabbing the core - Channel creation",id:"grabbing-the-core---channel-creation",level:3},{value:"Timing and flow of establishing a connection",id:"timing-and-flow-of-establishing-a-connection",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\"Just started with Seata and don't have a deep understanding of its various modules? ",(0,i.jsx)("br",{}),"\nWant to delve into Seata's source code but haven't taken the plunge yet? ",(0,i.jsx)("br",{}),"\nCurious about what your application does 'secretly' during startup after integrating Seata? ",(0,i.jsx)("br",{}),"\nWant to learn about the design principles and best practices embodied in Seata as an excellent open-source framework? ",(0,i.jsx)("br",{}),"\nIf you have any of the above thoughts, then this article is tailor-made for you~"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["Those who have seen the first picture in the official README should know that Seata coordinates distributed transactions through its ",(0,i.jsx)(n.strong,{children:"coordinator side"})," TC, which communicates and interacts with the ",(0,i.jsx)(n.strong,{children:"application side"})," TM and RM to ensure data consistency among multiple transaction participants in distributed transactions. So, how does Seata establish connections and communicate between the coordinator side and the application side?"]}),"\n",(0,i.jsx)(n.p,{children:"That's right, the answer is Netty. Netty, as a high-performance RPC communication framework, ensures efficient communication between TC and RM. This article will not go into detail about Netty; instead, our focus today is on how the **application side, during startup, uses a series of Seata's key modules (such as RPC, Config/Registry Center, etc.) to establish communication with the coordinator side."}),"\n",(0,i.jsx)(n.h2,{id:"starting-with-globaltransactionscanner",children:"Starting with GlobalTransactionScanner"}),"\n",(0,i.jsx)(n.p,{children:"We know that Seata provides several development annotations, such as @GlobalTransactional for enabling distributed transactions, @TwoPhraseBusinessAction for declaring TCC two-phase services, and so on, which are based on the Spring AOP mechanism to enhance the annotations by assigning the corresponding bean methods to interceptors. Interceptors are enhanced to complete the corresponding processing logic. GlobalTransactionScanner, a Spring bean, carries the responsibility of assigning interceptors to annotations. From the name of its scanner, it is not difficult to deduce that it is designed for the startup of the Spring application, and the global transaction (GlobalTransactionScanner). GlobalTransactionScanner) during Spring application startup."}),"\n",(0,i.jsx)(n.p,{children:"In addition, the process of initialising the application-side RPC clients (TMClient, RMClient) and establishing a connection with the TC is also initiated in GlobalTransactionScanner#afterPropertiesSet():"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'/**\n* package: io.seata.spring.annotation\n* class: GlobalTransactionScanner\n*/\n@Override\npublic void afterPropertiesSet() {\nif (disableGlobalTransaction) {\nif (LOGGER.isInfoEnabled()) {\nLOGGER.info("Global transaction is disabled.");\n}\nreturn.\n}\n// Perform TM, RM initialisation after the bean properties are initialised\ninitClient();\n\n    }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"initialisation-and-connection-process-of-rm--tm",children:"Initialisation and connection process of RM & TM"}),"\n",(0,i.jsx)(n.p,{children:"Here, we take RMClient.init() as an example, and the initialisation process of TMClient is the same."}),"\n",(0,i.jsx)(n.h3,{id:"design-of-class-relationship",children:"Design of class relationship"}),"\n",(0,i.jsxs)(n.p,{children:["Looking at the source code of RMClient#init(), we find that RMClient first ",(0,i.jsx)(n.strong,{children:"constructs"})," an RmNettyRemotingClient, and then executes its ",(0,i.jsx)(n.strong,{children:"initialisation"})," init() method. The ",(0,i.jsx)(n.strong,{children:"constructor"})," and ",(0,i.jsx)(n.strong,{children:"initialisation"})," methods of RmNettyRemotingClient call the constructor and initialisation methods of the parent class layer by layer"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"    /**\n     * RMClient's initialisation logic\n     * package: io.seata.rm\n     * class: RMClient\n     */\n    public static void init(String applicationId, String transactionServiceGroup) {\n        //\u2460 Start with the RmNettyRemotingClient class and call the constructor of the parent class in turn\n\n        rmNettyRemotingClient.setResourceManager(DefaultResourceManager.get());\n        rmNettyRemotingClient.setTransactionMessageHandler(DefaultRMHandler.get()); rmNettyRemotingClient.setTransactionMessageHandler(DefaultRMHandler.get());\n        //\u2461 Then, starting with the RmNettyRemotingClient class, call init() of the parent class in turn\n        rmNettyRemotingClient.init();\n    }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The relationship between the above RMClient family classes and the process of calling the constructor and init() initialisation method is illustrated in the following diagram:\n",(0,i.jsx)(n.img,{src:"http://booogu.top/img/in-post/rmclient_relation.jpg",alt:"Relationship between the simplified version of the RMClient.init process and the main classes"})]}),"\n",(0,i.jsxs)(n.p,{children:["So why did you design RMClient with such a more complex inheritance relationship? In fact, it is in order to divide the responsibilities and boundaries of each layer clearly, so that each layer can focus on specific logic processing, to achieve better scalability, this part of the detailed design ideas, you can refer to the Seata RPC module refactoring PR of the operator by Hui brother's article! ",(0,i.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/PCSZ4a8cgmyZNhbUrO-BZQ",children:"The Road to Seata-RPC Refactoring"}),")"]}),"\n",(0,i.jsx)(n.h3,{id:"the-complete-flow-of-initialisation",children:"The complete flow of initialisation"}),"\n",(0,i.jsxs)(n.p,{children:["The main logic in the constructor and initialisation methods of each class can be sorted out with the help of the following ideographic sequence diagram, which can also be skipped first, and then looked back to see when these classes debut and how they interact with each other after we have analysed a few key classes below.\n",(0,i.jsx)(n.img,{src:"http://booogu.top/img/in-post/rmclient_initialization.png",alt:"Initialisation flow of RMClient"})]}),"\n",(0,i.jsx)(n.h3,{id:"grabbing-the-core---channel-creation",children:"Grabbing the core - Channel creation"}),"\n",(0,i.jsx)(n.p,{children:"First of all, we need to know that the communication between the application side and the coordinator side is done with the help of Netty's Channel, so the key to the communication process lies in the creation of the Channel**, which is created and managed in Seata by means of pooling (with the help of the object pool in common-pool)."}),"\n",(0,i.jsx)(n.p,{children:"Here we need to briefly introduce the simple concept of object pool and its implementation in Seata:\nThe main classes in common-pool are involved:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GenericKeydObjectPool<K, V>"}),": A KV generic object pool that provides access to all objects, while object creation is done by its internal factory class."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"KeyedPoolableObjectFactory<K, V>"}),": KV generic object factory responsible for the creation of pooled objects, held by the object pool"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The main classes involved are related to the implementation of object pooling in Seata:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["First, the pooled objects are ",(0,i.jsx)(n.strong,{children:"Channel"}),", which corresponds to the generic V in common-pool."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NettyPoolKey"}),": Key for Channel, corresponding to generic K in common-pool, NettyPoolKey contains two main information:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"address"}),":Address"," of TC Server when the Channel is created."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"message"}),":The"," RPC message sent to TC Server when the Channel is created."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"GenericKeydObjectPool<NettyPoolKey,Channel>"}),": Pool of Channel objects."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NettyPoolableFactory"}),": the factory class for creating Channel.\nHaving recognised the main classes related to object pooling above, let's take a look at some of the main classes in Seata that are involved in channel management and are related to RPC:"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"NettyClientChannelManager:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Holds the pool of Channel objects."}),"\n",(0,i.jsx)(n.li,{children:"Interacts with the channel object pool to manage application-side channels (acquisition, release, destruction, caching, etc.)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"RpcClientBootstrap: core bootstrap class for RPC clients, holds the Netty framework bootstrap object with start/stop capability; has the ability to get a new Channel based on the connection address for the Channel factory class to call."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"AbstractNettyRemotingClient:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Initialises and holds the RpcClientBootstrap."}),"\n",(0,i.jsx)(n.li,{children:"Application-side Netty client top-level abstraction, abstracts the ability of application-side RM/TM to obtain the NettyPoolKey corresponding to their respective Channel, for NettyClientChannelManager to call."}),"\n",(0,i.jsx)(n.li,{children:"Initialising the NettyPoolableFactory"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding the above concepts, we can simplify the process of creating a channel in Seata as follows:\n",(0,i.jsx)(n.img,{src:"http://booogu.top/img/in-post/create_channel.jpg",alt:"Process of creating a Channel object"})]}),"\n",(0,i.jsxs)(n.p,{children:["When you see this, you can go back and take a look at the above ",(0,i.jsx)(n.strong,{children:"Initialisation Sequence Diagram for RMClient"}),", and you should have a clearer understanding of the responsibilities and relationships of the various categories in the diagram, as well as the intent of the entire initialisation process."]}),"\n",(0,i.jsx)(n.h3,{id:"timing-and-flow-of-establishing-a-connection",children:"Timing and flow of establishing a connection"}),"\n",(0,i.jsx)(n.p,{children:"So, when does RMClient establish a connection with Server?"}),"\n",(0,i.jsx)(n.p,{children:"During the initialisation of RMClient, you will find that many init() methods set up some timed tasks, and the mechanism of reconnecting (connecting) the Seata application side to the coordinator is achieved through timed tasks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/**\n* package: io.seata.core.rpcn.netty\n* class: AbstractNettyRemotingClient\n*/\npublic void init() {\n// Set the timer to reconnect to the TC Server at regular intervals.\ntimerExecutor.scheduleAtFixedRate(new Runnable() {\n@Override\npublic void run() {\nclientChannelManager.reconnect(getTransactionServiceGroup());\n}\n}, SCHEDULE_DELAY_MILLS, SCHEDULE_INTERVAL_MILLS, TimeUnit.MILLISECONDS);\nif (NettyClientConfig.isEnableClientBatchSendRequest()) {\nmergeSendExecutorService = new ThreadPoolExecutor(MAX_MERGE_SEND_THREAD,\nMAX_MERGE_SEND_THREAD,\nKEEP_ALIVE_TIME, TimeUnit.\nnew LinkedBlockingQueue<>(),\nnew NamedThreadFactory(getThreadPrefix(), MAX_MERGE_SEND_THREAD));\nmergeSendExecutorService.submit(new MergedSendRunnable());\n}\nsuper.init();\nclientBootstrap.start();\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's see how the classes we explored above work together to connect RMClient to TC by tracing the execution of a reconnect (the first connection may actually occur during registerResource, but the process is the same)\n",(0,i.jsx)(n.img,{src:"http://booogu.top/img/in-post/rmclient_connect_tcserver.png",alt:"RMClient and TC Server connection process"})]}),"\n",(0,i.jsx)(n.p,{children:"In this diagram, you can focus on these points:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["NettyClientChannelManager executes the callback function (getPoolKeyFunction()) to get the NettyPoolKey in the concrete AbstractNettyRemotingClient: the different Clients (RMClient and TMClient) on the application side, when they create the NettyPoolKey, they create the NettyChannelManager. TMClient) on the application side, the Key used when creating the Channel is different, so that ",(0,i.jsx)(n.strong,{children:"they send different registration messages when reconnecting to the TC Server"}),", which is also determined by the different roles they play in Seata:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"TMClient: plays the role of transaction manager, when creating a Channel, it only sends a TM registration request (RegisterTMRequest) to the TC."}),"\n",(0,i.jsx)(n.li,{children:"RMClient: plays the role of resource manager, needs to manage all transaction resources on the application side, therefore, when creating a Channel, it needs to get all transaction resource information on the application side before sending RM registration request (RegisterRMRequest), and register it to TC Server."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["In the Channel object factory's ",(0,i.jsx)(n.code,{children:"NettyPoolableFactory"}),"'s ",(0,i.jsx)(n.code,{children:"makeObject"})," (create Channel) method, two tasks are completed using the two pieces of information in ",(0,i.jsx)(n.code,{children:"NettyPoolKey"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A new Channel is created using the address from ",(0,i.jsx)(n.code,{children:"NettyPoolKey"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A registration request is sent to the TC Server using the message from ",(0,i.jsx)(n.code,{children:"NettyPoolKey"})," and the new Channel. This is the Client's initial connection (first execution) or reconnection (subsequent executions driven by scheduled tasks) request to the TC Server."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The above content covers the entire process of the Seata application's initialization and its connection establishment with the TC Server coordinator side."}),"\n",(0,i.jsx)(n.p,{children:"For deeper details, it is recommended to thoroughly read the source code based on the outline and key points mentioned in this article. This will undoubtedly lead to a deeper understanding and new insights!"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Postscript: Considering the length and to maintain a suitable amount of information for a source code analysis article, the ",(0,i.jsx)(n.strong,{children:"collaboration of configuration and registration modules"})," mentioned in the introduction was not expanded upon in this article. ",(0,i.jsx)("br",{}),"\nIn the next source code analysis, I will focus on the ",(0,i.jsx)(n.strong,{children:"configuration center"})," and ",(0,i.jsx)(n.strong,{children:"registration center"}),", analyzing how the Seata application side ",(0,i.jsx)(n.strong,{children:"discovers the TC Server through service discovery"})," and how it ",(0,i.jsx)(n.strong,{children:"obtains various information from the configuration module"})," before establishing connections between RMClient/TM Client and the TC Server."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);
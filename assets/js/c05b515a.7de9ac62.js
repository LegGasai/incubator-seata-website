"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[73279],{40969:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var o=n(74848),a=n(28453);const r={title:"Analysis of Seata Data Source Proxy",keywords:["Seata","data source","data source proxy","multiple data sources"],description:"This article primarily introduces the implementation principles of Seata data source proxy and potential issues that may arise during usage.",author:"xiaoyong.luo",date:"2020/10/16"},s="Data Source Proxy",i={permalink:"/blog/seata-datasource-proxy",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-datasource-proxy.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-datasource-proxy.md",title:"Analysis of Seata Data Source Proxy",description:"This article primarily introduces the implementation principles of Seata data source proxy and potential issues that may arise during usage.",date:"2020-10-16T00:00:00.000Z",formattedDate:"October 16, 2020",tags:[],readingTime:29.455,hasTruncateMarker:!1,authors:[{name:"xiaoyong.luo"}],frontMatter:{title:"Analysis of Seata Data Source Proxy",keywords:["Seata","data source","data source proxy","multiple data sources"],description:"This article primarily introduces the implementation principles of Seata data source proxy and potential issues that may arise during usage.",author:"xiaoyong.luo",date:"2020/10/16"},unlisted:!1,prevItem:{title:"Detailed Explanation of seata-golang Communication Model",permalink:"/blog/seata-golang-communication-mode"},nextItem:{title:"Seata Source Code - Client Startup Process in Distributed Transactions",permalink:"/blog/seata-sourcecode-client-bootstrap"}},c={authorsImageUrls:[void 0]},d=[{value:"Proxy description",id:"proxy-description",level:2},{value:"Manual Proxy",id:"manual-proxy",level:2},{value:"AutoProxy",id:"autoproxy",level:2},{value:"Data Source Multi-Level Proxy",id:"data-source-multi-level-proxy",level:2},{value:"Commit business SQL",id:"commit-business-sql",level:2},{value:"UNDO_LOG insert",id:"undo_log-insert",level:2},{value:"Impact on branch transaction commits",id:"impact-on-branch-transaction-commits",level:2},{value:"Impact on branch transaction rollback",id:"impact-on-branch-transaction-rollback",level:2},{value:"Problem analysis",id:"problem-analysis",level:3},{value:"Background",id:"background",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Problems",id:"problems",level:2},{value:"Problem Analysis",id:"problem-analysis-1",level:2},{value:"Verify the conjecture",id:"verify-the-conjecture",level:2},{value:"Final implementation",id:"final-implementation",level:2},{value:"Code changes",id:"code-changes",level:2},{value:"DataSourceProxyHolder",id:"datasourceproxyholder",level:3},{value:"DataSourceProxy",id:"datasourceproxy",level:3},{value:"SeataDataSourceBeanPostProcessor",id:"seatadatasourcebeanpostprocessor",level:3},{value:"Multi-Layer Proxy Summary",id:"multi-layer-proxy-summary",level:2},{value:"Not using the <code>@Transactional</code> annotation",id:"not-using-the-transactional-annotation",level:2},{value:"Use the <code>@Transactional</code> annotation.",id:"use-the-transactional-annotation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In Seata version 1.3.0, data source auto-proxy and manual proxy must not be mixed, otherwise it will lead to multi-layer proxy, which will lead to the following problems:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["single data source case: cause branch transaction commit, undo_log itself is also proxied, i.e. ",(0,o.jsx)(t.code,{children:"generated undo_log for undo_log, assumed to be undo_log2"}),", at this time, undo_log will be treated as a branch transaction; branch transaction rollback, because of the ",(0,o.jsx)(t.code,{children:"undo_log2"})," generated by the faulty in ",(0,o.jsx)(t.code,{children:"undo_log corresponding transaction branch"})," rollback. When the branch transaction is rolled back, because there is a problem with the generation of ",(0,o.jsx)(t.code,{children:"undo_log2"}),", when the transaction branch corresponding to the ",(0,o.jsx)(t.code,{children:"undo_log"})," is rolled back, it will delete the ",(0,o.jsx)(t.code,{children:"undo_log"})," associated with the ",(0,o.jsx)(t.code,{children:"business table"}),", which will lead to the discovery that the ",(0,o.jsx)(t.code,{children:"business table corresponding to the "}),"business table",(0,o.jsx)(t.code,{children:"is rolled back and the"}),"undo_log",(0,o.jsx)(t.code,{children:"doesn't exist, and thus generate an additional status of 1 for the"}),"undo_log.' This time, the overall logic is already messed up, which is a very serious problem!"]}),"\n",(0,o.jsxs)(t.li,{children:["multiple data sources and ",(0,o.jsx)(t.code,{children:"logical data sources are proxied"})," case: in addition to the problems that will occur in the case of a single data source, may also cause deadlock problems. The reason for the deadlock is that for the undo_log operation, the ",(0,o.jsx)(t.code,{children:"select for update"})," and ",(0,o.jsx)(t.code,{children:"delete"})," operations that should have been performed in one transaction are spread out over multiple transactions, resulting in one transaction not committing after executing the ",(0,o.jsx)(t.code,{children:"select for update"}),", and one transaction waiting for a lock when executing the ",(0,o.jsx)(t.code,{children:"delete"})," until the timeout expires, and then the lock will not lock until the timeout expires. until it times out."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"proxy-description",children:"Proxy description"}),"\n",(0,o.jsxs)(t.p,{children:["This is a layer of DataSource proxying that overrides some methods. For example, the ",(0,o.jsx)(t.code,{children:"getConnection"})," method does not return a ",(0,o.jsx)(t.code,{children:"Connection"}),", but a ",(0,o.jsx)(t.code,{children:"ConnectionProxy"}),", and so on."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"// DataSourceProxy\n\npublic DataSourceProxy(DataSource targetDataSource) {\nthis(targetDataSource, DEFAULT_RESOURCE_GROUP_ID);\n}\n\nprivate void init(DataSource dataSource, String resourceGroupId) {\nDefaultResourceManager.get().registerResource(this); }\n}\n\npublic Connection getPlainConnection() throws SQLException {\nreturn targetDataSource.getConnection(); } public Connection getPlainConnection(); return targetDataSource.\n}\n\n@Override\npublic ConnectionProxy getConnection() throws SQLException {\nConnection targetConnection = targetDataSource.getConnection(); } @Override public ConnectionProxy getConnection(); }\nreturn new ConnectionProxy(this, targetConnection);\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"manual-proxy",children:"Manual Proxy"}),"\n",(0,o.jsxs)(t.p,{children:["That is, manually inject a ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," as follows"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'@Bean\npublic DataSource druidDataSource() {\nreturn new DruidDataSource()\n}\n\n@Primary\n@Bean("dataSource")\npublic DataSourceProxy dataSource(DataSource druidDataSource) {\nreturn new DataSourceProxy(druidDataSource); }\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"autoproxy",children:"AutoProxy"}),"\n",(0,o.jsxs)(t.p,{children:["Create a proxy class for ",(0,o.jsx)(t.code,{children:"DataSource"}),", get ",(0,o.jsx)(t.code,{children:"DataSourceProxy (create it if it doesn't exist)"})," based on ",(0,o.jsx)(t.code,{children:"DataSource"})," inside the proxy class, and then call the relevant methods of ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),". The core logic is in ",(0,o.jsx)(t.code,{children:"SeataAutoDataSourceProxyCreator"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'public class SeataAutoDataSourceProxyCreator extends AbstractAutoProxyCreator {\nprivate static final Logger LOGGER = LoggerFactory.getLogger(SeataAutoDataSourceProxyCreator.class);\nprivate final String[] excludes; private final Advisor advisor = new SeataAutoDataSourceProxyCreator.class\nprivate final Advisor advisor = new DefaultIntroductionAdvisor(new SeataAutoDataSourceProxyAdvice());\n\n    public SeataAutoDataSourceProxyCreator(boolean useJdkProxy, String[] excludes) {\n        this.excludes = excludes;\n        setProxyTargetClass(!useJdkProxy);\n    }\n\n    @Override\n    protected Object[] getAdvicesAndAdvisorsForBean(Class<? > beanClass, String beanName, TargetSource customTargetSource) throws BeansException {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info("Auto proxy of [{}]", beanName);\n        }\n        return new Object[]{advisor};\n    }\n\n    @Override\n    protected boolean shouldSkip(Class<? > beanClass, String beanName) {\n        return SeataProxy.class.isAssignableFrom(beanClass) ||\n                DataSourceProxy.class.isAssignableFrom(beanClass) ||\n                !DataSource.class.isAssignableFrom(beanClass) ||\n                Arrays.asList(excludes).contains(beanClass.getName());\n    }\n}\n\npublic class SeataAutoDataSourceProxyAdvice implements MethodInterceptor, IntroductionInfo {\n}\npublic Object invoke(MethodInvocation invocation) throws Throwable {\nDataSourceProxy dataSourceProxy = DataSourceProxyHolder.get().putDataSource((DataSource) invocation.getThis());\nMethod method = invocation.getMethod();\nObject[] args = invocation.getArguments();\nMethod m = BeanUtils.findDeclaredMethod(DataSourceProxy.class, method.getName(), method.getParameterTypes());\nif (m ! = null) {\nreturn m.invoke(dataSourceProxy, args); } else { m.invoke(DataSourceProxy.class, method.getName(), method.getParameterTypes())\n} else {\nreturn invocation.proceed();\n}\n}\n\n    @Override\n    public Class<? >[] getInterfaces() {\n        return new Class[]{SeataProxy.class};\n    }\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"data-source-multi-level-proxy",children:"Data Source Multi-Level Proxy"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'@Bean.\n@DependsOn("strangeAdapter")\npublic DataSource druidDataSource(StrangeAdapter strangeAdapter) {\ndruidDataSource(StrangeAdapter strangeAdapter) { doxx\nreturn new DruidDataSource()\n}\n\n@Primary\n@Bean("dataSource")\npublic DataSourceProxy dataSource(DataSource druidDataSource) {\nreturn new DataSourceProxy(druidDataSource); }\n}\n'})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["First we inject two ",(0,o.jsx)(t.code,{children:"DataSources"})," into the configuration class: ",(0,o.jsx)(t.code,{children:"DruidDataSource"})," and ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),", where ",(0,o.jsx)(t.code,{children:"DruidDataSource"})," is used as the targetDataSource attribute of ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," and ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," is used as the targetDataSource attribute of ",(0,o.jsx)(t.code,{children:"DruidDataSource"}),". DataSourceProxy",(0,o.jsx)(t.code,{children:"is declared using the"}),"@Primary` annotation."]}),"\n",(0,o.jsxs)(t.li,{children:["The application has automatic data source proxying enabled by default, so when calling methods related to ",(0,o.jsx)(t.code,{children:"DruidDataSource"}),", a corresponding data source proxy ",(0,o.jsx)(t.code,{children:"DataSourceProxy2"})," will be created for ",(0,o.jsx)(t.code,{children:"DruidDataSource"}),"."]}),"\n",(0,o.jsx)(t.li,{children:"What happens when we want to get a Connection in our application?"}),"\n",(0,o.jsxs)(t.li,{children:["first get a ",(0,o.jsx)(t.code,{children:"DataSource"}),", because the ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," is ",(0,o.jsx)(t.code,{children:"Primary"}),", so we get a ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),". 2. based on the ",(0,o.jsx)(t.code,{children:"DataSource"}),", we create a corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy2"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["get a ",(0,o.jsx)(t.code,{children:"Connection"})," based on the ",(0,o.jsx)(t.code,{children:"DataSource"}),", i.e. get the ",(0,o.jsx)(t.code,{children:"Connection"})," through the ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),". At this time, we will first call the getConnection method of ",(0,o.jsx)(t.code,{children:"targetDataSource"}),", i.e. DruidDataSource",(0,o.jsx)(t.code,{children:", but since the cutover will intercept "}),"DruidDataSource",(0,o.jsx)(t.code,{children:", according to the interception logic in step 2, we can know that a "}),"DataSourceProxy2",(0,o.jsx)(t.code,{children:"will be created automatically, and then call the"}),"DataSourceProxy2",(0,o.jsx)(t.code,{children:". Then call "}),"DataSourceProxy2#getConnection",(0,o.jsx)(t.code,{children:", and then call "}),"DruidDataSource#getConnection",(0,o.jsx)(t.code,{children:". This results in a two-tier proxy, and the returned "}),"Connection",(0,o.jsx)(t.code,{children:"is also a two-tier"}),"ConnectionProxy`."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac0b91bd8fc4c48aa68afd5c58a42d5~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.p,{children:["The above is actually the modified proxy logic, Seata's default autoproxy will proxy the ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," again, the consequence is that there is one more layer of proxy at this time the corresponding diagram is as follows"]}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837aa0462d994e9a8614707c6a50b5ae~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsx)(t.p,{children:"The two problems that can result from multiple layers of proxies for a data source are summarised at the beginning of the article, with case studies below."}),"\n",(0,o.jsx)(t.h1,{id:"branching-transaction-commits",children:"Branching Transaction Commits"}),"\n",(0,o.jsxs)(t.p,{children:["What happens when the corresponding method is executed through the ",(0,o.jsx)(t.code,{children:"ConnectionProxy"}),"? Let's take an example of a branching transaction commit involving an update operation:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Execute ",(0,o.jsx)(t.code,{children:"ConnectionProxy#prepareStatement"}),", which returns a ",(0,o.jsx)(t.code,{children:"PreparedStatementProxy"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Execute ",(0,o.jsx)(t.code,{children:"PreparedStatementProxy#executeUpdate"}),", ",(0,o.jsx)(t.code,{children:"PreparedStatementProxy#executeUpdate"})," will probably do two things: execute the business SQL and commit the undo_log."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"commit-business-sql",children:"Commit business SQL"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"// ExecuteTemplate#execute\nif (sqlRecognizers.size() == 1) {\n   SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n   switch (sqlRecognizer.getSQLType()) {\n       case INSERT.\n           executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType, new Class[]{StatementLoader.load(InsertExecutor.class, dbType)) { case INSERT.\n                   new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class}, new\n                   new Object[]{statementProxy, statementCallback, sqlRecognizer});\n           statementProxy, statementCallback, sqlRecognizer}); break;\n       case UPDATE: executor = new UpdateExecutor\n           executor = new UpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer); break; case UPDATE.\n           break;\n       case DELETE.\n           executor = new DeleteExecutor<>(statementProxy, statementCallback, sqlRecognizer); break; case DELETE.\n           break; case SELECT_FOR_UPDATE.\n       case SELECT_FOR_UPDATE: executor = new SelectForUpdate.\n           executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer); break; case SELECT_FOR_UPDATE.\n           break; break\n       default: executor = new PlainExecutor\n           executor = new PlainExecutor<>(statementProxy, statementCallback); break; default.\n           break;\n   }\n} else {\n   executor = new MultiExecutor<>(statementProxy, statementCallback, sqlRecognizers); } else { executor = new MultiExecutor<>(statementProxy, statementCallback, sqlRecognizers); }\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"The main process is: first execute the business SQL, then execute the commit method of the ConnectionProxy, in which the corresponding undo_log SQL will be executed for us, and then commit the transaction."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"PreparedStatementProxy#executeUpdate =>\nExecuteTemplate#execute =>\nBaseTransactionalExecutor#execute =>\nAbstractDMLBaseExecutor#doExecute =>\nAbstractDMLBaseExecutor#executeAutoCommitTrue =>\nAbstractDMLBaseExecutor#executeAutoCommitFalse => In this step, the statementCallback#execute method will be triggered, i.e. the native PreparedStatement#executeUpdate method will be called.\nConnectionProxy#commit\nConnectionProxy#processGlobalTransactionCommit\n"})}),"\n",(0,o.jsx)(t.h2,{id:"undo_log-insert",children:"UNDO_LOG insert"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'// ConnectionProxy#processGlobalTransactionCommit\nprivate void processGlobalTransactionCommit() throws SQLException {\n   try {\n       // Register for a branch transaction, simply understand that a request is sent to the server, and then the server inserts a record into the branch_table table.\n       register();\n   } catch (TransactionException e) {\n       // If there is no for update sql, it will register directly before commit, then not only insert a branch record, but also lock information for the competition, the following exception is generally thrown in the registration did not get the lock, generally is pure update statement concurrency will trigger the competition lock failure exception @FUNKYE\n       recognizeLockKeyConflictException(e, context.buildLockKeys());\n   }\n   try {\n       // undo_log handling, expect targetConnection handling @1\n       UndoLogManagerFactory.getUndoLogManager(this.getDbType()).flushUndoLogs(this); // Commit local transaction, expect targetConnection.\n\n       // Commit the local transaction, expecting it to be handled by targetConnection @2\n       targetConnection.commit(); } catch (Throwable ex)\n   } catch (Throwable ex) {\n       LOGGER.error("process connectionProxy commit error: {}", ex.getMessage(), ex); report(false); }\n       report(false); } catch (Throwable ex); }\n       throw new SQLException(ex);\n   }\n   if (IS_REPORT_SUCCESS_ENABLE) {\n       report(true); }\n   }\n   context.reset();\n}\n'})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["undo_log processing @1, parses the ",(0,o.jsx)(t.code,{children:"undo_log"})," involved in the current transaction branch and writes it to the database using ",(0,o.jsx)(t.code,{children:"TargetConnection"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'   public void flushUndoLogs(ConnectionProxy cp) throws SQLException {\n   ConnectionContext connectionContext = cp.getContext();\n   if (!connectionContext.hasUndoLog()) {\n   return;\n   }\n\n   String xid = connectionContext.getXid(); long branchId = connectionContext.hasUndoLog(); { return; }\n   long branchId = connectionContext.getBranchId(); }\n\n   BranchUndoLog branchUndoLog = new BranchUndoLog(); branchUndoLog.setBranchId = connectionContext.getBranchId(); }\n   branchUndoLog.setXid(xid); branchUndoLog.\n   branchUndoLog.setBranchId(branchId); branchUndoLog.\n   branchUndoLog.setSqlUndoLogs(connectionContext.getUndoItems());\n\n   UndoLogParser parser = UndoLogParserFactory.getInstance();\n   byte[] undoLogContent = parser.encode(branchUndoLog);\n\n   if (LOGGER.isDebugEnabled()) {\n   LOGGER.debug("Flushing UNDO LOG: {}", new String(undoLogContent, Constants.DEFAULT_CHARSET));\n   }\n\n   insertUndoLogWithNormal(xid, branchId, buildContext(parser.getName()), undoLogContent,cp.getTargetConnection());\n   }\n'})}),"\n",(0,o.jsxs)(t.ol,{start:"2",children:["\n",(0,o.jsxs)(t.li,{children:["Commit local transaction @2, i.e., commit the transaction via ",(0,o.jsx)(t.code,{children:"TargetConnection"}),". That is, the same ",(0,o.jsx)(t.code,{children:"TargetConnection"})," is used for ",(0,o.jsx)(t.code,{children:"service SQL execution"}),", ",(0,o.jsx)(t.code,{children:"undo_log write"}),", and ",(0,o.jsx)(t.code,{children:"i.e. transaction commit"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"lcn's built-in database solution, lcn is to write undolog to his embedded h2 (I forget if it's this one) database, at this time it will become two local transactions, one is h2's undolog insertion transaction, one is the transaction of the business database, if the business database is abnormal after the insertion of the h2, lcn's solution will be data redundancy, roll back the data. data is the same, delete undolog and rollback business data is not a local transaction.\nBut the advantage of lcn is the invasion of small, do not need to add another undolog table. Thanks to @FUNKYE for the advice, I don't know much about lcn, I'll look into it when I get a chance!"}),"\n"]}),"\n",(0,o.jsx)(t.h1,{id:"branch-transaction-rollback",children:"Branch Transaction Rollback"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Server sends a rollback request to Client. 2."}),"\n",(0,o.jsxs)(t.li,{children:["Client receives the request from Server, and after a series of processing, it ends up in the ",(0,o.jsx)(t.code,{children:"DataSourceManager#branchRollback"})," method. 3."]}),"\n",(0,o.jsxs)(t.li,{children:["first according to the resourceId from the ",(0,o.jsx)(t.code,{children:"DataSourceManager.dataSourceCache"})," to get the corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),", at this time for the ",(0,o.jsx)(t.code,{children:"masterSlaveProxy"})," (rollback stage we do not test the proxy data source, simple and direct, anyway, the final get all the ",(0,o.jsx)(t.code,{children:"TragetConnection"}),")"]}),"\n",(0,o.jsxs)(t.li,{children:["According to the xid and branchId sent from the Server side to find the corresponding undo_log and parse its ",(0,o.jsx)(t.code,{children:"rollback_info"})," attribute, each undo_log may be parsed out of more than one ",(0,o.jsx)(t.code,{children:"SQLUndoLog"}),", each ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," can be interpreted as an operation. For example, if a branch transaction updates table A and then table B, the undo_log generated for the branch transaction contains two ",(0,o.jsx)(t.code,{children:"SQLUndoLog"}),"s: the first ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," corresponds to the snapshot before and after the update of table A; the second ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," corresponds to the snapshot before and after the update of table B."]}),"\n",(0,o.jsxs)(t.li,{children:["for each ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," execute the corresponding rollback operation, for example, a ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," corresponds to the operation ",(0,o.jsx)(t.code,{children:"INSERT"}),", then its corresponding rollback operation is ",(0,o.jsx)(t.code,{children:"DELETE"}),"."]}),"\n",(0,o.jsx)(t.li,{children:"Delete the undo_log based on the xid and branchId."}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'// AbstractUndoLogManager#undo removes some non-critical code\n\npublic void undo(DataSourceProxy dataSourceProxy, String xid, long branchId) throws TransactionException {\n   Connection conn = null;\n   ResultSet rs = null;\n   PreparedStatement selectPST = null;\n   boolean originalAutoCommit = true; for (; ; ) {\n\n   for (; ; ) {\n       try {\n           // Get the connection to the original data source, we don\'t care about the proxy data source in the rollback phase, we\'ll end up with the TargetConnection.\n           conn = dataSourceProxy.getPlainConnection(); // Get the connection to the native data source.\n\n           // Put the rollback operation in a local transaction and commit it manually, making sure that the final business SQL operation is committed along with the undo_log delete operation.\n           if (originalAutoCommit = conn.getAutoCommit()) {\n               conn.setAutoCommit(false);\n           }\n\n           // Query undo_log based on xid and branchId, note the SQL statement SELECT * FROM undo_log WHERE branch_id = ? AND xid = ? FOR UPDATE\n           selectPST = conn.prepareStatement(SELECT_UNDO_LOG_SQL);\n           selectPST.setLong(1, branchId); selectPST.setString(1, branchId); selectPST.setString(1, branchId)\n           selectPST.setString(2, xid);\n           rs = selectPST.executeQuery(); boolean exists = false; rs = selectPST.\n\n           boolean exists = false; while (rs.next())\n           while (rs.next()) {\n               exists = true; boolean exists = false; while (rs.next()) {\n               // status == 1 undo_log is not processed, related to anti-suspension\n               if (!canUndo(state)) {\n                   return; }\n               }\n\n               // Parsing the undo_log\n               byte[] rollbackInfo = getRollbackInfo(rs); // Parsing the undo_log.\n               BranchUndoLog branchUndoLog = UndoLogParserFactory.getInstance(serialiser).decode(rollbackInfo);\n               try {\n                   setCurrentSerializer(parser.getName());\n                   List<SQLUndoLog> sqlUndoLogs = branchUndoLog.getSqlUndoLogs(); if (sqlUndoLog.getSqlUndoLogs(parser.getName()); } }\n                   if (sqlUndoLogs.size() > 1) {\n                       Collections.reverse(sqlUndoLogs);\n                   }\n                   for (SQLUndoLog sqlUndoLog : sqlUndoLogs) {\n                       AbstractUndoExecutor undoExecutor = UndoExecutorFactory.getUndoExecutor(dataSourceProxy.getDbType(), sqlUndoLog);\n                       // Execute the corresponding rollback operation\n                       undoExecutor.executeOn(conn);\n                   }\n               }\n           }\n\n           // If (exists) { undoExecutor.executeOn(conn); }\n           if (exists) {\n               LOGGER.error("\\n delete from undo_log where xid={} AND branchId={} \\n", xid, branchId);\n               deleteUndoLog(xid, branchId, conn);\n               conn.commit();\n           // and anti-suspension related If no undo_log is found based on xid and branchId, it means that there is an exception in the branch transaction: for example, the business process timed out, resulting in a global transaction rollback, but the business undo_log was not inserted at that time.\n           } else {\n               LOGGER.error("\\n insert into undo_log xid={},branchId={} \\n", xid, branchId);\n               insertUndoLogWithGlobalFinished(xid, branchId, UndoLogParserFactory.getInstance(), conn);\n               conn.commit();\n           }\n           return; }\n       } catch (Throwable e) {\n           throw new BranchTransactionException(BranchRollbackFailed_Retriable, String\n               .format("Branch session rollback failed and try again later xid = %s branchId = %s %s", xid,branchId, e.getMessage()), e); }\n       }\n   }\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"There are several notes:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["rollback does not take into account data source proxying, and ends up using ",(0,o.jsx)(t.code,{children:"TargetConnection"}),"."]}),"\n",(0,o.jsx)(t.li,{children:"set atuoCommit to false, i.e. you need to commit the transaction manually"}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"for update"})," is added when querying the undo_log based on xid and branchId, i.e. the transaction will hold the lock for this undo_log until all rollbacks are complete, as it is not until they are done that the"]}),"\n"]}),"\n",(0,o.jsx)(t.h1,{id:"multi-tier-proxy-issues",children:"Multi-Tier Proxy Issues"}),"\n",(0,o.jsx)(t.p,{children:"Several issues that can be caused by multi-tier proxying of data sources have been mentioned at the beginning of the article, focusing on analysing why the above issues are caused:"}),"\n",(0,o.jsx)(t.h2,{id:"impact-on-branch-transaction-commits",children:"Impact on branch transaction commits"}),"\n",(0,o.jsxs)(t.p,{children:["Let's start by analysing what happens if we use a two-tier proxy. Let's analyse it from two aspects: ",(0,o.jsx)(t.code,{children:"business SQL"})," and ",(0,o.jsx)(t.code,{children:"undo_log"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"business SQL"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"   PreparedStatementProxy1.executeUpdate =>\n   statementCallback#executeUpdate(PreparedStatementProxy2#executeUpdate) =>\n   PreparedStatement#executeUpdate\n"})}),"\n",(0,o.jsxs)(t.p,{children:["It doesn't seem to matter, it's just an extra loop, and it's still executed through ",(0,o.jsx)(t.code,{children:"PreparedStatement"})," in the end."]}),"\n",(0,o.jsxs)(t.ol,{start:"2",children:["\n",(0,o.jsx)(t.li,{children:"undo_log"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"ConnectionProxy1#getTargetConnection ->\nConnectionProxy2#prepareStatement ->\nPreparedStatementProxy2#executeUpdate ->\nPreparedStatement#executeUpdate (native undo_log write, before generating undo_log2 (the undo_log of undo_log) for that undo_log) ->\nConnectionProxy2#commit ->\nConnectionProxy2#processGlobalTransactionCommit(write undo_log2) ->\nConnectionProxy2#getTargetConnection ->\nTargetConnection#prepareStatement ->\nPreparedStatement#executeUpdate\n"})}),"\n",(0,o.jsx)(t.h2,{id:"impact-on-branch-transaction-rollback",children:"Impact on branch transaction rollback"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Why isn't the undo_log deleted after a transaction rollback?"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["It is not actually not deleted. As I said before, the two-tier proxy causes the ",(0,o.jsx)(t.code,{children:"undo_log"})," to be treated as a branch transaction, so it generates an undo_log for that ",(0,o.jsx)(t.code,{children:"undo_log"})," (assuming it's ",(0,o.jsx)(t.code,{children:"undo_log2"}),"), and ",(0,o.jsx)(t.code,{children:"undo_log2"})," is generated wrongly (which is fine, it should be generated this way), which results in the ",(0,o.jsx)(t.code,{children:"business-table-associated undo_log"})," being deleted when rolling back. This leads to a rollback that deletes the ",(0,o.jsx)(t.code,{children:"undo_log"})," associated with the ",(0,o.jsx)(t.code,{children:"business table"}),", which ultimately leads to the ",(0,o.jsx)(t.code,{children:"business table corresponding to the transaction branch"})," rolling back to find that the undo_log does not exist, thus generating one more undo_log with a status of 1."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Before the rollback"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"// undo_log\n84 59734070967644161 172.16.120.59:23004:59734061438185472 serializer=jackson 1.1KB 0\n85 59734075254222849 172.16.120.59:23004:59734061438185472 serializer=jackson 4.0KB 0\n\n// branch_table\n59734070967644161 172.16.120.59:23004:59734061438185472 jdbc:mysql://172.16.248.10:3306/tuya_middleware\n59734075254222849 172.16.120.59:23004:59734061438185472 jdbc:mysql://172.16.248.10:3306/tuya_middleware\n\n// lock_table\njdbc:mysql://xx^^^seata_storage^^^1 59734070967644161 jdbc:mysql://172.16.248.10:3306/tuya_middleware seata_storage 1\njdbc:mysql://xx^^^^undo_log^^^^84 59734075254222849 jdbc:mysql://172.16.248.10:3306/tuya_middleware undo_log 84\n"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"After the rollback"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"// An undo_log with status 1 was generated, corresponding to the log: undo_log added with GlobalFinished\n86 59734070967644161 172.16.120.59:23004:59734061438185472 serializer=jackson 1.0Byte 1\n"})}),"\n",(0,o.jsx)(t.h3,{id:"problem-analysis",children:"Problem analysis"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"find the corresponding undo_log log based on xid and branchId"}),"\n",(0,o.jsxs)(t.li,{children:["parse the undo_log, mainly its ",(0,o.jsx)(t.code,{children:"rollback_info"})," field, ",(0,o.jsx)(t.code,{children:"rollback_info"})," is a ",(0,o.jsx)(t.code,{children:"SQLUndoLog collection"}),", each ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," corresponds to an operation, which contains a snapshot before and after the operation, and then perform a corresponding rollback"]}),"\n",(0,o.jsx)(t.li,{children:"Delete undo_log logs based on xid and branchId."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Because of the two-tier proxy problem, an undo_log becomes a branch transaction, so when a rollback occurs, we also need to rollback the undo_log branch transaction:\n1, first according to the xid and branchId to find the corresponding ",(0,o.jsx)(t.code,{children:"undo_log"})," and parse its ",(0,o.jsx)(t.code,{children:"rollback_info"})," attribute, here the parsed rollback_info contains two ",(0,o.jsx)(t.code,{children:"SQLUndoLog"}),". Why are there two?"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["If you think about it, you can understand that the first layer of proxy operations on ",(0,o.jsx)(t.code,{children:"seata_storage"})," are put into the cache, which should be cleared after execution, but because of the two-tier proxy, the process is not finished at this time. When it's the second tier proxy's turn to operate on ",(0,o.jsx)(t.code,{children:"undo_log"}),", it puts that operation into the cache, and at that point there are two operations in the cache, ",(0,o.jsx)(t.code,{children:"UPDATE"})," for ",(0,o.jsx)(t.code,{children:"seata_storage"})," and ",(0,o.jsx)(t.code,{children:"INSERT"})," for ",(0,o.jsx)(t.code,{children:"undo_log"}),". So it's easy to see why the ",(0,o.jsx)(t.code,{children:"undo_log operation"})," is extra large (4KB) because it has two operations in its ",(0,o.jsx)(t.code,{children:"rollback_info"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["One thing to note is that the first ",(0,o.jsx)(t.code,{children:"SQLUndoLog"})," corresponds to the after snapshot, which has branchId=",(0,o.jsx)(t.code,{children:"59734070967644161"})," pk=",(0,o.jsx)(t.code,{children:"84"}),", i.e., branchId",(0,o.jsx)(t.code,{children:"corresponding to the"}),"seata_storage branch and ",(0,o.jsx)(t.code,{children:"undo_log corresponding to the "}),"seata_storage PK",(0,o.jsx)(t.code,{children:". In other words, the undo_log rollback deletes the "}),"seata_storage corresponding undo_log`.\nHow to delete the undo_log itself? In the next logic, it will be deleted according to xid and branchId."]}),"\n",(0,o.jsxs)(t.ol,{start:"2",children:["\n",(0,o.jsxs)(t.li,{children:["Parsing the first ",(0,o.jsx)(t.code,{children:"SQLUndoLog"}),", it corresponds to the INSERT",(0,o.jsx)(t.code,{children:"operation of"}),"undo_log",(0,o.jsx)(t.code,{children:", so its corresponding rollback operation is "}),"DELETE",(0,o.jsx)(t.code,{children:". Because "}),"undo_log",(0,o.jsx)(t.code,{children:"is treated as a business table at this point. So this step will delete the"}),"59734075254222849",(0,o.jsx)(t.code,{children:"corresponding to the"}),"undo_log",(0,o.jsx)(t.code,{children:", **but this is actually the corresponding business table corresponding to the corresponding "}),"undo_log`**."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["3, parse the second ",(0,o.jsx)(t.code,{children:"SQLUndoLog"}),", at this time corresponds to the ",(0,o.jsx)(t.code,{children:"seata_storage UPDATE"})," operation, this time will be through the snapshot of the ",(0,o.jsx)(t.code,{children:"seata_storage"})," corresponding to the recovery of records"]}),"\n",(0,o.jsxs)(t.p,{children:["4\u3001Delete the undo_log log according to xid and branchId, here the deletion is the undo_log of ",(0,o.jsx)(t.code,{children:"undo_log , i.e. undo_log2"}),". So, by this point, both undo_logs have been deleted."]}),"\n",(0,o.jsxs)(t.ol,{start:"5",children:["\n",(0,o.jsxs)(t.li,{children:["Next, roll back ",(0,o.jsx)(t.code,{children:"seata_storage"}),", because at this time its corresponding undo_log has been deleted in step 2, so at this time can not check the undo_log, and then regenerate a ",(0,o.jsx)(t.code,{children:"status == 1 undo_log"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h1,{id:"case-study",children:"Case Study"}),"\n",(0,o.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Three data sources are configured: two physical data sources and one logical data source, but the corresponding connection addresses of the two physical data sources are the same. Is this interesting?"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'@Bean("dsMaster")\nDynamicDataSource dsMaster() {\n   return new DynamicDataSource(masterDsRoute);\n}\n\n@Bean("dsSlave")\nDynamicDataSource dsSlave() {\n   return new DynamicDataSource(slaveDsRoute); }\n}\n\n@Primary\n@Bean("masterSlave")\nDataSource masterSlave(@Qualifier("dsMaster") DataSource dataSourceMaster,\n                       @Qualifier("dsSlave") DataSource dataSourceSlave) throws SQLException {\n   Map<String, DataSource> dataSourceMap = new HashMap<>(2);\n   // Master database\n   dataSourceMap.put("dsMaster", dataSourceMaster);\n   //slave\n   dataSourceMap.put("dsSlave", dataSourceSlave); // Configure read/write separation rules.\n   // Configure read/write separation rules\n   MasterSlaveRuleConfiguration masterSlaveRuleConfig = new MasterSlaveRuleConfiguration(\n           "masterSlave", "dsMaster", Lists.newArrayList("dsSlave")\n   );\n   Properties shardingProperties = new Properties();\n   shardingProperties.setProperty("sql.show", "true");\n   shardingProperties.setProperty("sql.simple", "true");\n   // Get the data source object\n   DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap, masterSlaveRuleConfig, shardingProperties);\n   log.info("datasource initialised!");\n   return dataSource;\u02da\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e05c8fc0294a8caf4d0883a4676750~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.p,{children:["2, open seata's data source dynamic proxy, according to seata's data source proxy logic can be known, will eventually generate three proxy data sources, the relationship between the native data source and the proxy data source is cached in the ",(0,o.jsx)(t.code,{children:"DataSourceProxyHolder.dataSourceProxyMap"}),", if the native data source and the proxy data source corresponds to the relationship is as follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"dsMaster(DynamicDataSource) => dsMasterProxy(DataSourceProxy)\ndsSlave(DynamicDataSource) => dsSlaveProxy(DataSourceProxy)\nmasterSlave(MasterSlaveDataSource) => masterSlaveProxy(DataSourceProxy)\n"})}),"\n",(0,o.jsx)(t.p,{children:"So, ultimately, the three data sources that exist in the IOC container are: dsMasterProxy, dsSlaveProxy, masterSlaveProxy. According to the @Primary feature, when we get a DataSource from the container, the default data source returned is the proxy masterSlaveProxy."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"I haven't studied shardingjdbc specifically, but just guessed its working mechanism based on the code I saw during the debug."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"masterSlaveProxy"})," can be seen as ",(0,o.jsx)(t.code,{children:"MasterSlaveDataSource"})," wrapped by DataSourceProxy. We can venture to guess that ",(0,o.jsx)(t.code,{children:"MasterSlaveDataSource"})," is not a physical data source, but a logical data source, which can simply be thought of as containing routing logic. When we get a connection, we will use the routing rules inside to select a specific physical data source, and then get a real connection through that physical data source.\nThe routing rules should be able to be defined by yourself. According to the phenomenon observed when debugging, the default routing rules should be:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"for select read operations, will be routed to the slave library, that is, our dsSlave"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"for update write operations, will be routed to the master library, that is, our dsMaster"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["When each DataSourceProxy is initialised, it will parse the connection address of that real DataSource, and then maintain that ",(0,o.jsx)(t.code,{children:"connection address and the DataSourceProxy itself"})," in ",(0,o.jsx)(t.code,{children:"DataSourceManager.dataSourceCache"}),". The ",(0,o.jsx)(t.code,{children:"DataSourceManager.dataSourceCache"})," is used for rollback: when rolling back, it finds the corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," based on the connection address, and then does the rollback operation based on that ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),".\nBut we can find this problem, these three data sources are resolved to the same connection address, that is, the key is duplicated, so in the ",(0,o.jsx)(t.code,{children:"DataSourceManager.dataSourceCache"}),", when the connection place is the same, after the registration of the data source will overwrite the existing one. That is: ",(0,o.jsx)(t.code,{children:"DataSourceManager.dataSourceCache"})," ultimately exists ",(0,o.jsx)(t.code,{children:"masterSlaveProxy"}),", that is to say, will ultimately be rolled back through the ",(0,o.jsx)(t.code,{children:"masterSlaveProxy"}),", this point is very important."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["4, the table involved: very simple, we expect a business table ",(0,o.jsx)(t.code,{children:"seata_account"}),", but because of the duplicate proxy problem, resulting in seata will undo_log also as a business table"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"seata_account"}),"\n",(0,o.jsx)(t.li,{children:"undo_log"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"OK, here's a brief background, moving on to the Seata session"}),"\n",(0,o.jsx)(t.h2,{id:"requirements",children:"Requirements"}),"\n",(0,o.jsxs)(t.p,{children:["We have a simple requirement to perform a simple update operation inside a branch transaction to update the count value of ",(0,o.jsx)(t.code,{children:"seata_account"}),". After the update, manually throw an exception that triggers a rollback of the global transaction.\nTo make it easier to troubleshoot and reduce interference, we use one branch transaction in the global transaction and no other branch transactions.SQL is as follows."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"update seata_account set count = count - 1 where id = 100;\n"})}),"\n",(0,o.jsx)(t.h2,{id:"problems",children:"Problems"}),"\n",(0,o.jsx)(t.p,{children:"Client: In the console log, the following logs are printed over and over again"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["the above logs are printed at 20s intervals, and I checked the value of the ",(0,o.jsx)(t.code,{children:"innodb_lock_wait_timeout"})," property of the database, and it happens to be 20, which means that every time a rollback request comes through, the rollback fails because of the timeout for acquiring the lock (20)."]}),"\n",(0,o.jsx)(t.li,{children:"Why is it not printed once after 20s? Because the server side will have a timer to process the rollback request."}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"// Branch rollback starts\nBranch rollback start: 172.16.120.59:23004:59991911632711680 59991915571163137 jdbc:mysql://172.16.248.10:3306/tuya_middleware\n\n// undo_log transaction branch The original action corresponds to insert, so it rolls back to delete.\nundoSQL undoSQL=DELETE FROM undo_log WHERE id = ?  and PK=[[id,139]]\n// Since the corresponding operation of the first-level agent is also in the context, when the undo_log branch transaction commits, the corresponding undo_log contains two actions\nundoSQL undoSQL=UPDATE seata_account SET money = ? WHERE id = ?  and PK=[[id,1]].\n\n// After the branch transaction has been rolled back, delete the corresponding undo_log for that branch transaction\ndelete from undo_log where xid=172.16.120.59:23004:59991911632711680 AND branchId=59991915571163137\n\n// Threw an exception indicating that the rollback failed because `Lock wait timeout exceeded`, and failed when deleting the undo_log based on the xid and branchId because a lock acquisition timeout occurred, indicating that there was another operation that held a lock on the record that was not released.\nbranchRollback failed. branchType:[AT], xid:[172.16.120.59:23004:59991911632711680], branchId:[59991915571163137], resourceId:[jdbc. mysql://172.16.248.10:3306/tuya_middleware], applicationData:[null]. reason:[Branch session rollback failed and try again later xid = 172.16.120.59:23004:59991911632711680 branchId = 59991915571163137 Lock wait timeout exceeded; try restarting transaction]\n"})}),"\n",(0,o.jsx)(t.p,{children:"Server: the following log is printed every 20s, indicating that the server is constantly retrying to send a rollback request"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Rollback branch transaction failed and will retry, xid = 172.16.120.59:23004:59991911632711680 branchId = 59991915571163137\n"})}),"\n",(0,o.jsx)(t.p,{children:"The SQL involved in the process is roughly as follows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"1. SELECT * FROM undo_log WHERE branch_id = ? AND xid = ? FOR UPDATE slaveDS\n2. SELECT * FROM undo_log WHERE (id ) in ( (?)  ) slaveDS\n3. DELETE FROM undo_log WHERE id = ?                                masterDS\n4. SELECT * FROM seata_account WHERE (id ) in ( (?)  ) masterDS\n5. UPDATE seata_account SET money = ? WHERE id = ?                      masterDS\n6. DELETE FROM undo_log WHERE branch_id = ? AND xid = ?                 masterDS\n"})}),"\n",(0,o.jsx)(t.p,{children:"At this point, check the database transaction status, lock status, lock wait relationship\n1, check the current transaction being executed"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"SELECT * FROM information_schema.INNODB_TRX.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9852b91a9949f781e1f90bffe95fbf~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.ol,{start:"2",children:["\n",(0,o.jsx)(t.li,{children:"Check the current lock status"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"SELECT * FROM information_schema.INNODB_LOCKs;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a29748a3af34e7c90e3aa7cb78564bc~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.ol,{start:"3",children:["\n",(0,o.jsx)(t.li,{children:"Check the current lock wait relationship"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"SELECT * FROM information_schema.INNODB_LOCK_waits;\n\nSELECT\n block_trx.trx_mysql_thread_id AS sessionID that already holds a lock, request_trx.\n request_trx.trx_mysql_thread_id AS the sessionID that is requesting the lock,\n block_trx.trx_query AS the SQL statement that already holds the lock, request_trx.\n request_trx.trx_query AS the SQL statement for which the lock is being requested,\n waits.blocking_trx_id AS Transaction ID that already holds the lock, waits.requesting_trx.trx_query\n waits.requesting_trx_id AS \u6b63\u5728\u7533\u8bf7\u9501\u7684\u4e8b\u52a1ID,\n waits.requested_lock_id AS the ID of the lock object, waits.\n locks.lock_table AS lock_table, -- table locked by the lock object\n locks.lock_type AS lock_type, -- lock type\n locks.lock_mode AS lock_mode -- lock mode\nFROM\n information_schema.innodb_lock_waits AS waits\n INNER JOIN information_schema.innodb_trx AS block_trx ON waits.blocking_trx_id = block_trx.trx_id\n INNER JOIN information_schema.innodb_trx AS request_trx ON waits.requesting_trx_id = request_trx.trx_id\n INNER JOIN information_schema.innodb_locks AS locks ON waits.requested_lock_id = locks.lock_id;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["! ",(0,o.jsx)(t.a,{href:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ca5b50cab534a69a49c3e470518e3b6~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["the record involved is ",(0,o.jsx)(t.code,{children:"branch_id = 59991915571163137 AND xid = 172.16.120.59:23004:59991911632711680"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["transaction ID ",(0,o.jsx)(t.code,{children:"1539483284"})," holds the lock for this record, but its corresponding SQL is empty, so it should be waiting for a commit."]}),"\n",(0,o.jsxs)(t.li,{children:["transaction ID ",(0,o.jsx)(t.code,{children:"1539483286"})," is trying to acquire a lock on this record, but the logs show that it is waiting for a lock timeout."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Probably a good guess is that ",(0,o.jsx)(t.code,{children:"select for update"})," and ",(0,o.jsx)(t.code,{children:"delete from undo ... "})," are in conflict. According to the logic in the code, these two operations should have been committed in a single transaction, so why have they been separated into two transactions?"]}),"\n",(0,o.jsx)(t.h2,{id:"problem-analysis-1",children:"Problem Analysis"}),"\n",(0,o.jsx)(t.p,{children:"In conjunction with the rollback process described above, let's look at what happens during the rollback of our example."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["first get the data source, at this time dataSourceProxy.getPlainConnection() to get the ",(0,o.jsx)(t.code,{children:"MasterSlaveDataSource"})," data source"]}),"\n",(0,o.jsxs)(t.li,{children:["during the ",(0,o.jsx)(t.code,{children:"select for update"})," operation, get a ",(0,o.jsx)(t.code,{children:"Connection"})," from the ",(0,o.jsx)(t.code,{children:"MasterSlaveDataSource"}),", as I said before, the ",(0,o.jsx)(t.code,{children:"MasterSlaveDataSource"})," is a logical datasource, which has a routing logic, according to the above, this time we get the ",(0,o.jsx)(t.code,{children:"dsSlave"}),"'s ",(0,o.jsx)(t.code,{children:"Connection"}),", and then we get the ",(0,o.jsx)(t.code,{children:"ddsSlave"}),"'s ",(0,o.jsx)(t.code,{children:"Connection"}),". dsSlave",(0,o.jsx)(t.code,{children:"'s "}),"Connection`."]}),"\n",(0,o.jsxs)(t.li,{children:["When executing the ",(0,o.jsx)(t.code,{children:"delete from undo ... 3. When performing the "}),"delete from undo ...' operation, you get the ",(0,o.jsx)(t.code,{children:"Connection"})," from the `dsMaster'."]}),"\n",(0,o.jsxs)(t.li,{children:["Although ",(0,o.jsx)(t.code,{children:"dsSlave"})," and ",(0,o.jsx)(t.code,{children:"dsMaster"})," correspond to the same address, they must be getting different connections, so the two operations must be spread across two transactions."]}),"\n",(0,o.jsxs)(t.li,{children:["the transaction that executes ",(0,o.jsx)(t.code,{children:"select for update"})," will wait until the deletion of the undo_log is complete before committing."]}),"\n",(0,o.jsxs)(t.li,{children:["the transaction that executes ",(0,o.jsx)(t.code,{children:"delete from undo ... The transaction executing "}),"delete from undo ...' waits for the ",(0,o.jsx)(t.code,{children:"select for update"})," transaction to release the lock."]}),"\n",(0,o.jsx)(t.li,{children:"Typical deadlock problem"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"verify-the-conjecture",children:"Verify the conjecture"}),"\n",(0,o.jsx)(t.p,{children:"I tried to verify this problem in two ways:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["change the Seata code from ",(0,o.jsx)(t.code,{children:"select for update"})," to ",(0,o.jsx)(t.code,{children:"select"}),", then the query to undo_log does not need to hold a lock on the record, and will not cause a deadlock."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["change the data source proxy logic, this is the key to the problem, the main cause of the problem is not ",(0,o.jsx)(t.code,{children:"select for update"}),". The main cause of the problem is not ",(0,o.jsx)(t.code,{children:"select for update"}),". The multi-layer proxy problem has already been created before that, and then it will cause the deadlock problem. We should never have proxied the ",(0,o.jsx)(t.code,{children:"masterSlave"})," datasource in the first place. It's just a logical data source, so why proxy it? If we proxy the ",(0,o.jsx)(t.code,{children:"masterSlave"}),", we won't cause multiple layers of proxies, and we won't cause the deadlock problem when deleting the undo_log!"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"final-implementation",children:"Final implementation"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"masterSlave"})," is also a ",(0,o.jsx)(t.code,{children:"DataSource"})," type, how to proxy just ",(0,o.jsx)(t.code,{children:"dsMaster"})," and ",(0,o.jsx)(t.code,{children:"dsSlave"})," but not ",(0,o.jsx)(t.code,{children:"masterSlave"}),"? Observing the ",(0,o.jsx)(t.code,{children:"SeataAutoDataSourceProxyCreator#shouldSkip"})," method, we can solve this problem with the ",(0,o.jsx)(t.code,{children:"excludes"})," attribute of the EnableAutoDataSourceProxy annotation"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"@Override\nprotected boolean shouldSkip(Class<? > beanClass, String beanName) {\nreturn SeataProxy.class.isAssignableFrom(beanClass) ||\nDataSourceProxy.class.isAssignableFrom(beanClass) ||\n!DataSource.class.isAssignableFrom(beanClass) ||\nArrays.asList(excludes).contains(beanClass.getName());\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"i.e.: turn off the data source autoproxy, then add this annotation to the startup class"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'@EnableAutoDataSourceProxy(excludes = {"org.apache.shardingsphere.shardingjdbc.jdbc.core.datasource.MasterSlaveDataSource"})\n'})}),"\n",(0,o.jsx)(t.h1,{id:"autoproxy-optimisation-in-new-releases",children:"Autoproxy optimisation in new releases"}),"\n",(0,o.jsxs)(t.p,{children:["Since ",(0,o.jsx)(t.code,{children:"Seata 1.4.0"})," has not been officially released yet, I'm currently looking at the ",(0,o.jsx)(t.code,{children:"1.4.0-SNAPSHOT"})," version of the code, which is the latest code in the ",(0,o.jsx)(t.code,{children:"ddevelop"})," branch at the current time"]}),"\n",(0,o.jsx)(t.h2,{id:"code-changes",children:"Code changes"}),"\n",(0,o.jsx)(t.p,{children:"The main changes are as follows, but I won't go into too much detail on the minor ones:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"DataSourceProxyHolder"})," adjustment"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"DataSourceProxy"})," adjustment"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"SeataDataSourceBeanPostProcessor"})," is added."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"datasourceproxyholder",children:"DataSourceProxyHolder"}),"\n",(0,o.jsxs)(t.p,{children:["The most significant of the changes to this class are to its ",(0,o.jsx)(t.code,{children:"putDataSource"})," method"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"public SeataDataSourceProxy putDataSource(DataSource dataSource, BranchType dataSourceProxyMode) {\n   DataSource originalDataSource; if (dataSource instanceof SeataDataSource)\n   if (dataSource instanceof SeataDataSourceProxy) {\n       SeataDataSourceProxy dataSourceProxy = (SeataDataSourceProxy) dataSource;\n       // If this is a proxy data source and it is the same as the current application's configured data source proxy mode (AT/XA), then return it directly\n       if (dataSourceProxyMode == dataSourceProxy.getBranchType()) {\n           return (SeataDataSourceProxy)dataSource; }\n       }\n\n       // If it's a proxy data source, and the data source proxy mode (AT/XA) is different from the one configured by the current application, then you need to get its TargetDataSource and create a proxy data source for it.\n       originalDataSource = dataSourceProxy.getTargetDataSource(); } else { dataSourceProxy.getTargetDataSource()\n   } else {\n       originalDataSource = dataSource; } else { originalDataSource = dataSource.\n   }\n\n   // If necessary, create a proxy data source based on the TargetDataSource.\n   return this.dataSourceProxyMap.computeIfAbsent(originalDataSource, originalDataSource, BranchType.\n           BranchType.XA == dataSourceProxyMode ? DataSourceProxyXA::new : DataSourceProxy::new); }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataSourceProxyHolder#putDataSource"})," method is used in two main places: in the ",(0,o.jsx)(t.code,{children:"SeataAutoDataSourceProxyAdvice"})," cutout; and in the ",(0,o.jsx)(t.code,{children:"SeataDataSourceBeanPostProcessor"}),".\nWhat problem does this judgement solve for us? The problem of multi-tier proxying of data sources. Think about the following scenarios with automatic data source proxying turned on:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["If we manually injected a ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," into our project, a call to the ",(0,o.jsx)(t.code,{children:"DataSourceProxyHolder#putDataSource"})," method in a cutover would return the ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," itself directly, without creating another ` DataSourceProxy"]}),"\n",(0,o.jsxs)(t.li,{children:["if we manually inject a ",(0,o.jsx)(t.code,{children:"DruidSource"})," into the project, then the ",(0,o.jsx)(t.code,{children:"DataSourceProxyHolder#putDataSource"})," method will create another ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for it and return it when it is called from the facet."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"It looks like the problem is solved, but is it possible that there are other problems? Take a look at the following code"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:"@Bean\npublic DataSourceProxy dsA(){\n   return new DataSourceProxy(druidA)\n}\n\n@Bean\npublic DataSourceProxy dsB(DataSourceProxy dsA){\n   return new DataSourceProxy(dsA)\n}\n"})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"this is definitely wrong, but you can't help it if he wants to write it this way"}),"\n",(0,o.jsxs)(t.li,{children:["there's nothing wrong with ",(0,o.jsx)(t.code,{children:"dsA"}),", but ",(0,o.jsx)(t.code,{children:"dsB"})," still has a double proxy problem, because the TargetDataSource of ",(0,o.jsx)(t.code,{children:"dsB"})," is ",(0,o.jsx)(t.code,{children:"dsA"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["This brings us to the ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," change."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"datasourceproxy",children:"DataSourceProxy"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'public DataSourceProxy(DataSource targetDataSource, String resourceGroupId) {\n   // The following judgement ensures that we don\'t have a two-tier proxy problem even when we pass in a DataSourceProxy\n   if (targetDataSource instanceof SeataDataSourceProxy) {\n       LOGGER.info("Unwrap the target data source, because the type is: {}", targetDataSource.getClass().getName());\n       targetDataSource = ((SeataDataSourceProxy) targetDataSource).getTargetDataSource();\n   }\n   this.targetDataSource = targetDataSource;\n   init(targetDataSource, resourceGroupId);\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"seatadatasourcebeanpostprocessor",children:"SeataDataSourceBeanPostProcessor"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'public class SeataDataSourceBeanPostProcessor implements BeanPostProcessor {\n   private static final Logger LOGGER = LoggerFactory.getLogger(SeataDataSourceBeanPostProcessor.class);\n\n   ......\n\n   @Override\n   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n       if (bean instanceof DataSource) {\n           //When not in the excludes, put and init proxy. if (!excludes.contains.\n           if (!excludes.contains(bean.getClass().getName())) {\n               //Only put and init proxy, not return proxy.\n               DataSourceProxyHolder.get().putDataSource((DataSource) bean, dataSourceProxyMode);\n           }\n\n           //If is SeataDataSourceProxy, return the original data source.\n           if (bean instanceof SeataDataSourceProxy) {\n               LOGGER.info("Unwrap the bean of the data source," +\n                   " and return the original data source to replace the data source proxy."); return ((SeataDataSourceProxy); } }\n               return ((SeataDataSourceProxy) bean).getTargetDataSource();\n           }\n       }\n       return bean.\n   }\n}\n'})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"SeataDataSourceBeanPostProcessor"})," implements the ",(0,o.jsx)(t.code,{children:"BeanPostProcessor"})," interface, which executes the ",(0,o.jsx)(t.code,{children:"BeanPostProcessor#postProcessAfterInitialization"})," method after a bean is initialised. That is, in the ",(0,o.jsx)(t.code,{children:"postProcessAfterInitialization"})," method, the bean is already available at this point."]}),"\n",(0,o.jsxs)(t.li,{children:["Why provide such a class? From its code, it is just to initialise the corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for the data source after the bean has been initialised, but why is this necessary?"]}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["Because some data sources may not be initialised (i.e. the relevant methods of the data source will not be called) after the application is started. If the ",(0,o.jsx)(t.code,{children:"SeataDataSourceBeanPostProcessor"})," class is not provided, then the ",(0,o.jsx)(t.code,{children:"DataSourceProxyHolder#putDataSource"})," method will only be triggered in the ",(0,o.jsx)(t.code,{children:"SeataAutoDataSourceProxyAdvice"})," cutout. If a client goes down during the rollback, after restarting, the Server sends it a rollback request via a timed task, at which point the client needs to first find the corresponding ",(0,o.jsx)(t.code,{children:"DatasourceProxy"})," based on the ",(0,o.jsx)(t.code,{children:"rsourceId"})," (connection address). However, if the client hasn't triggered the data source's related methods before then, it won't enter the ",(0,o.jsx)(t.code,{children:"SeataAutoDataSourceProxyAdvice"})," cutover logic, and won't initialise the corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for the data source, which will result in the failure of the rollback."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"multi-layer-proxy-summary",children:"Multi-Layer Proxy Summary"}),"\n",(0,o.jsxs)(t.p,{children:["Through the above analysis, we probably already know some optimisations of seata in avoiding multi-layer proxies, but there is actually one more issue to pay attention to:** Logical data source proxies**\n! ",(0,o.jsx)(t.a,{href:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6910095aadab436eaffe03a752e44240~tplv-k3u1fbpfcp-watermark.image"})]}),"\n",(0,o.jsxs)(t.p,{children:["The calling relationship at this point is: ",(0,o.jsx)(t.code,{children:"masterSlaveProxy -> masterSlave -> masterproxy/slaveProxy -> master/slave"})]}),"\n",(0,o.jsxs)(t.p,{children:["At this point you can exclude the logical datasource via the ",(0,o.jsx)(t.code,{children:"excludes"})," attribute so that no datasource proxy is created for it."]}),"\n",(0,o.jsx)(t.p,{children:"To summarise:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["when initialising the corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for a ",(0,o.jsx)(t.code,{children:"DataSource"}),", determine whether it is necessary to create a corresponding ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for it, and if it is a ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," itself, return it directly."]}),"\n",(0,o.jsxs)(t.li,{children:["For the case of manual injection of some ",(0,o.jsx)(t.code,{children:"DataSource"}),", in order to avoid the problem of multi-layer proxy caused by human error, we add a judgement in the constructor of ",(0,o.jsx)(t.code,{children:"DataSourceProxy"}),", ",(0,o.jsx)(t.code,{children:"If the input parameter TragetDatasource is a DataSourceProxy itself, then we get the target attribute of TragetDatasource as the target attribute of the new DataSourceProxy. TragetDatasource"})," of the new DataSourceProxy."]}),"\n",(0,o.jsxs)(t.li,{children:["for other cases, such as ",(0,o.jsx)(t.strong,{children:"logical data source proxy issues"}),", add exclusions to the ",(0,o.jsx)(t.code,{children:"excludes"})," attribute to avoid creating a ",(0,o.jsx)(t.code,{children:"DataSourceProxy"})," for the logical data source."]}),"\n"]}),"\n",(0,o.jsx)(t.h1,{id:"suggestions-for-using-global-and-local-transactions",children:"Suggestions for using global and local transactions"}),"\n",(0,o.jsxs)(t.p,{children:["There is a question, if there are multiple DB operations involved in a method, say 3 update operations are involved, do we need to use ",(0,o.jsx)(t.code,{children:"@Transactional"})," annotation in spring for this method? We consider this question from two perspectives: without ",(0,o.jsx)(t.code,{children:"@Transactional"})," annotation and with ",(0,o.jsx)(t.code,{children:"@Transactional"})," annotation."]}),"\n",(0,o.jsxs)(t.h2,{id:"not-using-the-transactional-annotation",children:["Not using the ",(0,o.jsx)(t.code,{children:"@Transactional"})," annotation"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"in the commit phase, since the branch transaction has 3 update operations, each time the update operation is executed, a branch transaction will be registered with the TC through the data broker and a corresponding undo_log will be generated for it, so that the 3 update operations will be treated as 3 branch transactions"}),"\n",(0,o.jsx)(t.li,{children:"In the rollback phase, the three branch transactions need to be rolled back."}),"\n",(0,o.jsx)(t.li,{children:"data consistency is ensured by the seata global transaction."}),"\n"]}),"\n",(0,o.jsxs)(t.h2,{id:"use-the-transactional-annotation",children:["Use the ",(0,o.jsx)(t.code,{children:"@Transactional"})," annotation."]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"in the commit phase, the three update operations are committed as one branch transaction, so only one branch transaction will be registered in the end"}),"\n",(0,o.jsx)(t.li,{children:"in the rollback phase, 1 branch transaction needs to be rolled back."}),"\n",(0,o.jsx)(t.li,{children:"data consistency: the 3 update operations are guaranteed by the consistency of the local transaction; global consistency is guaranteed by the seata global transaction. At this point, the 3 updates are just a branch transaction."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Through the above comparison, the answer is obvious, the reasonable use of local transactions can greatly improve the processing speed of global transactions. The above is just 3 DB operations, what if there are more DB operations involved in a method, then the difference between the two ways is not greater?"}),"\n",(0,o.jsx)(t.p,{children:"Finally, thanks to @FUNKYE for answering a lot of questions and providing valuable suggestions!"})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var o=n(96540);const a={},r=o.createContext(a);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);
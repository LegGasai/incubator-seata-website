"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[97447],{22396:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var o=t(74848),s=t(28453);const i={title:"Detailed Explanation of seata-golang Communication Model",keywords:["seata","seata-golang","seata-go","getty","distributed transaction"],description:"This article provides a detailed explanation of the underlying RPC communication implementation in seata-golang.",author:"xiaomin.liu",date:"2021/01/04"},a="The getty-based seata-golang communication model",r={permalink:"/blog/seata-golang-communication-mode",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-golang-communication-mode.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-golang-communication-mode.md",title:"Detailed Explanation of seata-golang Communication Model",description:"This article provides a detailed explanation of the underlying RPC communication implementation in seata-golang.",date:"2021-01-04T00:00:00.000Z",formattedDate:"January 4, 2021",tags:[],readingTime:16.875,hasTruncateMarker:!1,authors:[{name:"xiaomin.liu"}],frontMatter:{title:"Detailed Explanation of seata-golang Communication Model",keywords:["seata","seata-golang","seata-go","getty","distributed transaction"],description:"This article provides a detailed explanation of the underlying RPC communication implementation in seata-golang.",author:"xiaomin.liu",date:"2021/01/04"},unlisted:!1,prevItem:{title:"Analysis of Seata Configuration Management Principles",permalink:"/blog/seata-config-manager"},nextItem:{title:"Analysis of Seata Data Source Proxy",permalink:"/blog/seata-datasource-proxy"}},c={authorsImageUrls:[void 0]},l=[{value:"I. Introduction",id:"i-introduction",level:2},{value:"How to implement RPC communication based on getty?",id:"how-to-implement-rpc-communication-based-on-getty",level:2},{value:"1. Establish Connection",id:"1-establish-connection",level:3},{value:"2. Sending and Receiving Messages",id:"2-sending-and-receiving-messages",level:3},{value:"3. How to decouple the underlying network message processing logic from the business logic",id:"3-how-to-decouple-the-underlying-network-message-processing-logic-from-the-business-logic",level:3},{value:"4. Implementation",id:"4-implementation",level:3},{value:"4.1 Codec Protocol Implementation",id:"41-codec-protocol-implementation",level:4},{value:"4.2 Client Side Implementation",id:"42-client-side-implementation",level:4},{value:"4.3 Server-side Transaction Coordinator Implementation",id:"43-server-side-transaction-coordinator-implementation",level:4},{value:"4.4 Session Manager Analysis",id:"44-session-manager-analysis",level:4},{value:"III. The Future of seata-golang",id:"iii-the-future-of-seata-golang",level:2},{value:"<strong>Author Bio</strong>",id:"author-bio",level:3},{value:"References",id:"references",level:4}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Author | Liu Xiaomin Yu Yu"}),"\n",(0,o.jsx)(n.h2,{id:"i-introduction",children:"I. Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["In the Java world, netty is a widely used high-performance network communication framework, and many RPC frameworks are based on netty. In the golang world, ",(0,o.jsx)(n.a,{href:"https://github.com/AlexStocks/getty",children:"getty"})," is also a high-performance network communication library similar to netty. getty was originally developed by Yu Yu, the leader of the dubbogo project, and is available in ",(0,o.jsx)(n.a,{href:"https://",children:"dubbo-go"})," as an underlying communication library. github.com/apache/dubbo-go). With the donation of dubbo-go to the apache foundation, getty eventually made its way into the apache family and was renamed ",(0,o.jsx)(n.a,{href:"https://github.com/apache/dubbo-getty",children:"dubbo-getty"}),", thanks to the efforts of the community."]}),"\n",(0,o.jsx)(n.p,{children:"In '18, I was practicing microservices in my company, and the biggest problem I encountered at that time was distributed transactions. In the same year, Ali open-sourced their distributed transaction solution in the community, and I quickly noticed this project, which was initially called fescar, but later renamed seata. Since I was very interested in open source technology, I added a lot of community groups, and at that time, I also paid attention to the dubbo-go project, and silently dived in it. As I learnt more about seata, the idea of making a go version of a distributed transaction framework gradually emerged."}),"\n",(0,o.jsx)(n.p,{children:"To make a golang version of distributed transaction framework, one of the first problems is how to achieve RPC communication. dubbo-go is a very good example in front of us, so we started to study the underlying getty of dubbo-go."}),"\n",(0,o.jsx)(n.h2,{id:"how-to-implement-rpc-communication-based-on-getty",children:"How to implement RPC communication based on getty?"}),"\n",(0,o.jsx)(n.p,{children:"The overall model of the getty framework is as follows:"}),"\n",(0,o.jsxs)(n.p,{children:["! [image.png]( ",(0,o.jsx)(n.a,{href:"https://img.alicdn.com/imgextra/i1/O1CN011TIcL01jY4JaweOfV",children:"https://img.alicdn.com/imgextra/i1/O1CN011TIcL01jY4JaweOfV"}),"_! !6000000004559-2-tps-954-853.png)"]}),"\n",(0,o.jsx)(n.p,{children:"The following is a detailed description of the RPC communication process of seata-golang with related code."}),"\n",(0,o.jsx)(n.h3,{id:"1-establish-connection",children:"1. Establish Connection"}),"\n",(0,o.jsxs)(n.p,{children:["To implement RPC communication, we need to establish a network connection first, let's start from ",(0,o.jsx)(n.a,{href:"https://github.com/apache/dubbo-getty/blob/master/client.go",children:"client.go"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (c *client) connect() {\n var (\n  err error\n  ss Session\n )\n\n for {\n       // Create a session connection\n  ss = c.dial()\n  if ss == nil {\n   if ss == nil { // client has been closed\n   if ss == nil { // client has been closed\n  }\n  err = c.newSession(ss)\n  if err == nil {\n           // send and receive messages\n   ss.(*session).run()\n   // Omit some code here\n\n   break\n  }\n  // don't distinguish between tcp connection and websocket connection. because\n  // gorilla/websocket/conn.go:(Conn)Close also invoke net.Conn.Close()\n  ss.Conn().Close()\n Close()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"connect()"})," method gets a session connection via the ",(0,o.jsx)(n.code,{children:"dial()"})," method into the dial() method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"func (c *client) dial() Session {\nswitch c.endPointType {\ncase TCP_CLIENT.\nreturn c.dialTCP()\ncase UDP_CLIENT: return c.dialUDP()\nreturn c.dialUDP()\ncase WS_CLIENT: return c.dialWS()\nreturn c.dialWS()\ncase WSS_CLIENT: return c.dialWSS()\nreturn c.dialWSS()\n}\n\nreturn nil\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We're concerned with TCP connections, so we continue into the ",(0,o.jsx)(n.code,{children:"c.dialTCP()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func (c *client) dialTCP() Session {\n var (\n  err error\n  conn net.\n )\n\n for {\n  if c.IsClosed() {\n   return nil\n  }\n  if c.sslEnabled {\n   if sslConfig, err := c.tlsConfigBuilder.BuildTlsConfig(); err == nil && sslConfig ! = nil {\n    d := &net.Dialer{Timeout: connectTimeout}\n    // Establish an encrypted connection\n    conn, err = tls.DialWithDialer(d, "tcp", c.addr, sslConfig)\n   }\n  } else {\n           // Establish a tcp connection\n   conn, err = net.DialTimeout("tcp", c.addr, connectTimeout)\n  }\n  if err == nil && gxnet.IsSameAddr(conn.RemoteAddr(), conn.LocalAddr()) {\n   conn.Close()\n   err = errSelfConnect\n  }\n  if err == nil {\n           // Return a TCPSession\n   return newTCPSession(conn, c)\n  }\n\n  log.Infof("net.DialTimeout(addr:%s, timeout:%v) = error:%+v", c.addr, connectTimeout, perrors.WithStack(err))\n  <-wheel.After(connectInterval)\n }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"At this point, we know how getty establishes a TCP connection and returns a TCPSession."}),"\n",(0,o.jsx)(n.h3,{id:"2-sending-and-receiving-messages",children:"2. Sending and Receiving Messages"}),"\n",(0,o.jsxs)(n.p,{children:["How does it send and receive messages? Let's go back to the connection method and look at the next line, which is ",(0,o.jsx)(n.code,{children:"ss.(*session).run()"}),". After this line of code, the code is a very simple operation, so we guess that the logic of this line of code must include sending and receiving messages, and then go to the ",(0,o.jsx)(n.code,{children:"run()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (s *session) run() {\n// Omit some of the code\n\ngo s.handleLoop()\ngo s.handlePackage()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There are two goroutines up here, ",(0,o.jsx)(n.code,{children:"handleLoop"})," and ",(0,o.jsx)(n.code,{children:"handlePackage"}),", which literally match our guesses into the ",(0,o.jsx)(n.code,{children:"handleLoop()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func (s *session) handleLoop() {\n   // Omit some of the code\n\n for {\n  // A select blocks until one of its cases is ready to run.\n  // It choose one at random if multiple are ready. Otherwise it choose default branch if none is ready.\n  It choose one at random if multiple are ready.\n  // Otherwise it choose default branch if none is ready.\n\n  case outPkg, ok = <-s.wQ.\n   // Omit some of the code\n\n   iovec = iovec[:0]\n   for idx := 0; idx < maxIovecNum; idx++ {\n       // Encode interface{} type outPkg into binary bits via s.writer\n    pkgBytes, err = s.writer.Write(s, outPkg)\n    // Omit some of the code\n\n    iovec = append(iovec, pkgBytes)\n\n               // omit some code\n   }\n           // Send these binary bits out\n   err = s.WriteBytesArray(iovec[:]...)\n   if err ! = nil {\n    log.Errorf("%s, [session.handleLoop]s.WriteBytesArray(iovec len:%d) = error:%+v",\n     s.sessionToken(), len(iovec), perrors.WithStack(err))\n    s.stop()\n    // break LOOP\n    flag = false\n   }\n\n  case <-wheel.After(s.period).\n   if flag {\n    if wsFlag {\n     err := wsConn.writePing()\n     if err ! = nil {\n      log.Warnf("wsConn.writePing() = error:%+v", perrors.WithStack(err))\n     }\n    }\n               // Logic for timed execution, heartbeat, etc.\n    s.listener.OnCron(s)\n   }\n  }\n }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["With the above code, it is easy to see that the ",(0,o.jsx)(n.code,{children:"handleLoop()"})," method handles the logic of sending the message, which is encoded into binary bits by ",(0,o.jsx)(n.code,{children:"s.writer"})," and then sent over the established TCP connection. This ",(0,o.jsx)(n.code,{children:"s.writer"})," corresponds to the Writer interface, which is an interface that must be implemented by the RPC framework."]}),"\n",(0,o.jsxs)(n.p,{children:["Moving on to the ",(0,o.jsx)(n.code,{children:"handlePackage()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func (s *session) handlePackage() {\n// Omit some of the code\n\nif _, ok := s.Connection.(*gettyTCPConn); ok {\nif s.reader == nil {\nerrStr := fmt.Sprintf("session{name:%s, conn:%#v, reader:%#v}", s.name, s.Connection, s.reader)\nlog.Error(errStr)\npanic(errStr)\n}\n\nerr = s.handleTCPPackage()\n} else if _, ok := s.Connection.(*gettyWSConn); ok {\nerr = s.handleWSPackage()\n} else if _, ok := s.Connection.(*gettyUDPConn); ok {\nerr = s.handleUDPPackage()\n} else {\npanic(fmt.Sprintf("unknown type session{%#v}", s))\n}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Go to the ",(0,o.jsx)(n.code,{children:"handleTCPPackage()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (s *session) handleTCPPackage() error {\n   // Omit some of the code\n\n conn = s.Connection.(*gettyTCPConn)\n for {\n  // omit some code\n\n  bufLen = 0\n  for {\n   // for clause for the network timeout condition check\n   // s.conn.SetReadTimeout(time.Now().Add(s.rTimeout))\n           // Receive a message from the TCP connection\n   bufLen, err = conn.recv(buf)\n   // Omit some of the code\n\n   break\n  }\n  // Omit part of the code\n\n       // Write the binary bits of the received message to pkgBuf\n  pktBuf.Write(buf[:bufLen])\n  for {\n   if pktBuf.Len() <= 0 {\n    Write(buf[:bufLen]) for { if pktBuf.\n   }\n           // Decode the received message into an RPC message via s.reader\n   pkg, pkgLen, err = s.reader.Read(s, pktBuf.Bytes())\n   // Omit some of the code\n\n     s.UpdateActive()\n           // Put the received message into a TaskQueue for consumption by the RPC consumer.\n   s.addTask(pkg)\n   pktBuf.Next(pkgLen)\n   // continue to handle case 5\n  If exit { pktBuf.Next(pkgLen) // continue to handle case 5\n  if exit {\n   pktBuf.Next(pkgLen) // continue to handle case 5 } if exit {\n  }\n }\n\n return perrors.WithStack(err)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"From the above code logic, we analyse that the RPC consumer needs to decode the binary bits received from the TCP connection into messages that can be consumed by RPC, and this work is implemented by s.reader, so we need to implement the Reader interface corresponding to s.reader in order to build the RPC communication layer."}),"\n",(0,o.jsx)(n.h3,{id:"3-how-to-decouple-the-underlying-network-message-processing-logic-from-the-business-logic",children:"3. How to decouple the underlying network message processing logic from the business logic"}),"\n",(0,o.jsx)(n.p,{children:"We all know that netty decouples the underlying network logic from the business logic through the boss thread and the worker thread. So how does getty do it?"}),"\n",(0,o.jsxs)(n.p,{children:["At the end of the ",(0,o.jsx)(n.code,{children:"handlePackage()"})," method, we see that the incoming message is put into the ",(0,o.jsx)(n.code,{children:"s.addTask(pkg)"})," method, so let's move on:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (s *session) addTask(pkg interface{}) {\nf := func() {\ns.listener.OnMessage(s, pkg)\ns.incReadPkgNum()\n}\nif taskPool := s.EndPoint().GetTaskPool(); taskPool ! = nil {\ntaskPool.AddTaskAlways(f)\nreturn\n}\nf()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"pkg"})," argument is passed to an anonymous method that ends up in ",(0,o.jsx)(n.code,{children:"taskPool"}),". This method is critical, and I ran into a pitfall later on when I wrote the seata-golang code, which is analysed later."]}),"\n",(0,o.jsxs)(n.p,{children:["Next we look at the definition of ",(0,o.jsx)(n.a,{href:"https://github.com/dubbogo/gost/blob/master/sync/task_pool.go",children:"taskPool"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// NewTaskPoolSimple builds a simple task pool.\nfunc NewTaskPoolSimple(size int) GenericTaskPool {\n if size < 1 {\n  size = runtime.NumCPU() * 100\n NumCPU() * 100 }\n return &taskPoolSimple{\n  work: make(chan task), sem: make(chan struct{task\n  sem:  make(chan struct{}, size),\n  done: make(chan struct{}),\n }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Builds a channel ",(0,o.jsx)(n.code,{children:"sem"})," with a buffer size of size (defaults to ",(0,o.jsx)(n.code,{children:"runtime.NumCPU() * 100"}),"). Then look at the method ",(0,o.jsx)(n.code,{children:"AddTaskAlways(t task)"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (p *taskPoolSimple) AddTaskAlways(t task) {\nselect {\ncase <-p.done.\nreturn\ndefault.\n}\n\nselect {\ncase p.work <- t.\nreturn\ndefault: }\n}\nselect {\ncase p.work <- t: return default: }\ncase p.sem <- struct{}{}.\np.wg.Add(1)\ngo p.worker(t)\ndefault.\ngoSafely(t)\n}\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"When a task is added, it is consumed by len(p.sem) goroutines, and if no goroutine is free, a temporary goroutine is started to run t(). This is equivalent to having len(p.sem) goroutines to form a goroutine pool, and the goroutines in the pool process business logic instead of the goroutines that process network messages to run business logic, thus achieving decoupling. One of the pitfalls I encountered when writing seata-golang was that I forgot to set the taskPool, which resulted in the same goroutine handling the business logic and the underlying network message logic. When I blocked the business logic and waited for a task to complete, I blocked the entire goroutine, and I couldn't receive any messages during the blocking period."}),"\n",(0,o.jsx)(n.h3,{id:"4-implementation",children:"4. Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["The following code is available at ",(0,o.jsx)(n.a,{href:"https://github.com/apache/dubbo-getty/blob/master/getty.go",children:"getty.go"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// Reader is used to unmarshal a complete pkg from buffer\ntype Reader interface {\n Read(Session, []byte) (interface{}, int, error)\n}\n\n// Writer is used to marshal a pkg and write to session.\ntype Writer interface {\n // If @Session is udpGettySession, the second parameter is UDPContext.\n Write(Session, interface{}) ([]byte, error)\nWrite(Session, interface{}) ([]byte, error) }\n\n// ReadWriter interface use for handle application packages.\ntype ReadWriter interface {\n Writer\n Writer\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"// EventListener is used to process pkg that received from remote session\ntype EventListener interface {\n // invoked when session opened\n // If the return error is not nil, @Session will be closed.\n OnOpen(Session) error\n\n OnOpen(Session) error // invoked when session closed.\n EventListener { // invoked when session opened // If the return error is not nil, @Session will be closed.)\n\n OnOpen(Session) error // invoked when session closed.\n OnError(Session, error)\n\n // invoked periodically, its period can be set by (Session)SetCronPeriod\n OnCron(Session)\n\n // invoked when getty received a package. Pls attention that do not handle long time\n // logic processing in this func. You'd better set the package's maximum length.\n // If the message's length is greater than it, u should should return err in\n If the message's length is greater than it, u should should return err in // Reader{Read} and getty will close this connection soon.\n // If ur logic processing in this func\n // If ur logic processing in this func will take a long time, u should start a goroutine\n // If ur logic processing in this func will take a long time, u should start a goroutine pool (like working thread pool in cpp) to handle the processing asynchronously.\n // can do the logic processing in other asynchronous way.\n Or u // can do the logic processing in other asynchronous way. !In short, ur OnMessage callback func should return asap.\n // In short, ur OnMessage callback func should return asap.\n // If this is a udp event listener, the second parameter type is UDPContext.\n OnMessage(Session, interface{})\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["By analysing the entire getty code, we only need to implement ",(0,o.jsx)(n.code,{children:"ReadWriter"})," to encode and decode RPC messages, and then implement ",(0,o.jsx)(n.code,{children:"EventListener"})," to handle the corresponding specific logic of RPC messages, and then inject the ",(0,o.jsx)(n.code,{children:"ReadWriter"})," implementation and the ",(0,o.jsx)(n.code,{children:"EventLister"})," implementation into the Client and Server sides of RPC, then we can implement RPC communication. Inject the ",(0,o.jsx)(n.code,{children:"ReadWriter"})," implementation and ",(0,o.jsx)(n.code,{children:"EventLister"})," implementation into the Client and Server side of RPC to achieve RPC communication."]}),"\n",(0,o.jsx)(n.h4,{id:"41-codec-protocol-implementation",children:"4.1 Codec Protocol Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["The following is the definition of the seata protocol:\n! [image-20201205214556457.png](",(0,o.jsx)(n.a,{href:"https://cdn.nlark.com/yuque/0/2020/png/737378/1607180799872-5f96afb6-680d-4e69-8c95-b8fd1ac4c3a7.png",children:"https://cdn.nlark.com/yuque/0/2020/png/737378/1607180799872-5f96afb6-680d-4e69-8c95-b8fd1ac4c3a7.png"})," #align=left&display=inline&height=209&margin=%5Bobject%20Object%5D&name=image-20201205214556457.png& originHeight=209&originWidth=690&size=18407&status=done&style=none&width=690)"]}),"\n",(0,o.jsxs)(n.p,{children:["In the ReadWriter interface implementation ",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang",children:(0,o.jsx)(n.code,{children:"RpcPackageHandler"})}),", call the Codec method to codec the message body in the above format:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'// Encode the message into binary bits\nfunc MessageEncoder(codecType byte, in interface{}) []byte {\nswitch codecType {\ncase SEATA.\nreturn SeataEncoder(in)\ndefault.\nlog.Errorf("not support codecType, %s", codecType)\nreturn nil\n}\n}\n\n// Decode the binary bits into the message body\nfunc MessageDecoder(codecType byte, in []byte) (interface{}, int) {\nswitch codecType {\ncase SEATA.\nreturn SeataDecoder(in)\ndefault.\nlog.Errorf("not support codecType, %s", codecType)\nreturn nil, 0\n}\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"42-client-side-implementation",children:"4.2 Client Side Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at the client-side implementation of ",(0,o.jsx)(n.code,{children:"EventListener"})," [",(0,o.jsx)(n.code,{children:"RpcRemotingClient"}),"](",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/rpc_remoting_client",children:"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/rpc_remoting_client"}),". go):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func (client *RpcRemoteClient) OnOpen(session getty.Session) error {\n go func()\n  request := protocal.RegisterTMRequest{AbstractIdentifyRequest: protocal.\n   ApplicationId: client.conf.\n   TransactionServiceGroup: client.conf.\n  }}\n   // Once the connection is established, make a request to the Transaction Coordinator to register the TransactionManager.\n  _, err := client.sendAsyncRequestWithResponse(session, request, RPC_REQUEST_TIMEOUT)\n  if err == nil {\n     // Save the connection to the Transaction Coordinator in the connection pool for future use.\n   clientSessionManager.RegisterGettySession(session)\n   client.GettySessionOnOpenChannel <- session.RemoteAddr()\n  }\n }()\n\n return nil\n}\n\n// OnError ...\nfunc (client *RpcRemoteClient) OnError(session getty.Session, err error) {\n clientSessionManager.ReleaseGettySession(session)\n}\n\n// OnClose ...\nfunc (client *RpcRemoteClient) OnClose(session getty.Session) {\n clientSessionManager.ReleaseGettySession(session)\n}\n\n// OnMessage ...\nfunc (client *RpcRemoteClient) OnMessage(session getty.Session, pkg interface{}) {\n log.Info("received message:{%v}", pkg)\n rpcMessage, ok := pkg.(clientRpcRemoteClient.Session, pkg interface{}) { log.Info("received message:{%v}", pkg)\n if ok {\n  heartBeat, isHeartBeat := rpcMessage.Body.(protocal.HeartBeatMessage)\n  if isHeartBeat && heartBeat == protocal.HeartBeatMessagePong {\n   log.Debugf("received PONG from %s", session.RemoteAddr())\n  }\n }\n\n if rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST ||\n  rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST_ONEWAY {\n  log.Debugf("msgId:%s, body:%v", rpcMessage.Id, rpcMessage.Body)\n\n  // Process the transaction message, commit or rollback\n  client.onMessage(rpcMessage, session.RemoteAddr())\n } else {\n  resp, loaded := client.futures.Load(rpcMessage.Id)\n  if loaded {\n   response := resp.(*getty2.MessageFuture)\n   response.Response = rpcMessage.Body\n   response.Done <- true\n   client.futures.Delete(rpcMessage.Id)\n  }\n }\n}\n\n// OnCron ...\nfunc (client *RpcRemoteClient) OnCron(session getty.Session) {\n // Send a heartbeat\n client.defaultSendRequest(session, protocal.HeartBeatMessagePing)\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The logic of ",(0,o.jsx)(n.code,{children:"clientSessionManager.RegisterGettySession(session)"})," is analysed in subsection 4.4."]}),"\n",(0,o.jsx)(n.h4,{id:"43-server-side-transaction-coordinator-implementation",children:"4.3 Server-side Transaction Coordinator Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang/blob/dev/tc/server/default_coordinator_event_listener.go",children:(0,o.jsx)(n.code,{children:"DefaultCoordinator"})})," for code:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func (coordinator *DefaultCoordinator) OnOpen(session getty.Session) error {\n log.Infof("got getty_session:%s", session.Stat())\n error { log.Infof("got getty_session:%s", session.Stat())\n}\n\nfunc (coordinator *DefaultCoordinator) OnError(session getty.Session, err error) {\n // Release the TCP connection\n SessionManager.ReleaseGettySession(session)\n session.Close()\n log.Errorf("getty_session{%s} got error{%v}, will be closed.", session.Stat(), err)\n}\n\nfunc (coordinator *DefaultCoordinator) OnClose(session getty.Session) {\n log.Info("getty_session{%s} is closing......" , session.Stat())\n}\n\nfunc (coordinator *DefaultCoordinator) OnMessage(session getty.Session, pkg interface{}) {\n log.Debugf("received message:{%v}", pkg)\n rpcMessage, ok := pkg.(protocal.)\n RpcMessage) if ok {\n  _, isRegTM := rpcMessage.Body.(protocal.RegisterTMRequest)\n  if isRegTM {\n     // Map the TransactionManager information to the TCP connection.\n   coordinator.OnRegTmMessage(rpcMessage, session)\n   OnRegTmMessage(rpcMessage, session)\n  }\n\n  heartBeat, isHeartBeat := rpcMessage.Body.(protocal.HeartBeatMessage)\n  if isHeartBeat && heartBeat == protocal.HeartBeatMessagePing {\n   coordinator.OnCheckMessage(rpcMessage, session)\n   OnCheckMessage(rpcMessage, session)\n  }\n\n  if rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST ||\n   rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST_ONEWAY {\n   log.Debugf("msgId:%s, body:%v", rpcMessage.Id, rpcMessage.Body)\n   _, isRegRM := rpcMessage.Body.(protocal.RegisterRMRequest)\n   if isRegRM {\n       // Map the ResourceManager information to the TCP connection.\n    coordinator.OnRegRmMessage(rpcMessage, session)\n   } else {\n    if SessionManager.IsRegistered(session) {\n     if err := recover(); } else { if SessionManager.IsRegistered(session) {\n      if err := recover(); err ! = nil { log.Errorf(); err !\n       log.Errorf("Catch Exception while do RPC, request: %v,err: %w", rpcMessage, err)\n      }\n     }()\n         // Handle transaction messages, global transaction registration, branch transaction registration, branch transaction commit, global transaction rollback, etc.\n     coordinator.OnTrxMessage(rpcMessage, session)\n    } else {\n     session.Close()\n     log.Infof("Close an unhandled connection! [%v]", session)\n    }\n   }\n  } else {\n   resp, loaded := coordinator.futures.Load(rpcMessage.Id)\n   if loaded {\n    response := resp.(*getty2.MessageFuture)\n    response.Response = rpcMessage.Body\n    response.Done <- true\n    coordinator.futures.Delete(rpcMessage.Id)\n   }\n  }\n }\n}\n\nfunc (coordinator *DefaultCoordinator) OnCron(session getty.Session) {\n\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"coordinator.OnRegTmMessage(rpcMessage, session)"})," registers the Transaction Manager, ",(0,o.jsx)(n.code,{children:"coordinator.OnRegRmMessage(rpcMessage, session)"})," registers the Resource The logic is analysed in Section 4.4.\nThe message enters the ",(0,o.jsx)(n.code,{children:"coordinator.OnTrxMessage(rpcMessage, session)"})," method and is routed to the specific logic according to the message type code:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"switch msg.GetTypeCode() {\ncase protocal.TypeGlobalBegin:\nreq := msg.(protocal.GlobalBeginRequest)\nresp := coordinator.doGlobalBegin(req, ctx)\nreturn resp\ncase protocal.TypeGlobalStatus.\nTypeGlobalStatus. req := msg.(protocal.GlobalStatusRequest)\nresp := coordinator.doGlobalStatus(req, ctx)\nreturn resp\ncase protocal.TypeGlobalReport.\nreq := msg.(protocal.GlobalReportRequest)\nresp := coordinator.doGlobalReport(req, ctx)\nreturn resp\ncase protocal.TypeGlobalCommit.\nreq := msg.(protocal.GlobalCommitRequest)\nresp := coordinator.doGlobalCommit(req, ctx)\nreturn resp\ncase protocal.TypeGlobalRollback.\nreq := msg.(protocal.GlobalRollbackRequest)\nresp := coordinator.doGlobalRollback(req, ctx)\nreturn resp\ncase protocal.TypeBranchRegister.\nTypeBranchRegister. req := msg.(protocal.BranchRegisterRequest)\nresp := coordinator.doBranchRegister(req, ctx)\nreturn resp\ncase protocal.TypeBranchStatusReport.\nTypeBranchStatusReport: req := msg.(protocal.BranchReportRequest)\nresp := coordinator.doBranchReport(req, ctx)\nreturn resp\ndefault.\nreturn nil\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"44-session-manager-analysis",children:"4.4 Session Manager Analysis"}),"\n",(0,o.jsxs)(n.p,{children:["After the Client establishes a connection with the Transaction Coordinator, it saves the connection in the map ",(0,o.jsx)(n.code,{children:"serverSessions = sync.Map{}"})," by using ",(0,o.jsx)(n.code,{children:"clientSessionManager.RegisterGettySession(session)"}),". The key of the map is the RemoteAddress of the Transaction Coordinator obtained from the session, and the value is the session. This allows the Client to register the Transaction Manager and Resource Manager with the Transaction Coordinator through a session in the map. See [",(0,o.jsx)(n.code,{children:"getty_client_session_manager.go"}),"]. (",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/getty_client_session_manager.go",children:"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/getty_client_session_manager.go"}),")\nAfter the Transaction Manager and Resource Manager are registered with the Transaction Coordinator, a connection can be used to send either TM messages or RM messages. We identify a connection with an RpcContext:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type RpcContext struct {\n Version string\n TransactionServiceGroup string\n ClientRole meta.TransactionRole\n ApplicationId string\n ClientId string\n ResourceSets *model.\n Session getty.\nSession }\n"})}),"\n",(0,o.jsx)(n.p,{children:"When a transaction message is received, we need to construct such an RpcContext to be used by the subsequent transaction logic. So, we will construct the following map to cache the mapping relationships:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"var (\n // session -> transactionRole\n // TM will register before RM, if a session is not the TM registered, // it will be the RM registered.\n // it will be the RM registered\n session_transactionroles = sync.Map{}\n\n // session -> applicationId\n identified_sessions = sync.Map{}\n\n // applicationId -> ip -> port -> session\n client_sessions = sync.Map{}\n\n // applicationId -> resourceIds\n client_resources = sync.Map{}\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this way, the Transaction Manager and Resource Manager are registered to the Transaction Coordinator via ",(0,o.jsx)(n.code,{children:"coordinator.OnRegTmMessage(rpcMessage, session)"})," and ",(0,o.jsx)(n.code,{children:"coordinator.OnRegRmMessage(rpcMessage, session)"})," respectively. session)",(0,o.jsx)(n.code,{children:" are registered with the Transaction Coordinator, the relationship between applicationId, ip, port and session is cached in the above client_sessions map, and the relationship between applicationId, ip, port and resourceIds (an application may be able to register with the Transaction Coordinator) is cached in the client_resources map. and resourceIds (there may be multiple Resource Managers for an application) in the client_resources map. When needed, we can construct an RpcContext from these mappings, which is very different from the java version of seata, so if you're interested, you can dig a little deeper. See ["}),"getty_session_manager.go`]. (",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang/blob/dev/tc/server/getty_session_manager.go",children:"https://github.com/opentrx/seata-golang/blob/dev/tc/server/getty_session_manager.go"}),")\nAt this point, we have analysed ",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang",children:"seata-golang"})," the entire mechanism of the RPC communication model."]}),"\n",(0,o.jsx)(n.h2,{id:"iii-the-future-of-seata-golang",children:"III. The Future of seata-golang"}),"\n",(0,o.jsxs)(n.p,{children:["The development of ",(0,o.jsx)(n.a,{href:"https://github.com/opentrx/seata-golang",children:"seata-golang"})," started in April this year, and in August it basically realised the interoperability with the java version of ",(0,o.jsx)(n.a,{href:"https://github.com/apache/incubator-",children:"seata 1.2"})," protocol. seata) protocol, implemented AT mode for mysql database (automatically coordinating the commit rollback of distributed transactions), implemented TCC mode, and used mysql to store data on the TC side, which turned TC into a stateless application to support high-availability deployment. The following figure shows the principle of AT mode: ! [image20201205-232516.png]( ",(0,o.jsx)(n.a,{href:"https://img.alicdn.com/imgextra/i3/O1CN01alqsQS1G2oQecFYIs",children:"https://img.alicdn.com/imgextra/i3/O1CN01alqsQS1G2oQecFYIs"}),"_! !6000000000565-2-tps-1025-573.png)"]}),"\n",(0,o.jsx)(n.p,{children:"There is still a lot of work to be done, such as support for the registry, support for the configuration centre, protocol interoperability with the java version of seata 1.4, support for other databases, implementation of the craft transaction coordinator, etc. We hope that developers interested in the distributed transaction problem can join in to build a perfect golang's distributed transaction framework."}),"\n",(0,o.jsx)(n.p,{children:"If you have any questions, please feel free to join the group [group number 33069364]:"}),"\n",(0,o.jsx)("img",{src:"https://img.alicdn.com/imgextra/i2/O1CN01IjOVG425erjuzqcOi_! !6000000007552-2-tps-600-621.png",width:"200px"}),"\n",(0,o.jsx)(n.h3,{id:"author-bio",children:(0,o.jsx)(n.strong,{children:"Author Bio"})}),"\n",(0,o.jsx)(n.p,{children:"Xiaomin Liu (GitHubID dk-lockdown), currently working at h3c Chengdu, is good at using Java/Go language, and has dabbled in cloud-native and microservices related technologies, currently specialising in distributed transactions.\nYu Yu (github @AlexStocks), dubbo-go project and community leader, a programmer with more than 10 years of frontline experience in server-side infrastructure R&D, has participated in the improvement of Muduo/Pika/Dubbo/Sentinel-go and other well-known projects, and is currently engaged in container orchestration and service mesh work in the Trusted Native Department of ants. Currently, he is working on container orchestration and service mesh in the Trusted Native Department of AntGold."}),"\n",(0,o.jsx)(n.h4,{id:"references",children:"References"}),"\n",(0,o.jsxs)(n.p,{children:["seata official: ",(0,o.jsx)(n.a,{href:"https://seata.apache.org",children:"https://seata.apache.org"})]}),"\n",(0,o.jsxs)(n.p,{children:["java version seata\uff1a",(0,o.jsx)(n.a,{href:"https://github.com/apache/incubator-seata",children:"https://github.com/apache/incubator-seata"})]}),"\n",(0,o.jsxs)(n.p,{children:["seata-golang project address: ",(0,o.jsx)(n.a,{href:"https://github.com/apache/incubator-seata-go",children:"https://github.com/apache/incubator-seata-go"})]}),"\n",(0,o.jsxs)(n.p,{children:["seata-golang go night reading b\u7ad9\u5206\u4eab\uff1a",(0,o.jsx)(n.a,{href:"https://www.bilibili.com/video/BV1oz411e72T",children:"https://www.bilibili.com/video/BV1oz411e72T"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(96540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);